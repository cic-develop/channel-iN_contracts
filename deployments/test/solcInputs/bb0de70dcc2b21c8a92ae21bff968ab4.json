{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n */\ninterface IVotes {\n    /**\n     * @dev The signature used has expired.\n     */\n    error VotesExpiredSignature(uint256 expiry);\n\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of voting units.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousVotes, uint256 newVotes);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     */\n    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "@openzeppelin/contracts/governance/utils/Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (governance/utils/Votes.sol)\npragma solidity ^0.8.20;\n\nimport {IERC5805} from \"../../interfaces/IERC5805.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Nonces} from \"../../utils/Nonces.sol\";\nimport {EIP712} from \"../../utils/cryptography/EIP712.sol\";\nimport {Checkpoints} from \"../../utils/structs/Checkpoints.sol\";\nimport {SafeCast} from \"../../utils/math/SafeCast.sol\";\nimport {ECDSA} from \"../../utils/cryptography/ECDSA.sol\";\nimport {Time} from \"../../utils/types/Time.sol\";\n\n/**\n * @dev This is a base abstract contract that tracks voting units, which are a measure of voting power that can be\n * transferred, and provides a system of vote delegation, where an account can delegate its voting units to a sort of\n * \"representative\" that will pool delegated voting units from different accounts and can then use it to vote in\n * decisions. In fact, voting units _must_ be delegated in order to count as actual votes, and an account has to\n * delegate those votes to itself if it wishes to participate in decisions and does not have a trusted representative.\n *\n * This contract is often combined with a token contract such that voting units correspond to token units. For an\n * example, see {ERC721Votes}.\n *\n * The full history of delegate votes is tracked on-chain so that governance protocols can consider votes as distributed\n * at a particular block number to protect against flash loans and double voting. The opt-in delegate system makes the\n * cost of this history tracking optional.\n *\n * When using this module the derived contract must implement {_getVotingUnits} (for example, make it return\n * {ERC721-balanceOf}), and can use {_transferVotingUnits} to track a change in the distribution of those units (in the\n * previous example, it would be included in {ERC721-_update}).\n */\nabstract contract Votes is Context, EIP712, Nonces, IERC5805 {\n    using Checkpoints for Checkpoints.Trace208;\n\n    bytes32 private constant DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address account => address) private _delegatee;\n\n    mapping(address delegatee => Checkpoints.Trace208) private _delegateCheckpoints;\n\n    Checkpoints.Trace208 private _totalCheckpoints;\n\n    /**\n     * @dev The clock was incorrectly modified.\n     */\n    error ERC6372InconsistentClock();\n\n    /**\n     * @dev Lookup to future votes is not available.\n     */\n    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based\n     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.\n     */\n    function clock() public view virtual returns (uint48) {\n        return Time.blockNumber();\n    }\n\n    /**\n     * @dev Machine-readable description of the clock as specified in EIP-6372.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public view virtual returns (string memory) {\n        // Check that the clock was not modified\n        if (clock() != Time.blockNumber()) {\n            revert ERC6372InconsistentClock();\n        }\n        return \"mode=blocknumber&from=default\";\n    }\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) public view virtual returns (uint256) {\n        return _delegateCheckpoints[account].latest();\n    }\n\n    /**\n     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastVotes(address account, uint256 timepoint) public view virtual returns (uint256) {\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return _delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is\n     * configured to use block numbers, this will return the value at the end of the corresponding block.\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     *\n     * Requirements:\n     *\n     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.\n     */\n    function getPastTotalSupply(uint256 timepoint) public view virtual returns (uint256) {\n        uint48 currentTimepoint = clock();\n        if (timepoint >= currentTimepoint) {\n            revert ERC5805FutureLookup(timepoint, currentTimepoint);\n        }\n        return _totalCheckpoints.upperLookupRecent(SafeCast.toUint48(timepoint));\n    }\n\n    /**\n     * @dev Returns the current total supply of votes.\n     */\n    function _getTotalSupply() internal view virtual returns (uint256) {\n        return _totalCheckpoints.latest();\n    }\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) public view virtual returns (address) {\n        return _delegatee[account];\n    }\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual {\n        address account = _msgSender();\n        _delegate(account, delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > expiry) {\n            revert VotesExpiredSignature(expiry);\n        }\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        _useCheckedNonce(signer, nonce);\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Delegate all of `account`'s voting units to `delegatee`.\n     *\n     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.\n     */\n    function _delegate(address account, address delegatee) internal virtual {\n        address oldDelegate = delegates(account);\n        _delegatee[account] = delegatee;\n\n        emit DelegateChanged(account, oldDelegate, delegatee);\n        _moveDelegateVotes(oldDelegate, delegatee, _getVotingUnits(account));\n    }\n\n    /**\n     * @dev Transfers, mints, or burns voting units. To register a mint, `from` should be zero. To register a burn, `to`\n     * should be zero. Total supply of voting units will be adjusted with mints and burns.\n     */\n    function _transferVotingUnits(address from, address to, uint256 amount) internal virtual {\n        if (from == address(0)) {\n            _push(_totalCheckpoints, _add, SafeCast.toUint208(amount));\n        }\n        if (to == address(0)) {\n            _push(_totalCheckpoints, _subtract, SafeCast.toUint208(amount));\n        }\n        _moveDelegateVotes(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Moves delegated votes from one delegate to another.\n     */\n    function _moveDelegateVotes(address from, address to, uint256 amount) private {\n        if (from != to && amount > 0) {\n            if (from != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    _delegateCheckpoints[from],\n                    _subtract,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(from, oldValue, newValue);\n            }\n            if (to != address(0)) {\n                (uint256 oldValue, uint256 newValue) = _push(\n                    _delegateCheckpoints[to],\n                    _add,\n                    SafeCast.toUint208(amount)\n                );\n                emit DelegateVotesChanged(to, oldValue, newValue);\n            }\n        }\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function _numCheckpoints(address account) internal view virtual returns (uint32) {\n        return SafeCast.toUint32(_delegateCheckpoints[account].length());\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function _checkpoints(\n        address account,\n        uint32 pos\n    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {\n        return _delegateCheckpoints[account].at(pos);\n    }\n\n    function _push(\n        Checkpoints.Trace208 storage store,\n        function(uint208, uint208) view returns (uint208) op,\n        uint208 delta\n    ) private returns (uint208, uint208) {\n        return store.push(clock(), op(store.latest(), delta));\n    }\n\n    function _add(uint208 a, uint208 b) private pure returns (uint208) {\n        return a + b;\n    }\n\n    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {\n        return a - b;\n    }\n\n    /**\n     * @dev Must return the voting units held by an account.\n     */\n    function _getVotingUnits(address) internal view virtual returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5805.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC5805.sol)\n\npragma solidity ^0.8.20;\n\nimport {IVotes} from \"../governance/utils/IVotes.sol\";\nimport {IERC6372} from \"./IERC6372.sol\";\n\ninterface IERC5805 is IERC6372, IVotes {}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC6372.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC6372.sol)\n\npragma solidity ^0.8.20;\n\ninterface IERC6372 {\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    function clock() external view returns (uint48);\n\n    /**\n     * @dev Description of the clock\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Pausable} from \"../../../utils/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n        super._update(from, to, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20Permit} from \"./IERC20Permit.sol\";\nimport {ERC20} from \"../ERC20.sol\";\nimport {ECDSA} from \"../../../utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"../../../utils/cryptography/EIP712.sol\";\nimport {Nonces} from \"../../../utils/Nonces.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {\n    bytes32 private constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Permit deadline has expired.\n     */\n    error ERC2612ExpiredSignature(uint256 deadline);\n\n    /**\n     * @dev Mismatched signature.\n     */\n    error ERC2612InvalidSigner(address signer, address owner);\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        if (block.timestamp > deadline) {\n            revert ERC2612ExpiredSignature(deadline);\n        }\n\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        if (signer != owner) {\n            revert ERC2612InvalidSigner(signer, owner);\n        }\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {\n        return super.nonces(owner);\n    }\n\n    /**\n     * @inheritdoc IERC20Permit\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view virtual returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Votes} from \"../../../governance/utils/Votes.sol\";\nimport {Checkpoints} from \"../../../utils/structs/Checkpoints.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: This contract does not provide interface compatibility with Compound's COMP token.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n */\nabstract contract ERC20Votes is ERC20, Votes {\n    /**\n     * @dev Total supply cap has been exceeded, introducing a risk of votes overflowing.\n     */\n    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint208).max` (2^208^ - 1).\n     *\n     * This maximum is enforced in {_update}. It limits the total supply of the token, which is otherwise a uint256,\n     * so that checkpoints can be stored in the Trace208 structure used by {{Votes}}. Increasing this value will not\n     * remove the underlying limitation, and will cause {_update} to fail because of a math overflow in\n     * {_transferVotingUnits}. An override could be used to further restrict the total supply (to a lower value) if\n     * additional logic requires it. When resolving override conflicts on this function, the minimum should be\n     * returned.\n     */\n    function _maxSupply() internal view virtual returns (uint256) {\n        return type(uint208).max;\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {IVotes-DelegateVotesChanged} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override {\n        super._update(from, to, value);\n        if (from == address(0)) {\n            uint256 supply = totalSupply();\n            uint256 cap = _maxSupply();\n            if (supply > cap) {\n                revert ERC20ExceededSafeSupply(supply, cap);\n            }\n        }\n        _transferVotingUnits(from, to, value);\n    }\n\n    /**\n     * @dev Returns the voting units of an `account`.\n     *\n     * WARNING: Overriding this function may compromise the internal vote accounting.\n     * `ERC20Votes` assumes tokens map to voting units 1:1 and this is not easy to change.\n     */\n    function _getVotingUnits(address account) internal view virtual override returns (uint256) {\n        return balanceOf(account);\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return _numCheckpoints(account);\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {\n        return _checkpoints(account, pos);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.20;\n\nimport {MessageHashUtils} from \"./MessageHashUtils.sol\";\nimport {ShortStrings, ShortString} from \"../ShortStrings.sol\";\nimport {IERC5267} from \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose\n * encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract\n * does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to\n * produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the {_domainSeparatorV4} function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {IERC-5267}.\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n\n    /**\n     * @dev The name parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _name which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Name() internal view returns (string memory) {\n        return _name.toStringWithFallback(_nameFallback);\n    }\n\n    /**\n     * @dev The version parameter for the EIP712 domain.\n     *\n     * NOTE: By default this function reads _version which is an immutable value.\n     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function _EIP712Version() internal view returns (string memory) {\n        return _version.toStringWithFallback(_versionFallback);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\npragma solidity ^0.8.20;\n\nimport {Strings} from \"../Strings.sol\";\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Nonces.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Nonces.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides tracking nonces for addresses. Nonces will only increment.\n */\nabstract contract Nonces {\n    /**\n     * @dev The nonce used for an `account` is not the expected current nonce.\n     */\n    error InvalidAccountNonce(address account, uint256 currentNonce);\n\n    mapping(address account => uint256) private _nonces;\n\n    /**\n     * @dev Returns the next unused nonce for an address.\n     */\n    function nonces(address owner) public view virtual returns (uint256) {\n        return _nonces[owner];\n    }\n\n    /**\n     * @dev Consumes a nonce.\n     *\n     * Returns the current value and increments nonce.\n     */\n    function _useNonce(address owner) internal virtual returns (uint256) {\n        // For each account, the nonce has an initial value of 0, can only be incremented by one, and cannot be\n        // decremented or reset. This guarantees that the nonce never overflows.\n        unchecked {\n            // It is important to do x++ and not ++x here.\n            return _nonces[owner]++;\n        }\n    }\n\n    /**\n     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.\n     */\n    function _useCheckedNonce(address owner, uint256 nonce) internal virtual {\n        uint256 current = _useNonce(owner);\n        if (nonce != current) {\n            revert InvalidAccountNonce(owner, current);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using\n     * {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/Checkpoints.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/Checkpoints.sol)\n// This file was procedurally generated from scripts/generate/templates/Checkpoints.js.\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\n\n/**\n * @dev This library defines the `Trace*` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.Trace*` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n */\nlibrary Checkpoints {\n    /**\n     * @dev A value was attempted to be inserted on a past checkpoint.\n     */\n    error CheckpointUnorderedInsertion();\n\n    struct Trace224 {\n        Checkpoint224[] _checkpoints;\n    }\n\n    struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint32).max` key set will disable the\n     * library.\n     */\n    function push(Trace224 storage self, uint32 key, uint224 value) internal returns (uint224, uint224) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace224 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace224 storage self, uint32 pos) internal view returns (Checkpoint224 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private returns (uint224, uint224) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace208 {\n        Checkpoint208[] _checkpoints;\n    }\n\n    struct Checkpoint208 {\n        uint48 _key;\n        uint208 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace208 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint48).max` key set will disable the\n     * library.\n     */\n    function push(Trace208 storage self, uint48 key, uint208 value) internal returns (uint208, uint208) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace208 storage self) internal view returns (uint208) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint208 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace208 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace208 storage self, uint32 pos) internal view returns (Checkpoint208 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint208[] storage self, uint48 key, uint208 value) private returns (uint208, uint208) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint208 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint208({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint208({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint208[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint208 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }\n\n    struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.\n     *\n     * Returns previous value and new value.\n     *\n     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint96).max` key set will disable the\n     * library.\n     */\n    function push(Trace160 storage self, uint96 key, uint160 value) internal returns (uint160, uint160) {\n        return _insert(self._checkpoints, key, value);\n    }\n\n    /**\n     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if\n     * there is none.\n     */\n    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     */\n    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero\n     * if there is none.\n     *\n     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high\n     * keys).\n     */\n    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }\n\n    /**\n     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value\n     * in the most recent checkpoint.\n     */\n    function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }\n\n    /**\n     * @dev Returns the number of checkpoint.\n     */\n    function length(Trace160 storage self) internal view returns (uint256) {\n        return self._checkpoints.length;\n    }\n\n    /**\n     * @dev Returns checkpoint at given position.\n     */\n    function at(Trace160 storage self, uint32 pos) internal view returns (Checkpoint160 memory) {\n        return self._checkpoints[pos];\n    }\n\n    /**\n     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,\n     * or by updating the last one.\n     */\n    function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private returns (uint160, uint160) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            // Copying to memory is important here.\n            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);\n\n            // Checkpoint keys must be non-decreasing.\n            if (last._key > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (last._key == key) {\n                _unsafeAccess(self, pos - 1)._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (last._value, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }\n\n    /**\n     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high`\n     * if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and exclusive\n     * `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or\n     * `high` if there is none. `low` and `high` define a section where to do the search, with inclusive `low` and\n     * exclusive `high`.\n     *\n     * WARNING: `high` should not be greater than the array's length.\n     */\n    function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/types/Time.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/types/Time.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"../math/Math.sol\";\nimport {SafeCast} from \"../math/SafeCast.sol\";\n\n/**\n * @dev This library provides helpers for manipulating time-related objects.\n *\n * It uses the following types:\n * - `uint48` for timepoints\n * - `uint32` for durations\n *\n * While the library doesn't provide specific types for timepoints and duration, it does provide:\n * - a `Delay` type to represent duration that can be programmed to change value automatically at a given point\n * - additional helper functions\n */\nlibrary Time {\n    using Time for *;\n\n    /**\n     * @dev Get the block timestamp as a Timepoint.\n     */\n    function timestamp() internal view returns (uint48) {\n        return SafeCast.toUint48(block.timestamp);\n    }\n\n    /**\n     * @dev Get the block number as a Timepoint.\n     */\n    function blockNumber() internal view returns (uint48) {\n        return SafeCast.toUint48(block.number);\n    }\n\n    // ==================================================== Delay =====================================================\n    /**\n     * @dev A `Delay` is a uint32 duration that can be programmed to change value automatically at a given point in the\n     * future. The \"effect\" timepoint describes when the transitions happens from the \"old\" value to the \"new\" value.\n     * This allows updating the delay applied to some operation while keeping some guarantees.\n     *\n     * In particular, the {update} function guarantees that if the delay is reduced, the old delay still applies for\n     * some time. For example if the delay is currently 7 days to do an upgrade, the admin should not be able to set\n     * the delay to 0 and upgrade immediately. If the admin wants to reduce the delay, the old delay (7 days) should\n     * still apply for some time.\n     *\n     *\n     * The `Delay` type is 112 bits long, and packs the following:\n     *\n     * ```\n     *   | [uint48]: effect date (timepoint)\n     *   |           | [uint32]: value before (duration)\n     *   ↓           ↓       ↓ [uint32]: value after (duration)\n     * 0xAAAAAAAAAAAABBBBBBBBCCCCCCCC\n     * ```\n     *\n     * NOTE: The {get} and {withUpdate} functions operate using timestamps. Block number based delays are not currently\n     * supported.\n     */\n    type Delay is uint112;\n\n    /**\n     * @dev Wrap a duration into a Delay to add the one-step \"update in the future\" feature\n     */\n    function toDelay(uint32 duration) internal pure returns (Delay) {\n        return Delay.wrap(duration);\n    }\n\n    /**\n     * @dev Get the value at a given timepoint plus the pending value and effect timepoint if there is a scheduled\n     * change after this timepoint. If the effect timepoint is 0, then the pending value should not be considered.\n     */\n    function _getFullAt(Delay self, uint48 timepoint) private pure returns (uint32, uint32, uint48) {\n        (uint32 valueBefore, uint32 valueAfter, uint48 effect) = self.unpack();\n        return effect <= timepoint ? (valueAfter, 0, 0) : (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev Get the current value plus the pending value and effect timepoint if there is a scheduled change. If the\n     * effect timepoint is 0, then the pending value should not be considered.\n     */\n    function getFull(Delay self) internal view returns (uint32, uint32, uint48) {\n        return _getFullAt(self, timestamp());\n    }\n\n    /**\n     * @dev Get the current value.\n     */\n    function get(Delay self) internal view returns (uint32) {\n        (uint32 delay, , ) = self.getFull();\n        return delay;\n    }\n\n    /**\n     * @dev Update a Delay object so that it takes a new duration after a timepoint that is automatically computed to\n     * enforce the old delay at the moment of the update. Returns the updated Delay object and the timestamp when the\n     * new delay becomes effective.\n     */\n    function withUpdate(\n        Delay self,\n        uint32 newValue,\n        uint32 minSetback\n    ) internal view returns (Delay updatedDelay, uint48 effect) {\n        uint32 value = self.get();\n        uint32 setback = uint32(Math.max(minSetback, value > newValue ? value - newValue : 0));\n        effect = timestamp() + setback;\n        return (pack(value, newValue, effect), effect);\n    }\n\n    /**\n     * @dev Split a delay into its components: valueBefore, valueAfter and effect (transition timepoint).\n     */\n    function unpack(Delay self) internal pure returns (uint32 valueBefore, uint32 valueAfter, uint48 effect) {\n        uint112 raw = Delay.unwrap(self);\n\n        valueAfter = uint32(raw);\n        valueBefore = uint32(raw >> 32);\n        effect = uint48(raw >> 64);\n\n        return (valueBefore, valueAfter, effect);\n    }\n\n    /**\n     * @dev pack the components into a Delay object.\n     */\n    function pack(uint32 valueBefore, uint32 valueAfter, uint48 effect) internal pure returns (Delay) {\n        return Delay.wrap((uint112(effect) << 64) | (uint112(valueBefore) << 32) | uint112(valueAfter));\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2ERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2ERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n"
    },
    "contracts/Channel_iN/ChanneliN.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../shared/libraries/LibDiamond.sol\";\nimport {IDiamondCut} from \"../shared/interfaces/IDiamondCut.sol\";\n\ncontract CHANNELIN {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = address(bytes20(ds.facets[msg.sig]));\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/Channel_iN/facets/AdminFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IP2} from \"../interfaces/IP2.sol\";\nimport {IP2_Admin} from \"../interfaces/IP2_Admin.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport {LibDistribute} from \"../../shared/libraries/LibDistribute.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\n\nimport {LibP2} from \"../libraries/LibP2.sol\";\n\ncontract AdminFacet is Modifiers {\n    /**@dev P0 Admin functions\n     */\n    function admin_p0_setStates(\n        uint24 _maxProb,\n        uint _addProbFee,\n        uint16 _addProbExp,\n        bool _isVRF\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_states.maxProb = _maxProb;\n        s.p0_states.addProbFee = _addProbFee;\n        s.p0_states.addProbExp = _addProbExp;\n        s.p0_states.isVRF = _isVRF;\n    }\n\n    function admin_p0_setGradeInfos(\n        uint8 _gradeIndex,\n        bool _isOpen,\n        uint _mixFee,\n        uint24 _initBaseProb,\n        uint16 _mixExp,\n        uint24 _failedAddProbMin,\n        uint24 _failedAddProbMax\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_gradeInfos[_gradeIndex].isOpen = _isOpen;\n        s.p0_gradeInfos[_gradeIndex].mixFee = _mixFee;\n        s.p0_gradeInfos[_gradeIndex].initBaseProb = _initBaseProb;\n        s.p0_gradeInfos[_gradeIndex].mixExp = _mixExp;\n        s.p0_gradeInfos[_gradeIndex].failedAddProbMin = _failedAddProbMin;\n        s.p0_gradeInfos[_gradeIndex].failedAddProbMax = _failedAddProbMax;\n    }\n\n    function admin_p0_setPerFriendsProb(\n        uint _grade,\n        string memory _pfGrade,\n        uint24 _gradeProb\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_perFriendsProbs[_grade].pfGrade = _pfGrade;\n        s.p0_perFriendsProbs[_grade].gradeProb = uint24(_gradeProb);\n    }\n\n    function admin_p0_getStates()\n        external\n        view\n        returns (uint24, uint, uint16, bool)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_states.maxProb,\n            s.p0_states.addProbFee,\n            s.p0_states.addProbExp,\n            s.p0_states.isVRF\n        );\n    }\n\n    function admin_p0_getGradeInfos(\n        uint8 _gradeIndex\n    ) external view returns (bool, uint, uint24, uint16, uint24, uint24) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_gradeInfos[_gradeIndex].isOpen,\n            s.p0_gradeInfos[_gradeIndex].mixFee,\n            s.p0_gradeInfos[_gradeIndex].initBaseProb,\n            s.p0_gradeInfos[_gradeIndex].mixExp,\n            s.p0_gradeInfos[_gradeIndex].failedAddProbMin,\n            s.p0_gradeInfos[_gradeIndex].failedAddProbMax\n        );\n    }\n\n    function admin_p0_getPerFriendsProb(\n        uint _grade\n    ) external view returns (string memory, uint24) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_perFriendsProbs[_grade].pfGrade,\n            s.p0_perFriendsProbs[_grade].gradeProb\n        );\n    }\n\n    function admin_p0_setMetaData(\n        uint _pfId,\n        uint8 _grade,\n        string memory _seedHash\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.pfMetaURI[_pfId] = _seedHash;\n        s.p0_mergePfGrades[_grade].setMatadataId = _pfId;\n\n        IDB(s.contracts[\"db\"]).adminSetMetaData(_pfId, _grade, _seedHash);\n    }\n\n    function admin_p0_setMergeGradesInfo(\n        uint8 _grade,\n        string memory _gradeName,\n        uint _mergeFee,\n        uint _mergeUseItemAmount,\n        uint _latestId,\n        bool _isOpen\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_mergePfGrades[_grade].grade = _grade;\n        s.p0_mergePfGrades[_grade].gradeName = _gradeName;\n        s.p0_mergePfGrades[_grade].mergeFee = _mergeFee;\n        s.p0_mergePfGrades[_grade].mergeUseItemAmount = _mergeUseItemAmount;\n        s.p0_mergePfGrades[_grade].latestId = _latestId;\n        s.p0_mergePfGrades[_grade].isOpen = _isOpen;\n    }\n\n    function admin_p0_getMetadataMargin(\n        uint8 _grade\n    ) external view returns (uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_mergePfGrades[_grade].latestId,\n            s.p0_mergePfGrades[_grade].setMatadataId,\n            s.p0_mergePfGrades[_grade].setMatadataId -\n                s.p0_mergePfGrades[_grade].latestId\n        );\n    }\n\n    /**@dev P2 Admin functions\n     */\n    function admin_P2_start(uint _baseBalance, uint _plusBalance, uint _dailyRewardPercent,uint _maxStakingLimit, uint _dayToSec) external onlyDev returns(bool){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.isP2Stop = true;\n        s.REWARD_PERCENT_DECIMAL = 1e5;\n        s.PRECISION_FACTOR = 1e12;\n        s.DAY_TO_SEC = _dayToSec;\n        s.P2_baseBalance = _baseBalance;\n        s.P2_plusBalance = _plusBalance;\n        s.P2_dailyRewardPercent = _dailyRewardPercent;\n        s.P2_dailyRewardUpdateBlock = block.number - _dayToSec;\n        s.P2_MAX_STAKING_LIMIT = _maxStakingLimit;\n\n        return true;\n    } \n\n\n    function admin_P2_layer_setting(\n        uint _layerNumber,\n\t\tuint _fromP2BasePercent,\n\t\tuint _fromP2PlusPercent,\n\t\tuint _add_dailyReward_Percent,\n\t\tbool _isOpen) external onlyDev {\n        // 1Layer :  81144000   / 0             || -                        || 7000     ||   -      || 100000 ||\n        // 2Layer :  104328000  / 0             || -                        || 9000     ||   -      || 100000 || add_dailyReward_Percent\n        // 3Layer :  128491285  / 96949286      || -                        || 11000    ||   -      || 100000 || 1000\n        // 4Layer :  157051365  / 629181181     || -                        || 13000    ||   -      || 100000 || 1000\n        // 5Layer :  11592000   / 1528310000    || -                        || 1000     ||   -      || 100000 || 1000\n        // 6Layer :  11592000   / 1528310000    || 73966502951109738390000  || 1000     || 10000    || 100000 ||\n        // 7Layer :  11592000   / 1528310000    || 73966502951109738390000  || 1000     || 10000    || 100000 ||\n        // 8Layer :  11592000   / 1528310000    || 73966502951109738390000  || 1000     || 10000    || 100000 ||\n        // 9Layer :  11592000   / 1528310000    || 73966502951109738390000  || 1000     || 10000    || 100000 ||\n        // 10Layer :  11592000  / 1528310000    || 73966502951109738390000  || 1000     || 10000    || 100000 ||\n\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p2_layers[_layerNumber].rewardBasePercent = _fromP2BasePercent;\n        s.p2_layers[_layerNumber].rewardPlusPercent = _fromP2PlusPercent;\n        s.p2_layers[_layerNumber].dailyReward_Percent = 100000;\n        // 1-5 layer는 0, 6-10 layer는 10000\n        s.p2_layers[_layerNumber].add_dailyReward_Percent = _add_dailyReward_Percent;\n        s.p2_layers[_layerNumber].isOpen = _isOpen;\n    }\n\n    function admin_P2_layer_setRewardPercent(\n        uint _layerNumber,\n        uint _rewardBasePercent,\n        uint _rewardPlusPercent\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p2_layers[_layerNumber].dailyReward_Percent = _rewardBasePercent;\n        s.p2_layers[_layerNumber].add_dailyReward_Percent = _rewardPlusPercent;\n    }\n\n    function admin_P2_setDailyRewardPercent(uint _dailyRewardPercent) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.P2_dailyRewardPercent = _dailyRewardPercent;\n    }\n    function admin_P2_blockUser(\n        address _user,\n        bool _isBlock\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p2_users[_user].isBlockUser = _isBlock;\n    }\n\n    function admin_P2_setMaxLimit(uint _maxLimit) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.P2_MAX_STAKING_LIMIT = _maxLimit;\n    }    \n    \n    function admin_P2_layer_balances_setting(uint _layerNumber, uint _baseBalance,uint _plusBalance, uint _savedBaseBalance,uint _savedPlusBalance) external onlyDev returns(bool){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p2_layers[_layerNumber].balances.baseBalance = _baseBalance;\n        s.p2_layers[_layerNumber].balances.plusBalance = _plusBalance;\n        s.p2_layers[_layerNumber].balances.savedBaseBalance = _savedBaseBalance;\n        s.p2_layers[_layerNumber].balances.savedPlusBalance = _savedPlusBalance;\n\n        return true;\n    }\n\n    \n    function admin_P2_Stop(bool _isStop) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.isP2Stop = _isStop;\n    }\n\n    function admin_P2_setBalance(uint _baseBalance, uint _plusBalance) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.P2_baseBalance = _baseBalance;\n        s.P2_plusBalance = _plusBalance;\n    }\n\n\n\n    /**@dev DistriBute Admin functions\n     */\n    function admin_distribute_setStates(\n        uint24 _p1Ratio,\n        uint24 _p2BaseRatio,\n        uint24 _p2PlusRatio,\n        uint24 _burnRatio,\n        uint24 _teamFeeRatio\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.distribute_states.p1Ratio = _p1Ratio;\n        s.distribute_states.p2BaseRatio = _p2BaseRatio;\n        s.distribute_states.p2PlusRatio = _p2PlusRatio;\n        s.distribute_states.burnRatio = _burnRatio;\n        s.distribute_states.teamFeeRatio = _teamFeeRatio;\n    }\n\n    function admin_distribute_userStates(\n        uint _agencyIncomePercent,\n        uint _influencerIncomePercent\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_mergeState.agencyIncomePercent = _agencyIncomePercent;\n        s.p0_mergeState.influencerIncomePercent = _influencerIncomePercent;\n    }\n\n    function admin_distribute_getStates()\n        external\n        view\n        returns (uint24, uint24, uint24, uint24, uint24, uint, uint)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.distribute_states.p1Ratio,\n            s.distribute_states.p2BaseRatio,\n            s.distribute_states.p2PlusRatio,\n            s.distribute_states.burnRatio,\n            s.distribute_states.teamFeeRatio,\n            s.p0_mergeState.agencyIncomePercent,\n            s.p0_mergeState.influencerIncomePercent\n        );\n    }\n\n    function admin_distribute_setAuto(bool _isAuto) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.isAutoDistribute = _isAuto;\n    }\n\n    function admin_distribute_ksSwapLimit(uint _limit) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.ksSwapLimit = _limit;\n    }\n\n    function admin_distribute_getBeforAmounts()\n        external\n        view\n        returns (uint, uint, uint)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.distribute_states.beforeP2Usdt,\n            s.distribute_states.beforeTeamUsdt,\n            s.distribute_states.beforeP2Per\n        );\n    }\n\n    function admin_distribute_estimate()\n        external\n        view\n        returns (bool, uint, uint)\n    {\n        return LibDistribute.isSwap();\n    }\n\n    // function admin_distribute_swap() external onlyDev {\n    //     LibDistribute.swapToDistribute();\n    // }\n\n    /**@dev aien mint variables\n     */\n\n    function admin_setAienMintFee(uint _mintFee) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.aienMintFee = _mintFee;\n    }\n}\n"
    },
    "contracts/Channel_iN/facets/AienMintFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {LibAienMint} from \"../libraries/LibAienMint.sol\";\n\n/**\n@dev Aien Mint Facet Contract\n */\n\ncontract AienMintFacet {\n    // aien mint functions\n    function aiMint() external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._aiMint(msgsender);\n    }\n\n    function pfMint(uint _pfId) external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._pfMint(msgsender, _pfId);\n    }\n\n    function defaultMint() external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._defaultMint(msgsender);\n    }\n\n    // image chage functions\n    function defaultSetImage(uint _aienId) external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._defaultSetImage(msgsender, _aienId);\n    }\n\n    function aiSetImage(uint _aienId) external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._aiSetImage(msgsender, _aienId);\n    }\n\n    function pfSetImage(uint _aienId, uint _pfId) external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._pfSetImage(msgsender, _aienId, _pfId);\n    }\n}\n"
    },
    "contracts/Channel_iN/facets/FrontFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../shared/interfaces/IERC1155.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\n\n/**\n@dev get load BlockChain datas before front component mount\n */\ncontract FrontFacet {\n    function Front_isApprovedAsset(\n        address _user\n    ) external view returns (bool, bool, bool, bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        return (\n            // per\n            IERC20(s.contracts[\"per\"]).allowance(\n                _user,\n                s.contracts[\"diamond\"]\n            ) > 0,\n            // aien\n            IERC721(s.contracts[\"aien\"]).isApprovedForAll(\n                _user,\n                s.contracts[\"diamond\"]\n            ),\n            // 퍼프\n            IERC721(s.contracts[\"perfriends\"]).isApprovedForAll(\n                _user,\n                s.contracts[\"diamond\"]\n            ),\n            // item\n            IERC1155(s.contracts[\"item\"]).isApprovedForAll(\n                _user,\n                s.contracts[\"diamond\"]\n            )\n        );\n    }\n\n    function Front_PfGrades() external view returns (IDB.pfGrade memory) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return IDB(s.contracts[\"db\"]).PfGrades();\n    }\n\n    function Front_getAienGradeInfo() external view returns (uint[] memory) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return IDB(s.contracts[\"db\"]).getAienGradeInfo();\n    }\n\n    \n}\n"
    },
    "contracts/Channel_iN/facets/MarketFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\n\n\ncontract MarketFacet is Modifiers {\n\n}\n"
    },
    "contracts/Channel_iN/facets/P0Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {P0_MergePfGrade, AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {LibP0} from \"../libraries/LibP0.sol\";\n\ninterface IP0 {\n    function mixPFInfos(\n        uint _level\n    ) external view returns (string memory, uint);\n}\n\n/**\n@dev i-TEZ : P0 (Mix) Facet Contract\n */\ncontract P0Facet is Modifiers {\n    function P0_itemMerge(uint _itemId, uint _itemAmount) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        LibP0._itemMerge(msgsender, _itemId, _itemAmount);\n    }\n\n    function P0_itemGradeMerge(\n        uint _itemId,\n        uint _itemAmount,\n        uint8 _grade\n    ) external {\n        address msgsender = LibMeta.msgSender();\n        LibP0._itemGradeMerge(msgsender, _itemId, _itemAmount, _grade);\n    }\n\n    function P0_baseMixCall(uint _id, uint _useItemId) external returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        return LibP0._baseMixCall(msgsender, _id, _useItemId);\n    }\n\n    function P0_premiumMixCall(\n        uint _id,\n        uint _useItemId\n    ) external returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        LibP0._premiumMixCall(msgsender, _id, _useItemId);\n    }\n\n    function P0_addProbCall(\n        uint _aienId,\n        uint[] memory _pf_Ids\n    ) external returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        LibP0._addProbCall(msgsender, _aienId, _pf_Ids);\n    }\n\n    /**\n    P0 _ get functions\n     */\n\n    function P0_getMaxProb() external view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.p0_states.maxProb;\n    }\n\n    // input ItemId별로 병합시 소요되는 Per, item수량\n    function P0_getMergeState(uint _itemId) external view returns (uint, uint) {\n        return LibP0._getMergeState(_itemId);\n    }\n\n    // PF POWER ZONE 사용되는 Per 수량\n    function P0_getAddProbFee() external view returns (uint) {\n        return LibP0._getAddProbFee();\n    }\n\n    // 인플루언서 루비온 병합시 amount\n    function P0_influencerMergeAmount() external view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return IDB(s.contracts[\"db\"]).influencerMergeAmount();\n    }\n\n    // 재단 루비온 병합시 amount\n    function P0_basicMergeAmount() external view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return IDB(s.contracts[\"db\"]).basicMergeAmount();\n    }\n\n    // MixPFInfos\n    function P0_mixPFInfos(\n        uint _level\n    ) external view returns (string memory, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return IP0(s.contracts[\"p0\"]).mixPFInfos(_level);\n    }\n\n    // Aien Metadata set Margin value\n    function P0_getMetadataMargin() external view returns (uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return IDB(s.contracts[\"db\"])._getMedataMargin();\n    }\n\n    function P0_getMergeStates(\n        uint8 _grade\n    ) external view returns (P0_MergePfGrade memory) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.p0_mergePfGrades[_grade];\n    }\n\n    function P0_getCurrentMergeStates()\n        external\n        view\n        returns (P0_MergePfGrade[] memory)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint8 endOpenGrade;\n        for (uint8 i = 1; i < 11; i++) {\n            s.p0_mergePfGrades[i].isOpen ? endOpenGrade = i : endOpenGrade;\n        }\n\n        P0_MergePfGrade[] memory _mergePfGrades = new P0_MergePfGrade[](\n            endOpenGrade\n        );\n        for (uint8 i = 1; i <= endOpenGrade; i++) {\n            _mergePfGrades[i - 1] = s.p0_mergePfGrades[i];\n        }\n\n        return _mergePfGrades;\n    }\n}\n"
    },
    "contracts/Channel_iN/facets/P1Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {IP1} from \"../interfaces/IP1.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IP2} from \"../interfaces/IP2.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\n\ncontract P1Facet {\n    event P1_Staking_Event(address indexed to, uint indexed stakeAmount);\n    event P1_RewardStaking_Event(address indexed to, uint indexed stakeAmount);\n\n    event P1_Harvest_Event(address indexed to, uint indexed rewardAmount);\n\n    event P1_AddPower_Event(address indexed to, uint indexed usePower);\n\n    event P1_UnStaking_Event(\n        address indexed to,\n        uint indexed unStakeAmount,\n        uint indexed pendingId,\n        uint burnPower\n    );\n    event P1_UnstakingConfirm_Event(\n        address indexed to,\n        uint indexed unStakeAmount,\n        uint indexed pendingId\n    );\n    event P1_UnstakingCancel_Event(\n        address indexed to,\n        uint indexed unStakeAmount,\n        uint indexed pendingId\n    );\n    event P1_UnstakingCancelConfirm_Event(\n        address indexed to,\n        uint indexed unStakeAmount,\n        uint indexed pendingId\n    );\n\n    function P1_staking(uint _amount) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        IP1(s.contracts[\"p1\"]).diamond_P1_deposit(msgsender, _amount);\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            msgsender,\n            s.contracts[\"p1\"],\n            _amount\n        );\n\n        emit P1_Staking_Event(msgsender, _amount);\n    }\n\n    function P1_rewardStaking() external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n\n        IP1(s.contracts[\"p1\"]).diamond_P1_reDposit(msgsender);\n        uint reward = IP1(s.contracts[\"p1\"]).diamond_P1_pendingReward(\n            msgsender,\n            0\n        );\n\n        emit P1_RewardStaking_Event(msgsender, reward);\n    }\n\n    function P1_harvest() external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n\n        IP1(s.contracts[\"p1\"]).diamond_P1_harvest(msgsender);\n        uint reward = IP1(s.contracts[\"p1\"]).diamond_P1_pendingReward(\n            msgsender,\n            0\n        );\n\n        emit P1_Harvest_Event(msgsender, reward);\n    }\n\n    function P1_pendingReward(\n        address _user,\n        uint _withdrawBlock\n    ) external view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return\n            IP1(s.contracts[\"p1\"]).diamond_P1_pendingReward(\n                _user,\n                _withdrawBlock\n            );\n    }\n\n    function P1_addPower(uint _aienId, uint _usePower) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n\n        IP1(s.contracts[\"p1\"]).diamond_P1_addPower(\n            msgsender,\n            _aienId,\n            _usePower\n        );\n\n        emit P1_AddPower_Event(msgsender, _usePower);\n    }\n\n    function P1_unstaking(uint _amount) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n\n        (uint burnPower, uint pendingId) = IP1(s.contracts[\"p1\"])\n            .diamond_P1_widthdraw(msgsender, _amount);\n\n        emit P1_UnStaking_Event(msgsender, _amount, pendingId, burnPower);\n    }\n\n    function P1_unstakingConfirm(uint _pendingId) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n\n        (uint reward, uint pendingId) = IP1(s.contracts[\"p1\"])\n            .diamond_P1_widthdrawConfirm(msgsender, _pendingId);\n\n        emit P1_UnstakingConfirm_Event(msgsender, reward, pendingId);\n    }\n\n    function P1_unstakingCancel(uint _pendingId) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n\n        (uint256 reward, uint pendingId) = IP1(s.contracts[\"p1\"])\n            .diamond_P1_widthdrawCancel(msgsender, _pendingId);\n\n        emit P1_UnstakingCancel_Event(msgsender, reward, pendingId);\n    }\n\n    function P1_unstakingCancelConfirm(uint _pendingId) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n\n        (uint256 reward, uint pendingId) = IP1(s.contracts[\"p1\"])\n            .diamond_P1_widthdrawCancelConfirm(msgsender, _pendingId);\n\n        emit P1_UnstakingCancelConfirm_Event(msgsender, reward, pendingId);\n    }\n\n    /**\n    P1 _ get functions\n     */\n    function P1_getPoolData() external view returns (uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return IP1(s.contracts[\"p1\"]).diamond_P1_getPoolData();\n    }\n\n    function P1_getUserData()\n        external\n        view\n        returns (uint, uint, uint, uint, uint)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        return IP1(s.contracts[\"p1\"]).diamond_P1_getUserData(msgsender);\n    }\n\n    function P1_getUnstakeData()\n        external\n        view\n        returns (IP1.PendingInfo[] memory)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        return IP1(s.contracts[\"p1\"]).diamond_P1_getUnstakeData(msgsender);\n    }\n\n    function P1_getTimeLockInfo() external view returns (uint16, uint16) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            IP1(s.contracts[\"p1\"]).unStakeTimeLock(),\n            IP1(s.contracts[\"p1\"]).unStakeCancelTimeLock()\n        );\n    }\n}\n"
    },
    "contracts/Channel_iN/facets/P2Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage, P2_Layer} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {LibP2} from \"../libraries/LibP2.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport \"../../shared/libraries/LibEnumerableSet.sol\";\n\ncontract P2Facet {\n    event P2_Staking_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed layer\n    );\n    event P2_UnStaking_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed layer\n    );\n    event P2_Harvest_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed layer,\n        uint baseReward,\n        uint plusReward\n    );\n\n    function P2_staking(uint _aienId) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // address msgsender = LibMeta.msgSender();\n        uint _aienLevel = P2_getAienLevel(_aienId);\n        LibP2.diamond_P2_deposit(msg.sender, _aienId);\n        IERC721(s.contracts[\"aien\"]).safeTransferFrom(\n            msg.sender,\n            s.contracts[\"p2balance\"],\n            _aienId\n        );\n\n        emit P2_Staking_Event(msg.sender, _aienId, _aienLevel);\n    }\n\n    function P2_unStaking(uint _aienId) external {\n        // address msgsender = LibMeta.msgSender();\n\n        uint _aienLevel = P2_getAienLevel(_aienId);\n        (uint base, uint plus) = LibP2.__P2_Pending_Reward(\n            _aienId,\n            _aienLevel\n        );\n\n        emit P2_UnStaking_Event(msg.sender, _aienId, _aienLevel);\n        emit P2_Harvest_Event(msg.sender, _aienId, _aienLevel, base, plus);\n\n        LibP2.diamond_P2_withdraw(msg.sender, _aienId);\n    }\n\n    function P2_harvest(uint _aienId) external {\n        // address msgsender = LibMeta.msgSender();\n        uint _aienLevel = P2_getAienLevel(_aienId);\n        (uint base, uint plus) = LibP2.__P2_Pending_Reward(\n            _aienId,\n            _aienLevel\n        );\n        emit P2_Harvest_Event(msg.sender, _aienId, _aienLevel, base, plus);\n        LibP2.diamond_P2_harvest(msg.sender, _aienId);\n    }\n\n    function P2_getUserInfo()\n        external\n        view\n        returns (\n            LibP2.UserLoadData memory,\n            LibP2.AienLoadData[] memory,\n            LibP2.LayerLoadData[] memory\n        )\n    {\n        // address msgsender = LibMeta.msgSender();\n\n        (\n            LibP2.UserLoadData memory userData,\n            LibP2.AienLoadData[] memory aienData,\n            LibP2.LayerLoadData[] memory layerData\n        ) = LibP2.diamond_P2_getUserInfo(msg.sender);\n        return (userData, aienData, layerData);\n    }\n\n    function P2_getLayerData(\n        uint _number\n    ) public view returns (uint, uint, uint) {\n        \n        return LibP2.diamond_p2_getLayerData(_number);\n    }\n\n    function P2_getAienLevel(uint _aienId) public view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return IDB(s.contracts[\"db\"]).getAienLevel(_aienId);\n    }\n\n    function P2_baseBalance() public view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.P2_baseBalance;\n    }\n\n    function P2_plusBalance() public view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.P2_plusBalance;\n    }\n\n    function P2_maxStakingLimit() public view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.P2_MAX_STAKING_LIMIT;\n    }\n\n    function P2_layers(uint _number) public view returns (P2_Layer memory) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.p2_layers[_number];\n    //     return IP2(s.contracts[\"p2\"]).layers(_number);\n    }\n\n    function P2_pendingReward(uint _aienId) public view returns(uint, uint){\n        uint _aienLevel = P2_getAienLevel(_aienId);\n        return LibP2.__P2_Pending_Reward(_aienId, _aienLevel);\n    }\n\n    function P2_blockPerLayers(uint _number) public view returns (uint,uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        \n        uint basePer =\n                ((s.p2_layers[_number].balances.baseBalance *\n\t\t\t\t\ts.p2_layers[_number].dailyReward_Percent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL /\n\t\t\t\t\ts.p2_layers[_number].totalStakedAien) /\n\t\t\t\ts.DAY_TO_SEC;\n                \n        uint plusPer = ((s.p2_layers[_number].balances.plusBalance *\n\t\t\t\t\ts.p2_layers[_number].dailyReward_Percent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL /\n\t\t\t\t\ts.p2_layers[_number].totalStakedAien) /\n\t\t\t\ts.DAY_TO_SEC;\n        \n\n    return( basePer, plusPer);\n    }\n\n\n    // 0,0,0,2510772063979743000000,\n    // 0,0,0,0,0,0,1000,0,100000,0,0,0,0,0,0,false\n\n\n    function P2_beforeOpenLayer(uint _layer) public view returns (uint) {\n        // AppStorage storage s = LibAppStorage.diamondStorage();\n        // LibP2.diamond_p2_beforeLayer(_layer);\n\n        return LibP2.diamond_p2_beforeLayer(_layer);\n\n    }\n\n    function P2_layer_update(uint _layNumber) public {\n        LibP2.__P2_Layer_Update(_layNumber);\n    }\n    function P2_layer_updateAll(uint _layerNumber) public {\n        for (uint i = 1; i < _layerNumber; i++) {\n            LibP2.__P2_Layer_Update(i);\n        }\n    }\n    function P2_update() public {\n        LibP2.__P2_Update();\n    }\n\n    function P2_updateBlock() public view returns(uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.P2_dailyRewardUpdateBlock;\n    }\n\n    function P2_getDailyRewardPercent() public view returns(uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.P2_dailyRewardPercent;\n    }\n\n    function P2_getDailyRewardUpdateBlock() public view returns(uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.P2_dailyRewardUpdateBlock;\n    }\n}\n"
    },
    "contracts/Channel_iN/interfaces/IDB.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// legacy db contract interface\ninterface IDB {\n    struct pf {\n        uint id;\n        uint class;\n        bool isAien;\n        uint usedAienId;\n    }\n\n    struct pfGrade {\n        uint normal;\n        uint uncommon;\n        uint rare;\n        uint unique;\n        uint legendary;\n        uint myth;\n        uint ancient;\n    }\n\n    struct aien {\n        uint id;\n        // 강화 횟수\n        uint mixCount;\n        //\n        uint p2Level;\n        // 토탈 경험치\n        uint totalExp;\n        // 미션 및, 인플루언서 활동 관련 경험치\n        uint influExp;\n        // 기본 확률\n        uint baseProb;\n        // 토탈 확률\n        uint totalProb;\n        // is PF\n        uint isPFid;\n        // 추가확률\n        uint addProb;\n    }\n\n    struct User {\n        // DB > idx\n        uint userId;\n        // token itme ID\n        uint itemId;\n        address incomeAddr;\n        uint feeBalance;\n        bool isAble;\n        uint mintCount;\n        uint useLevelupCount;\n        uint useMergeCount;\n        // uint ownerIncomePercent;\n        // uint userIncomPercent;\n        //레퍼럴로 얻은 수익\n        uint referralIncome;\n        address agency;\n        uint agencyIncome;\n    }\n\n    function AIENS(uint _key) external view returns (aien memory);\n\n    function PFS(uint _key) external view returns (pf memory);\n\n    function getAien(uint _id) external view;\n\n    function getPF(uint _id) external view;\n\n    function getPfGrade(uint _id) external view returns (uint);\n\n    function setAien(uint _id) external;\n\n    function usePFimg(uint _aienId, uint _pfId) external;\n\n    function setAienAll(\n        uint _id,\n        uint _mixCount,\n        uint _p2Level,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _totalProb,\n        uint _isPFid,\n        uint _addProb\n    ) external;\n\n    function getContractAddr(\n        string memory _name\n    ) external view returns (address);\n\n    function burnValue(uint _burnAmount) external;\n\n    function setAienGradeInfo(uint _toGrade) external;\n\n    function subPfGrades(uint _pfId) external;\n\n    function setLevelUpStatus(uint _toGrade) external;\n\n    function _failedAienSet(\n        uint _id,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _addProb\n    ) external;\n\n    function _successAienSet(\n        uint _id,\n        uint _p2Level,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _addProb\n    ) external;\n\n    function _mergeCalcul(\n        uint _itemId\n    ) external view returns (uint, address, uint, address, uint, uint);\n\n    function _mergeCalcul2(\n        uint _itemId\n    ) external view returns (uint, address, uint, address, uint, uint);\n\n    function _influencerMerge(\n        address _to,\n        uint _itemId,\n        uint _referralIncome\n    ) external returns (uint, string memory);\n\n    function _levelUpCalcul(\n        uint _itemId,\n        uint _fee\n    ) external returns (address, address, uint, uint);\n\n    function _levelUpSucess(uint _id, uint _p2Level) external;\n\n    function _levelUpFailed(uint _id, uint _addProb) external;\n\n    function _mergeCount(\n        address _agency,\n        uint _agencyFee,\n        address _influencer,\n        uint _influencerFee\n    ) external;\n\n    function usePFPower(uint _id, uint _usePower) external;\n\n    function addProbFee() external view returns (uint);\n\n    function PfGrades() external view returns (pfGrade memory);\n\n    function getAienGradeInfo() external view returns (uint[] memory);\n\n    function basicMergeAmount() external view returns (uint);\n\n    function influencerMergeAmount() external view returns (uint);\n\n    function _getMedataMargin() external view returns (uint, uint, uint);\n\n    function getAienLevel(uint _aienId) external view returns (uint);\n\n    function setPerprojectWallet(address _addr) external;\n\n    function setAgencyAddr(address _influencer, address _agency) external;\n\n    function setAgencyIncomePercent(uint _agencyIncomePercent) external;\n\n    function adminSetMergeAmount(\n        uint _influencerMergeAmount,\n        uint _basicMergeAmount,\n        uint _agencyIncomePercent,\n        uint _ownerIncomePercent\n    ) external;\n\n    function getUserFromItem(uint _itemId) external view returns (User memory);\n\n    function adminSetMetaData(\n        uint _pfId,\n        uint8 _grade,\n        string memory _seedHash\n    ) external;\n\n    function _itemMergeFromDiamond(\n        address _to,\n        uint _pfId,\n        string memory _seedHash,\n        uint8 _grade\n    ) external;\n}\n"
    },
    "contracts/Channel_iN/interfaces/IP1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ninterface IP1 {\n    struct PendingInfo {\n        address user;\n        // 1: 출금요청,\n        // 2: 출금취소,\n        // 3: 완료,\n        // 4: 취소완료: 완료시 재예치 버튼 활성화\n        uint8 pendingType;\n        uint startTime;\n        uint endTime;\n        uint amount;\n        // pending Id\n        uint pendingId;\n    }\n\n    function update() external returns (uint);\n\n    function diamond_P1_deposit(\n        address _sender,\n        uint _amount\n    ) external returns (uint);\n\n    function diamond_P1_reDposit(address _sender) external returns (uint);\n\n    function diamond_P1_harvest(address _sender) external returns (uint);\n\n    function diamond_P1_pendingReward(\n        address _sender,\n        uint _withdrawBlock\n    ) external view returns (uint);\n\n    function diamond_P1_addPower(\n        address _sender,\n        uint _aienId,\n        uint _usePower\n    ) external returns (uint);\n\n    function diamond_P1_widthdraw(\n        address _sender,\n        uint _amount\n    ) external returns (uint,uint);\n\n    function diamond_P1_widthdrawConfirm(\n        address _sender,\n        uint _pendingId\n    ) external returns (uint,uint);\n\n    function diamond_P1_widthdrawCancel(\n        address _sender,\n        uint _pendingId\n    ) external returns (uint, uint);\n\n    function diamond_P1_widthdrawCancelConfirm(\n        address _sender,\n        uint _pendingId\n    ) external returns (uint, uint);\n\n    function diamond_P1_getPoolData() external view returns (uint, uint, uint);\n\n    function diamond_P1_getUserData(\n        address _sender\n    ) external view returns (uint, uint, uint, uint, uint);\n\n    function diamond_P1_getUnstakeData(\n        address _sender\n    ) external view returns (PendingInfo[] memory);\n\n    function diamond_P1_addDistributionAmountAll(uint _amount) external;\n\n    function unStakeTimeLock() external view returns (uint16);\n\n    function unStakeCancelTimeLock() external view returns (uint16);\n}\n"
    },
    "contracts/Channel_iN/interfaces/IP2_Admin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ninterface IP2_Admin {\n    // layer Settings\n    function _layer_setting(\n        uint _layerNumber,\n        uint _fromP2PerPercent,\n        uint _fromP2UsdtPercent,\n        uint _dailyReward_percent,\n        uint _add_dailyReward_Percent,\n        bool _isOpen\n    ) external;\n\n    function diamond_P2_BlockUser(\n        address _user,\n        bool _isBlock,\n        string memory _why\n    ) external;\n\n    function diamond_P2_setMaxLimit(uint _maxLimit) external;\n\n    \n\n\n}\n"
    },
    "contracts/Channel_iN/interfaces/IP2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ninterface IP2 {\n    struct User {\n        bool isBlockUser;\n        uint perRewarded;\n        uint usdtRewarded;\n        EnumerableSet.UintSet tokenIds;\n    }\n\n    struct Aien {\n        address staker;\n        uint level;\n        // requires value\n        uint rewardPer;\n        uint rewardUsdt;\n        uint rewardUsdtDebt;\n        uint rewardPerDebt;\n        ////////////////////\n        uint per_received;\n        uint usdt_received;\n    }\n\n    struct Balances {\n        // 로직상 계산에 필요한 밸런스 변수 (실제와 다를 수 있음)\n        uint perBalance;\n        uint usdtBalance;\n        // 레이어가 오픈 되지 않은 상태에서\n        // 레이어가 오픈되면 해당 레이어에 저장된 리워드를 데일리 리워드로 추가 분배하기 위한 변수\n        uint savedPerBalance;\n        uint savedUsdtBalance;\n        // 현재 savedUsdt, savedPer를 통해 나온 데일리 리워드\n        uint add_dailyUSDT;\n        uint add_dailyPER;\n        // 보안상 문제가 생겨\n        // 예상보다 많은 withdraw를 요청하게 되는 경우\n        // 지금까지 쌓인 레이어별 토탈 밸런스와\n        // 지금까지 쌓인 레이어별 출금 밸런스를 비교하여\n        // 출금 가능한지 체크하는 변수\n        uint total_checkWithdrawPER;\n        uint withdrawal_checkWithdrawPER;\n        uint total_checkWithdrawUSDT;\n        uint withdrawal_checkWithdrawUSDT;\n    }\n\n    struct Layer {\n        Balances balances;\n        // P2에서 해당 레이어에 토큰 배정 받을때 리워드 퍼센트\n        uint rewardUsdtPercent;\n        uint rewardPerPercent;\n        // 유저에게 하루에 분배하는 리워드 퍼센트\n        uint dailyReward_Percent;\n        // 계산에 필요\n        uint rewardPer;\n        uint rewardUsdt;\n        // 미오픈시 저장한 리워드를 데일리 리워드로 추가 분배하기 위한 퍼센트변수\n        uint add_dailyReward_Percent;\n        uint lastRewardBlock;\n        uint dailyRewardUpdateBlock;\n        uint totalStakedAien;\n        bool isOpen;\n    }\n\n    struct AienLoadData {\n        //aien정보\n        uint _aienId;\n        uint _aienLevel;\n        // 출금 토탈\n        uint _aien_per_received;\n        uint _aien_usdt_received;\n        //출금 가능\n        uint usdt_withdrawable;\n        uint per_withdrawable;\n        // block당 리워드\n        uint block_reward_per;\n        uint block_reward_usdt;\n    }\n\n    struct LayerLoadData {\n        bool isOpen;\n        uint _layerNumber;\n        uint _24h_reward_per;\n        uint _24h_reward_usdt;\n        uint totalStakedAien;\n    }\n    struct UserLoadData {\n        uint _usdtRewarded;\n        uint _perRewarded;\n        bool _isBlockUser;\n    }\n\n    function aiens(uint _id) external view returns (Aien memory);\n\n    function diamond_P2_deposit(address _sender, uint _aienId) external;\n\n    function diamond_P2_withdraw(address _sender, uint _aienId) external;\n\n    function diamond_P2_harvest(address _sender, uint _aienId) external;\n\n    function diamond_P2_getUserInfo(\n        address _sender\n    )\n        external\n        view\n        returns (\n            UserLoadData memory,\n            AienLoadData[] memory,\n            LayerLoadData[] memory\n        );\n\n    function diamond_P2_getLayerData(\n        uint _number\n    ) external view returns (uint, uint, uint);\n\n    function addPerUsdtDistribution(uint _usdt, uint _per) external;\n\n    function P2_usdtBalance() external view returns (uint);\n\n    function P2_perBalance() external view returns (uint);\n\n    function MAX_STAKING_LIMIT() external view returns (uint);\n\n    function layers(uint _number) external view returns (Layer memory);\n\n    function pendingReward(\n        uint _aienId,\n        uint _layerNumber,\n        uint _withdrawBlock\n    ) external view returns (uint, uint);\n}\n"
    },
    "contracts/Channel_iN/libraries/LibAienMint.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {LibDistribute} from \"../../shared/libraries/LibDistribute.sol\";\n\nlibrary LibAienMint {\n    // mint events\n    event Aien_DefaultMint_Event(address indexed to, uint indexed aienId);\n\n    event Aien_AiMint_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed payment\n    );\n\n    event Aien_PfMint_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed perfId\n    );\n\n    // setImage events\n    event Aien_DefaultSetImage_Event(address indexed to, uint indexed aienId);\n\n    event Aien_AiSetImage_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed payment\n    );\n\n    event Aien_PfSetImage_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed perfId\n    );\n\n    modifier onlyFirstMint() {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(\n            IERC721(s.contracts[\"aien\"]).balanceOf(LibMeta.msgSender()) == 0,\n            \"already minted\"\n        );\n        _;\n    }\n\n    function _aiMint(address _sender) internal onlyFirstMint returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint id = IERC721(s.contracts[\"aien\"]).nextTokenId();\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"team\"],\n            s.aienMintFee\n        );\n        IERC721(s.contracts[\"aien\"]).safeMintByMinter(_sender);\n        IDB(s.contracts[\"db\"]).setAien(id);\n\n        // emit AiMint(_sender, id);\n        emit Aien_AiMint_Event(_sender, id, s.aienMintFee);\n\n        return id;\n    }\n\n    function _defaultMint(\n        address _sender\n    ) internal onlyFirstMint returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint id = IERC721(s.contracts[\"aien\"]).nextTokenId();\n\n        IERC721(s.contracts[\"aien\"]).safeMintByMinter(_sender);\n        IDB(s.contracts[\"db\"]).setAien(id);\n\n        // emit DefaultMint(_sender, id);\n        emit Aien_DefaultMint_Event(_sender, id);\n        return id;\n    }\n\n    function _pfMint(\n        address _sender,\n        uint _pfId\n    ) internal onlyFirstMint returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        require(\n            IERC721(s.contracts[\"perfriends\"]).ownerOf(_pfId) == _sender,\n            \"not owner\"\n        );\n        // PF의 등급이 상위 3등급인지 체크 (unique, legendary, myth)\n        require(\n            IDB(s.contracts[\"db\"]).getPfGrade(_pfId) > 4,\n            \"at least PF grade 5\"\n        );\n\n        uint id = IERC721(s.contracts[\"aien\"]).nextTokenId();\n        IDB(s.contracts[\"db\"]).setAien(id);\n        IDB(s.contracts[\"db\"]).usePFimg(id, _pfId);\n        IERC721(s.contracts[\"aien\"]).safeMintByMinter(_sender);\n\n        // emit PfMint(_sender, id, _pfId);\n        emit Aien_PfMint_Event(_sender, id, _pfId);\n\n        return id;\n    }\n\n    function _defaultSetImage(address _sender, uint _aienId) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_aienId) == _sender,\n            \"not owner\"\n        );\n\n        // emit DefaultSetImage(_sender, _aienId);\n        emit Aien_DefaultSetImage_Event(_sender, _aienId);\n    }\n\n    function _aiSetImage(address _sender, uint _aienId) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_aienId) == _sender,\n            \"not owner\"\n        );\n\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"team\"],\n            s.aienMintFee\n        );\n\n        // emit AiSetImage(_sender, _aienId);\n        emit Aien_AiSetImage_Event(_sender, _aienId, s.aienMintFee);\n    }\n\n    function _pfSetImage(address _sender, uint _aienId, uint _pfId) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_aienId) == _sender,\n            \"not owner\"\n        );\n        require(\n            IERC721(s.contracts[\"perfriends\"]).ownerOf(_pfId) == _sender,\n            \"not owner\"\n        );\n        // PF의 등급이 상위 3등급인지 체크 (unique, legendary, myth)\n        require(\n            IDB(s.contracts[\"db\"]).getPfGrade(_pfId) > 4,\n            \"at least PF grade 5\"\n        );\n\n        IDB(s.contracts[\"db\"]).usePFimg(_aienId, _pfId);\n\n        // emit PfSetImage(_sender, _aienId, _pfId);\n        emit Aien_PfSetImage_Event(_sender, _aienId, _pfId);\n    }\n}\n"
    },
    "contracts/Channel_iN/libraries/LibBurn.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage, Modifiers} from \"../../shared/libraries/LibAppStorage.sol\";\n\nlibrary LibBurnFacet {}\n"
    },
    "contracts/Channel_iN/libraries/LibMarketPlace.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nlibrary LibMarketPlace {\n    // events\n    event CreateCollection(\n        address indexed nftAddress,\n        uint8 indexed nftType,\n        bool indexed isOpen\n    );\n    event CreateOrder(\n        address indexed nftAddress,\n        uint indexed orderId,\n        uint8 indexed orderType\n    );\n    event CancelOrder(\n        address indexed nftAddress,\n        uint indexed orderId,\n        uint8 indexed orderType\n    );\n\n    function setOrder(\n        address _nftAddress,\n        uint8 _orderType,\n        uint _tokenId,\n        uint _price\n    ) internal {}\n\n    function getOrder(address _nftAddress, uint _tokenId) internal {}\n\n    function matchOrder(address _nftAddress, uint _tokenId) internal {}\n\n    function _setFloorPrice(\n        address _nftAddress,\n        uint _tokenId,\n        uint _price\n    ) internal {}\n\n    function _matchOrder(\n        address _nftAddress,\n        uint _tokenId,\n        uint _price\n    ) internal {}\n\n    function _cancelOrder(address _nftAddress, uint _tokenId) internal {}\n}\n"
    },
    "contracts/Channel_iN/libraries/LibP0.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {User, P0_MergeState, P0_MergePfGrade, AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../shared/interfaces/IERC1155.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {LibDistribute} from \"../../shared/libraries/LibDistribute.sol\";\n\nlibrary LibP0 {\n    event P0_BaseMix_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed itemId,\n        uint itemAmount,\n        bool isLevelUp,\n        uint payment\n    );\n\n    event P0_PremiumMix_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed itemId,\n        uint itemAmount,\n        bool isLevelUp,\n        uint payment,\n        uint usePower\n    );\n\n    event P0_ItemMerge_Event(\n        address indexed to,\n        uint indexed perfId,\n        uint indexed itemId,\n        uint itemAmount,\n        uint payment,\n        uint perfGrade,\n        bytes perfURI\n    );\n\n    event P0_AddProb_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed payment,\n        uint addProb,\n        uint[] perfs\n    );\n\n    // uint payment\n    function _baseMixCall(\n        address _sender,\n        uint _id,\n        uint _useItemId\n    ) internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_id) == _sender,\n            \"not owner\"\n        );\n        IDB.aien memory _AIEN = IDB(s.contracts[\"db\"]).AIENS(_id);\n\n        require(s.p0_gradeInfos[_AIEN.p2Level].isOpen == true, \"not open\");\n\n        (\n            address _influencer,\n            address _agency,\n            uint _influencerFee,\n            uint _agencyFee\n        ) = IDB(s.contracts[\"db\"])._levelUpCalcul(\n                _useItemId,\n                s.p0_gradeInfos[_AIEN.p2Level].mixFee\n            );\n\n        IERC1155(s.contracts[\"item\"]).burn(_sender, _useItemId, 1);\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        if (_AIEN.p2Level == 0) {\n            IDB(s.contracts[\"db\"])._levelUpSucess(_id, _AIEN.p2Level);\n            emit P0_BaseMix_Event(\n                _sender,\n                _id,\n                _useItemId,\n                1,\n                true,\n                s.p0_gradeInfos[_AIEN.p2Level].mixFee\n            );\n            // emit MixCall(_id, 0, true, s.p0_gradeInfos[_AIEN.p2Level].mixFee);\n\n            return true;\n        }\n\n        uint _random = __random(_sender);\n\n        // 성공시\n        if (_random <= _AIEN.baseProb) {\n            // 성공률 초기화\n            // 레벨 상승\n            IDB(s.contracts[\"db\"])._levelUpSucess(_id, _AIEN.p2Level);\n        } else {\n            // base성공률에 랜덤 성공률 추가\n\n            uint _randomAdd = __randomAddProb(\n                _sender,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMax,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMin\n            );\n            // 경험치 상승\n            // _AIEN[_id].baseProb += _randomAdd;\n\n            IDB(s.contracts[\"db\"])._levelUpFailed(_id, _randomAdd);\n        }\n\n        // emit MixCall(\n        //     _id,\n        //     0,\n        //     _random <= _AIEN.baseProb,\n        //     s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        // );\n        emit P0_BaseMix_Event(\n            _sender,\n            _id,\n            _useItemId,\n            1,\n            _random <= _AIEN.baseProb,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n        return true;\n    }\n\n    function _premiumMixCall(\n        address _sender,\n        uint _aienId,\n        uint _useItemId\n    ) internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        IDB.aien memory _AIEN = IDB(s.contracts[\"db\"]).AIENS(_aienId);\n\n        require(_AIEN.p2Level != 0, \"not premium level\");\n        require(s.p0_gradeInfos[_AIEN.p2Level].isOpen == true, \"not open\");\n\n        (\n            address _influencer,\n            address _agency,\n            uint _influencerFee,\n            uint _agencyFee\n        ) = IDB(s.contracts[\"db\"])._levelUpCalcul(\n                _useItemId,\n                s.p0_gradeInfos[_AIEN.p2Level].mixFee\n            );\n\n        IERC1155(s.contracts[\"item\"]).burn(_sender, _useItemId, 1);\n\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        uint _random = __random(_sender);\n        uint totalProb = 0;\n        if (_AIEN.baseProb + _AIEN.addProb >= s.p0_states.maxProb) {\n            // if (_AIEN.baseProb + _AIEN.addProb > _random) {\n            totalProb = _AIEN.baseProb + _AIEN.addProb - s.p0_states.maxProb;\n        }\n\n        if (_AIEN.baseProb + _AIEN.addProb >= _random) {\n            emit P0_PremiumMix_Event(\n                _sender,\n                _aienId,\n                _useItemId,\n                1,\n                true,\n                s.p0_gradeInfos[_AIEN.p2Level].mixFee,\n                totalProb == 0 ? _AIEN.addProb : _AIEN.addProb - totalProb\n            );\n            // 성공률 초기화\n            // 레벨 상승\n            IDB(s.contracts[\"db\"])._successAienSet(\n                _aienId,\n                _AIEN.p2Level + 1,\n                _AIEN.totalExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                _AIEN.influExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                s.p0_gradeInfos[_AIEN.p2Level].initBaseProb,\n                totalProb\n            );\n        } else {\n            emit P0_PremiumMix_Event(\n                _sender,\n                _aienId,\n                _useItemId,\n                1,\n                false,\n                s.p0_gradeInfos[_AIEN.p2Level].mixFee,\n                totalProb == 0 ? _AIEN.addProb : _AIEN.addProb - totalProb\n            );\n\n            uint _randomAdd = __randomAddProb(\n                _sender,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMax,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMin\n            );\n\n            IDB(s.contracts[\"db\"])._failedAienSet(\n                _aienId,\n                _AIEN.totalExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                _AIEN.influExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                _AIEN.baseProb + _randomAdd,\n                totalProb\n            );\n        }\n\n        return true;\n    }\n\n    function _itemMerge(\n        address _sender,\n        uint _itemId,\n        uint _itemAmount\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint mergeFee;\n        address _influencer;\n        uint _influencerFee;\n        address _agency;\n        uint _agencyFee;\n        uint _influencerItemAmount;\n\n        if (_itemId <= 50) {\n            (\n                mergeFee,\n                _influencer,\n                _influencerFee,\n                _agency,\n                _agencyFee,\n                _influencerItemAmount\n            ) = IDB(s.contracts[\"db\"])._mergeCalcul(_itemId);\n        } else {\n            (\n                mergeFee,\n                _influencer,\n                _influencerFee,\n                _agency,\n                _agencyFee,\n                _influencerItemAmount\n            ) = IDB(s.contracts[\"db\"])._mergeCalcul2(_itemId);\n        }\n\n        require(_itemAmount == _influencerItemAmount);\n\n        // merge 할때 카운트 적용 함수\n        IDB(s.contracts[\"db\"])._mergeCount(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee\n        );\n        //\n        IERC1155(s.contracts[\"item\"]).burn(_sender, _itemId, _itemAmount);\n\n        // IERC20(PER).transferFrom(msg.sender, address(this), mergeFee);\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            mergeFee\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee,\n            mergeFee\n        );\n\n        (uint mintPfId, string memory _pfURI) = IDB(s.contracts[\"db\"])\n            ._influencerMerge(_sender, _itemId, 0);\n\n        emit P0_ItemMerge_Event(\n            _sender,\n            mintPfId,\n            _itemId,\n            _itemAmount,\n            mergeFee,\n            1,\n            bytes(_pfURI)\n        );\n    }\n\n    function _itemGradeMerge(\n        address _sender,\n        uint _itemId,\n        uint _itemAmount,\n        uint8 _grade\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P0_MergePfGrade storage _mergePfGrade = s.p0_mergePfGrades[_grade];\n        string memory _seedHash = s.pfMetaURI[_mergePfGrade.latestId];\n        require(_mergePfGrade.isOpen, \"PF Grade Merge function not open\");\n\n        (\n            uint _mergeFee,\n            address _influencer,\n            uint _influencerFee,\n            address _agency,\n            uint _agencyFee,\n            uint _influencerItemAmount\n        ) = _mergeCalculate(_itemId, _grade);\n\n        IDB(s.contracts[\"db\"])._mergeCount(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee\n        );\n        // require(\n        //     _mergeFee < IERC20(s.contracts[\"per\"]).balanceOf(_sender),\n        //     \"not enough per\"\n        // );\n        // require(_itemAmount == _influencerItemAmount, \"not equal item amount\");\n        IERC1155(s.contracts[\"item\"]).burn(\n            _sender,\n            _itemId,\n            _influencerItemAmount\n        );\n\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            _mergeFee\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee,\n            _mergeFee\n        );\n\n        IDB(s.contracts[\"db\"])._itemMergeFromDiamond(\n            _sender,\n            _mergePfGrade.latestId,\n            _seedHash,\n            _grade\n        );\n\n        emit P0_ItemMerge_Event(\n            _sender,\n            _mergePfGrade.latestId,\n            _itemId,\n            _influencerItemAmount,\n            _mergeFee,\n            _grade,\n            bytes(_seedHash)\n        );\n\n        _mergePfGrade.latestId += 1;\n    }\n\n    function _addProbCall(\n        address _sender,\n        uint _aienId,\n        uint[] memory _pf_Ids\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_aienId) == _sender,\n            \"not owner\"\n        );\n\n        require(__checkDuplicates(_pf_Ids) == false, \"duplicate pf id\");\n        require(\n            __checkERC721sOwner(_sender, _pf_Ids) == true,\n            \"not owner of perfriends\"\n        );\n        uint _gradeProb = __checkERC721sGrade(_pf_Ids);\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            s.p0_states.addProbFee * _pf_Ids.length\n        );\n\n        for (uint i = 0; i < _pf_Ids.length; i++) {\n            IERC721(s.contracts[\"perfriends\"]).burn(_pf_Ids[i]);\n            IDB(s.contracts[\"db\"]).subPfGrades(_pf_Ids[i]);\n        }\n\n        IDB.aien memory _AIEN = IDB(s.contracts[\"db\"]).AIENS(_aienId);\n        IDB(s.contracts[\"db\"]).setAienAll(\n            _aienId,\n            _AIEN.mixCount,\n            _AIEN.p2Level,\n            _AIEN.totalExp + (s.p0_states.addProbExp * _pf_Ids.length),\n            _AIEN.influExp,\n            _AIEN.baseProb,\n            0,\n            _AIEN.isPFid,\n            _AIEN.addProb + _gradeProb\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            s.contracts[\"team\"],\n            (s.p0_states.addProbFee * _pf_Ids.length) / 10,\n            s.contracts[\"team\"],\n            0,\n            s.p0_states.addProbFee * _pf_Ids.length\n        );\n\n        emit P0_AddProb_Event(\n            _sender,\n            _aienId,\n            s.p0_states.addProbFee,\n            _gradeProb,\n            _pf_Ids\n        );\n    }\n\n    // internal functions\n    function __random(address _sender) internal view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // if (s.orakl  ? oraklVRF() : nativeRF())\n        bytes32 hash = keccak256(\n            abi.encodePacked(block.timestamp, _sender, block.coinbase)\n        );\n        return (uint(hash) % (s.p0_states.maxProb - 0 + 1)) + 0;\n    }\n\n    function __randomAddProb(\n        address _sender,\n        uint _max,\n        uint _min\n    ) internal view returns (uint) {\n        // if (s.orakl  ? oraklVRF() : nativeRF())\n        bytes32 hash = keccak256(\n            abi.encodePacked(block.timestamp, _sender, block.coinbase)\n        );\n        return (uint(hash) % (_max - _min + 1)) + _min;\n    }\n\n    function __checkDuplicates(\n        uint[] memory array\n    ) internal pure returns (bool) {\n        for (uint i = 0; i < array.length - 1; i++) {\n            for (uint j = i + 1; j < array.length; j++) {\n                if (array[i] == array[j]) return true;\n            }\n        }\n        return false;\n    }\n\n    // 다중 ERC721 owner확인\n    function __checkERC721sOwner(\n        address _owner,\n        uint[] memory _ids\n    ) internal view returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        for (uint i = 0; i < _ids.length; i++) {\n            if (IERC721(s.contracts[\"perfriends\"]).ownerOf(_ids[i]) != _owner)\n                return false;\n        }\n        return true;\n    }\n\n    // 다중 ERC721의 등급별 mixPFInfos 합을 구한다.\n    function __checkERC721sGrade(\n        uint[] memory _ids\n    ) internal view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint _gradeProb = 0;\n        for (uint i = 0; i < _ids.length; i++) {\n            _gradeProb += s\n                .p0_perFriendsProbs[IDB(s.contracts[\"db\"]).PFS(_ids[i]).class]\n                .gradeProb;\n        }\n        return _gradeProb;\n    }\n\n    function _getAddProbFee() internal view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return IDB(s.contracts[\"p0\"]).addProbFee();\n    }\n\n    function _getMergeState(uint _itemId) internal view returns (uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        (uint PerPrice, , , , , uint ItemAmount) = IDB(s.contracts[\"db\"])\n            ._mergeCalcul(_itemId);\n        return (PerPrice, ItemAmount);\n    }\n\n    function _mergeCalculate(\n        uint _itemId,\n        uint8 _grade\n    ) internal view returns (uint, address, uint, address, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P0_MergeState memory _mergeState = s.p0_mergeState;\n        IDB.User memory _user = IDB(s.contracts[\"db\"]).getUserFromItem(_itemId);\n        P0_MergePfGrade storage _mergePfGrade = s.p0_mergePfGrades[_grade];\n\n        address agency;\n        address influencer;\n        uint _influeIncome = (_mergePfGrade.mergeFee *\n            _mergeState.influencerIncomePercent) / 1e5;\n        uint _agencyIncome = (_mergePfGrade.mergeFee *\n            _mergeState.agencyIncomePercent) / 1e5;\n\n        _user.agency == address(0)\n            ? agency = s.contracts[\"team\"]\n            : agency = _user.agency;\n        influencer = _user.incomeAddr == address(0)\n            ? s.contracts[\"team\"]\n            : _user.incomeAddr;\n\n        return (\n            _mergePfGrade.mergeFee,\n            influencer,\n            _influeIncome,\n            agency,\n            _agencyIncome,\n            _mergePfGrade.mergeUseItemAmount\n        );\n    }\n}\n"
    },
    "contracts/Channel_iN/libraries/LibP2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {LibAppStorage, AppStorage, P2_Layer,P2_Aien,P2_User} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\n\n// libs\nimport \"../../shared/libraries/LibEnumerableSet.sol\";\n\nlibrary LibP2 {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    struct AienLoadData {\n\t\t//aien정보\n\t\tuint _aienId;\n\t\tuint _aienLevel;\n\t\t// 출금 토탈\n\t\tuint _aien_base_received;\n\t\tuint _aien_plus_received;\n\t\t//출금 가능\n\t\tuint base_withdrawable;\n\t\tuint plus_withdrawable;\n\t\t// block당 리워드\n\t\tuint block_reward_base;\n\t\tuint block_reward_plus;\n\t}\n\n\tstruct LayerLoadData {\n\t\tbool isOpen;\n\t\tuint _layerNumber;\n\t\tuint _24h_reward_base;\n\t\tuint _24h_reward_plus;\n\t\tuint totalStakedAien;\n\t}\n\tstruct UserLoadData {\n\t\tuint _baseRewarded;\n\t\tuint _plusRewarded;\n\t\tbool _isBlockUser;\n\t}\n\n    modifier isOpenLayer(uint _layer) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.p2_layers[_layer].isOpen, \"P2: Layer is not open\");\n        _;\n    }\n\n    modifier isBlackUser(address _sender) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(!s.p2_users[_sender].isBlockUser, \"P2: BlackList User\");\n        _;\n    }\n\n    modifier isP2StopCheck() {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.isP2Stop, \"P2: P2 is stopped\");\n        _;\n    }\n\n    modifier isMaxStakingLimit(address _sender) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.p2_users[_sender].tokenIds.length() < s.P2_MAX_STAKING_LIMIT, \"P2: Max Staking Limit\");\n        _;\n    }\n\n\n    function _P2_Layer_Reset(uint _layerNumber) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        s.p2_layers[_layerNumber].dailyRewardUpdateBlock = block.number;\n        s.p2_layers[_layerNumber].lastRewardBlock = block.number;\n\n        s.p2_layers[_layerNumber].balances.savedBaseBalance += s.p2_layers[_layerNumber].balances.baseBalance;\n        s.p2_layers[_layerNumber].balances.savedPlusBalance += s.p2_layers[_layerNumber].balances.plusBalance;\n\n        (uint dailyBASE, uint dailyPLUS) = __P2_Daily_Calculate(s.P2_baseBalance,s.P2_plusBalance, s.P2_dailyRewardPercent);\n        (uint add_dailyBASE, uint add_dailyPLUS) = __P2_Daily_Calculate(\n            s.p2_layers[_layerNumber].balances.savedBaseBalance, \n            s.p2_layers[_layerNumber].balances.savedPlusBalance, \n            s.p2_layers[_layerNumber].add_dailyReward_Percent\n        );\n        \n        s.p2_layers[_layerNumber].balances.savedBaseBalance -= add_dailyBASE;\n        s.p2_layers[_layerNumber].balances.savedPlusBalance -= add_dailyPLUS;\n\n        s.p2_layers[_layerNumber].balances.baseBalance = \n        ((dailyBASE / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[_layerNumber].rewardBasePercent) + \n        add_dailyBASE;\n\n        s.p2_layers[_layerNumber].balances.plusBalance = \n        ((dailyPLUS / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[_layerNumber].rewardPlusPercent) +\n        add_dailyPLUS;\n\n        __P2_Layer_Update(_layerNumber);\n    }\n\n\n    function _P2_Add_Base_Distribution(uint _base, uint _plus) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.P2_baseBalance += _base;\n        s.P2_plusBalance += _plus;\n\n        __P2_Update();\n    }\n\n    function _P2_Add_Plus_Distribution(uint _plus) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.P2_plusBalance += _plus;\n\n        __P2_Update();\n    }\n\n    function __P2_Update() internal isP2StopCheck() returns (uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        if(s.P2_dailyRewardUpdateBlock == block.number) return block.number;\n\n        if(block.number > s.P2_dailyRewardUpdateBlock + s.DAY_TO_SEC ) {\n\n            uint distri_base = 0;\n            uint distri_plus = 0;\n\n\n            while(block.number > s.P2_dailyRewardUpdateBlock + s.DAY_TO_SEC){\n                s.P2_dailyRewardUpdateBlock += s.DAY_TO_SEC;\n                \n                (uint dailyBASE, uint dailyPLUS) = __P2_Daily_Calculate(s.P2_baseBalance,s.P2_plusBalance, s.P2_dailyRewardPercent);\n                \n                for(uint8 i = 1; i < 11; i++){\n\n                    // 미오픈 레이어라면, saved 리워드만 추가\n                    if(!s.p2_layers[i].isOpen){\n                        s.p2_layers[i].balances.baseBalance = 0;\n                        s.p2_layers[i].balances.plusBalance = 0;\n                        s.p2_layers[i].balances.savedBaseBalance += ((dailyBASE / s.REWARD_PERCENT_DECIMAL) * \n                        s.p2_layers[i].rewardBasePercent);\n                        s.p2_layers[i].balances.savedPlusBalance += ((dailyPLUS / s.REWARD_PERCENT_DECIMAL) *\n                        s.p2_layers[i].rewardPlusPercent);\n\n                        distri_base += ((dailyBASE / s.REWARD_PERCENT_DECIMAL) * \n                        s.p2_layers[i].rewardBasePercent);\n\n                        distri_plus += ((dailyPLUS / s.REWARD_PERCENT_DECIMAL) *\n                        s.p2_layers[i].rewardPlusPercent);\n\n                        continue;\n                    }\n\n                (uint add_dailyBASE, uint add_dailyPLUS) = __P2_Daily_Calculate(\n                        s.p2_layers[i].balances.savedBaseBalance,\n                        s.p2_layers[i].balances.savedPlusBalance,\n                        s.p2_layers[i].add_dailyReward_Percent\n                );                \n\n                s.p2_layers[i].balances.baseBalance = \n                ((dailyBASE / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardBasePercent) +\n                add_dailyBASE;\n\n                s.p2_layers[i].balances.plusBalance = \n                ((dailyPLUS / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardPlusPercent) +\n                add_dailyPLUS;\n\n                s.p2_layers[i].balances.savedBaseBalance -= add_dailyBASE;\n                s.p2_layers[i].balances.savedPlusBalance -= add_dailyPLUS;\n\n                distri_base += (dailyBASE / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardBasePercent;\n                distri_plus += (dailyPLUS / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardPlusPercent;\n                    \n                }\n            s.P2_baseBalance -= distri_base;\n            s.P2_plusBalance -= distri_plus;\n            }\n        }\n        return block.number;\n    }\n    // function __P2_Update() internal isP2StopCheck() returns (uint){\n    //     AppStorage storage s = LibAppStorage.diamondStorage();\n\n    //     if(s.P2_dailyRewardUpdateBlock == block.number) return block.number;\n\n    //     if(block.number > s.P2_dailyRewardUpdateBlock + s.DAY_TO_SEC ) {\n\n    //         uint distri_base = 0;\n    //         uint distri_plus = 0;\n\n\n    //         while(block.number > s.P2_dailyRewardUpdateBlock + s.DAY_TO_SEC){\n    //             s.P2_dailyRewardUpdateBlock += s.DAY_TO_SEC;\n    //             (uint dailyBASE, uint dailyPLUS) = __P2_Daily_Calculate(s.P2_baseBalance,s.P2_plusBalance, s.P2_dailyRewardPercent);\n                \n    //             for(uint8 i = 1; i < 11; i++){\n    //                 (uint add_dailyBASE, uint add_dailyPLUS) = __P2_Daily_Calculate(\n    //                     s.p2_layers[i].balances.savedBaseBalance,\n    //                     s.p2_layers[i].balances.savedPlusBalance,\n    //                     s.p2_layers[i].add_dailyReward_Percent\n    //                 );\n    //             distri_base += (dailyBASE / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardBasePercent;\n    //             distri_plus += (dailyPLUS / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardPlusPercent;\n\n    //             if(!s.p2_layers[i].isOpen){\n    //                 s.p2_layers[i].balances.baseBalance = 0;\n    //                 s.p2_layers[i].balances.plusBalance = 0;\n    //                 s.p2_layers[i].balances.savedBaseBalance += ((dailyBASE / s.REWARD_PERCENT_DECIMAL) * \n    //                 s.p2_layers[i].rewardBasePercent);\n    //                 s.p2_layers[i].balances.savedPlusBalance += ((dailyPLUS / s.REWARD_PERCENT_DECIMAL) *\n    //                 s.p2_layers[i].rewardPlusPercent);\n\n    //             continue;\n\n    //             }\n\n    //             s.p2_layers[i].balances.savedBaseBalance -= add_dailyBASE;\n    //             s.p2_layers[i].balances.savedPlusBalance -= add_dailyPLUS;\n\n    //             s.p2_layers[i].balances.baseBalance = \n    //             ((dailyBASE / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardBasePercent) +\n    //             add_dailyBASE;\n\n    //             s.p2_layers[i].balances.plusBalance = \n    //             ((dailyPLUS / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardPlusPercent) +\n    //             add_dailyPLUS;\n\n    //         }\n    //         //분배 되어야할 dailyReward 차감\n    //         s.P2_baseBalance -= distri_base;\n    //         s.P2_plusBalance -= distri_plus;\n    //         }\n    //     }\n    //     return block.number;\n    // }\n\n    function __P2_Layer_Update(uint _layerNumber) internal isOpenLayer(_layerNumber) returns (uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.p2_layers[_layerNumber].isOpen, \"P2: Layer is not open\");\n        P2_Layer storage layer = s.p2_layers[_layerNumber];\n        \n        uint accRewardBase = 0;\n        uint accRewardPlus = 0;\n\n        if(layer.lastRewardBlock == block.number) return block.number;\n        if(layer.totalStakedAien == 0) return block.number;\n\n        if(block.number > layer.dailyRewardUpdateBlock + s.DAY_TO_SEC){\n            while(block.number > layer.dailyRewardUpdateBlock + s.DAY_TO_SEC){\n                layer.dailyRewardUpdateBlock += s.DAY_TO_SEC;\n\n                // acc = 남은블록의 리워드 * 데일리 리워드 퍼센트                \n                accRewardBase = ((layer.dailyRewardUpdateBlock - layer.lastRewardBlock) *\n                (layer.balances.baseBalance / s.DAY_TO_SEC) *\n                ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n                \n                layer.rewardBase += accRewardBase / layer.totalStakedAien;\n                \n\n                // acc = 남은블록의 리워드 * 데일리 리워드 퍼센트\n                accRewardPlus = ((layer.dailyRewardUpdateBlock - layer.lastRewardBlock) *\n                (layer.balances.plusBalance / s.DAY_TO_SEC) *\n                ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n\n                layer.rewardPlus += accRewardPlus / layer.totalStakedAien;\n\n                ///////////// \n                layer.lastRewardBlock = layer.dailyRewardUpdateBlock;\n            }\n        }\n\n        accRewardBase = ((block.number - layer.lastRewardBlock) *\n        (layer.balances.baseBalance / s.DAY_TO_SEC) *\n        ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n        layer.rewardBase += accRewardBase / layer.totalStakedAien;\n\n\n        accRewardPlus = ((block.number - layer.lastRewardBlock) *\n        (layer.balances.plusBalance / s.DAY_TO_SEC) *\n        ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n        layer.rewardPlus += accRewardPlus / layer.totalStakedAien;\n        /////////////\n        layer.lastRewardBlock = block.number;\n\n        return block.number;\n    }\n\n    function __P2_Pending_Reward(uint _aienId, uint _layerNumber) internal view returns (uint, uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_Layer memory layer = s.p2_layers[_layerNumber];\n        P2_Aien memory aien = s.p2_aiens[_aienId];\n        if(layer.totalStakedAien == 0) return (0,0);\n\n        uint _dailyRewardUpdateBlock = layer.dailyRewardUpdateBlock;\n\t\tuint _lastRewardBlock = layer.lastRewardBlock;\n\t\tuint _rewardBase = layer.rewardBase;\n\t\tuint _rewardPlus = layer.rewardPlus;\n\t\tuint _REWARD_BASE_SUPPLY = layer.balances.baseBalance;\n\t\tuint _REWARD_PLUS_SUPPLY = layer.balances.plusBalance;\n\t\tuint accRewardBase = 0;\n\t\tuint accRewardPlus = 0;\n\t\tuint _nowBlock = block.number;\n\n        if(_nowBlock > layer.dailyRewardUpdateBlock + s.DAY_TO_SEC){\n            while(_nowBlock > _dailyRewardUpdateBlock + s.DAY_TO_SEC){\n                \n                _dailyRewardUpdateBlock += s.DAY_TO_SEC;\n\n                accRewardBase = ((_dailyRewardUpdateBlock - _lastRewardBlock) *\n                (_REWARD_BASE_SUPPLY / s.DAY_TO_SEC) *\n                ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n                \n\n                _rewardBase += accRewardBase / layer.totalStakedAien;\n                _REWARD_BASE_SUPPLY = accRewardBase / s.PRECISION_FACTOR;\n\n                accRewardPlus = ((_dailyRewardUpdateBlock - _lastRewardBlock) *\n                (_REWARD_PLUS_SUPPLY / s.DAY_TO_SEC) *\n                ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n                \n\n                _rewardPlus += accRewardPlus / layer.totalStakedAien;\n                _REWARD_PLUS_SUPPLY = accRewardPlus / s.PRECISION_FACTOR;\n\n                _lastRewardBlock = _dailyRewardUpdateBlock;\n            }\n        }\n        // \n        accRewardBase = ((_nowBlock - _lastRewardBlock) *\n        (_REWARD_BASE_SUPPLY / s.DAY_TO_SEC) *\n        ((layer.dailyReward_Percent * s.PRECISION_FACTOR) / s.REWARD_PERCENT_DECIMAL));\n\n        _rewardBase += accRewardBase / layer.totalStakedAien;\n        // \n        accRewardPlus = ((_nowBlock - _lastRewardBlock) *\n        (_REWARD_PLUS_SUPPLY / s.DAY_TO_SEC) *\n        ((layer.dailyReward_Percent * s.PRECISION_FACTOR) / s.REWARD_PERCENT_DECIMAL));\n\n        _rewardPlus += accRewardPlus / layer.totalStakedAien;  \n        // \n\n        uint totalRewardBase = _rewardBase - aien.rewardBaseDebt;\n        uint totalRewardPlus = _rewardPlus - aien.rewardPlusDebt;\n\n        return (totalRewardBase / s.PRECISION_FACTOR, totalRewardPlus / s.PRECISION_FACTOR);\n    }\n\n    // \n    // \n    // \n\n    function __P2_Daily_Calculate(uint _baseBalance, uint _plusBalance, uint _dailyRewardPercent) internal pure returns(uint,uint) {\n        uint dailyBASE = (_baseBalance * _dailyRewardPercent) / 1e5;\n        uint dailyPLUS = (_plusBalance * _dailyRewardPercent) / 1e5;\n\n        return (dailyBASE, dailyPLUS);\n    }\n\n\n\n    function __P2_Reward_Transfer(address _to, uint _base, uint _plus) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\t\tIERC20(s.contracts[\"per\"]).transferFrom(s.contracts[\"p2balance\"], _to, _base);\n        IERC20(s.contracts[\"per\"]).transferFrom(s.contracts[\"p2balance\"], _to, _plus);\n    }\n\n    function __P2_Aien_Transfer(address _staker, uint _aienId) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        IERC721(s.contracts[\"aien\"]).safeTransferFrom(s.contracts[\"p2balance\"], _staker, _aienId);\n    }\n\n\n    \n\n\n    // admin Functions\n    function __P2_Layer_Start(uint _layerNumber) internal {\n        _P2_Layer_Reset(_layerNumber);\n    }\n\n    // user call functions\n    function diamond_P2_deposit(\n\t\taddress _sender,\n\t\tuint _aienId\n\t) internal isMaxStakingLimit(_sender) isBlackUser(_sender) isP2StopCheck {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint _layer = IDB(s.contracts[\"db\"]).getAienLevel(_aienId);\n        P2_Layer storage layer = s.p2_layers[_layer];\n\n\n        \n        if(layer.totalStakedAien == 0){\n            __P2_Layer_Start(_layer);\n        }\n\n        __P2_Update();\n        __P2_Layer_Update(_layer);\n\n        P2_User storage user = s.p2_users[_sender];\n        P2_Aien storage aien = s.p2_aiens[_aienId];\n\n        user.tokenIds.add(_aienId);\n\n        aien.staker = _sender;\n        aien.level = _layer;\n\n        layer.totalStakedAien += 1;\n\n        aien.rewardBaseDebt = layer.rewardBase;\n        aien.rewardPlusDebt = layer.rewardPlus;\n\n        \n    }\n\n        \n    function diamond_P2_withdraw(\n        address _sender,\n\t\tuint _aienId) internal isBlackUser(_sender) isP2StopCheck returns(uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_User storage user = s.p2_users[_sender];\n        P2_Aien storage aien = s.p2_aiens[_aienId];\n        P2_Layer storage layer = s.p2_layers[aien.level];\n\n        uint pendingBASE;\n        uint pendingPLUS;\n\n        __P2_Update();\n        __P2_Layer_Update(aien.level);\n\n        (pendingBASE, pendingPLUS) = __P2_Pending_Reward(_aienId, aien.level);\n\n\n        __P2_Reward_Transfer(aien.staker, pendingBASE, pendingPLUS);\n\n        user.baseRewarded += pendingBASE;\n        user.plusRewarded += pendingPLUS;\n        \n        aien.base_received += pendingBASE;\n        aien.plus_received += pendingPLUS;\n        \n        user.tokenIds.remove(_aienId);\n\n        layer.totalStakedAien -= 1;\n\n        if(layer.totalStakedAien == 0){\n        layer.dailyRewardUpdateBlock = 0;\n        layer.lastRewardBlock = 0;\n        layer.balances.add_dailyBASE = 0;\n        layer.balances.add_dailyPLUS = 0;\n\n        layer.rewardBase = 0;\n        layer.rewardPlus = 0;\n        }\n\n        aien.rewardBase += pendingBASE;\n        aien.rewardPlus += pendingPLUS;\n        aien.rewardBaseDebt = layer.rewardBase;\n        aien.rewardPlusDebt = layer.rewardPlus;\n\n        __P2_Aien_Transfer(aien.staker, _aienId);\n\n        aien.staker = address(0);\n\n        return block.number;\n    }\n\n    function diamond_P2_harvest(address _sender, uint _aienId) isP2StopCheck internal returns (uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_User storage user = s.p2_users[_sender];\n        P2_Aien storage aien = s.p2_aiens[_aienId];\n        P2_Layer storage layer = s.p2_layers[aien.level];\n\n        uint pendingBASE;\n        uint pendingPLUS;\n\n        __P2_Update();\n        __P2_Layer_Update(aien.level);\n\n        (pendingBASE, pendingPLUS) = __P2_Pending_Reward(_aienId, aien.level);\n\n        __P2_Reward_Transfer(_sender, pendingBASE, pendingPLUS);\n\n        user.baseRewarded += pendingBASE;\n        user.plusRewarded += pendingPLUS;\n        \n        aien.rewardBaseDebt = layer.rewardBase;\n        aien.rewardPlusDebt = layer.rewardPlus;\n\n        aien.rewardBase += pendingBASE;\n        aien.rewardPlus += pendingPLUS;\n\n        aien.base_received += pendingBASE;\n        aien.plus_received += pendingPLUS;\n\n        return block.number;\n    }\n\n\n\n// view data\n    function diamond_P2_getUserInfo(address _user) internal view returns (UserLoadData memory, AienLoadData[] memory, LayerLoadData[] memory){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_User storage user = s.p2_users[_user];\n        UserLoadData memory _UserLoadData = UserLoadData(\n            user.baseRewarded,\n            user.plusRewarded,\n            user.isBlockUser\n        );\n\n        AienLoadData[] memory _AienLoadData = new AienLoadData[](user.tokenIds.length());\n\t\tLayerLoadData[] memory _LayerLoadData = new LayerLoadData[](11);\n\n        for (uint i = 0; i < user.tokenIds.length(); i++) {\n            \n            P2_Aien memory aien = s.p2_aiens[user.tokenIds.at(i)];\n\n\t\t\t(uint _base, uint _plus) = __P2_Pending_Reward(user.tokenIds.at(i), aien.level);\n\n\t\t\t_AienLoadData[i]._aienId = user.tokenIds.at(i);\n\t\t\t_AienLoadData[i]._aienLevel = aien.level;\n\t\t\t_AienLoadData[i]._aien_base_received = aien.base_received;\n\t\t\t_AienLoadData[i]._aien_plus_received = aien.plus_received;\n\t\t\t_AienLoadData[i].block_reward_base =\n\t\t\t\t((s.p2_layers[aien.level].balances.baseBalance *\n\t\t\t\t\ts.p2_layers[aien.level].dailyReward_Percent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL /\n\t\t\t\t\ts.p2_layers[aien.level].totalStakedAien) /\n\t\t\t\ts.DAY_TO_SEC;\n\n\t\t\t_AienLoadData[i].block_reward_plus =\n\t\t\t\t((s.p2_layers[aien.level].balances.plusBalance *\n\t\t\t\t\ts.p2_layers[aien.level].dailyReward_Percent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL /\n\t\t\t\t\ts.p2_layers[aien.level].totalStakedAien) /\n\t\t\t\ts.DAY_TO_SEC;\n\t\t\t_AienLoadData[i].base_withdrawable = _base;\n\t\t\t_AienLoadData[i].plus_withdrawable = _plus;\n\t\t}\n\n        for (uint i = 1; i < 11; i++) {\n\t\t\tP2_Layer memory layer = s.p2_layers[i];\n\n\t\t\t(uint add_dailyBASE, uint add_dailyPLUS) = __P2_Daily_Calculate(\n\t\t\t\tlayer.balances.savedBaseBalance,\n\t\t\t\tlayer.balances.savedPlusBalance,\n\t\t\t\tlayer.add_dailyReward_Percent\n\t\t\t);\n\t\t\tuint _totalStakedAien;\n\t\t\tlayer.totalStakedAien == 0 ? _totalStakedAien = 1 : _totalStakedAien = layer.totalStakedAien;\n\t\t\t_LayerLoadData[i]._layerNumber = i;\n\t\t\t_LayerLoadData[i].isOpen = layer.isOpen;\n\t\t\t_LayerLoadData[i]._24h_reward_base =\n\t\t\t\t(((((s.P2_baseBalance * s.P2_dailyRewardPercent) / s.REWARD_PERCENT_DECIMAL) * layer.rewardBasePercent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL) + add_dailyBASE) /\n\t\t\t\t_totalStakedAien;\n\n\t\t\t_LayerLoadData[i]._24h_reward_plus =\n\t\t\t\t(((((s.P2_plusBalance * s.P2_dailyRewardPercent) / s.REWARD_PERCENT_DECIMAL) * layer.rewardPlusPercent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL) + add_dailyPLUS) /\n\t\t\t\t_totalStakedAien;\n\n\t\t\t_LayerLoadData[i].totalStakedAien = layer.totalStakedAien;\n\t\t}\n\n\t\treturn (_UserLoadData, _AienLoadData, _LayerLoadData);\n    }\n    \n    function diamond_p2_beforeLayer(uint _layerNumber) internal view returns(uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_Layer memory layer = s.p2_layers[_layerNumber];\n\n        (uint add_dailyBASE, uint add_dailyPLUS) = __P2_Daily_Calculate(\n\t\t\t\tlayer.balances.savedBaseBalance,\n\t\t\t\tlayer.balances.savedPlusBalance,\n\t\t\t\tlayer.add_dailyReward_Percent\n\t\t);\n\n        uint _base =  (((((s.P2_baseBalance * s.P2_dailyRewardPercent) / s.REWARD_PERCENT_DECIMAL) * 13000) /\n        // uint _base =  (((((s.P2_baseBalance * s.P2_dailyRewardPercent) / s.REWARD_PERCENT_DECIMAL) * layer.rewardBasePercent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL) + add_dailyBASE) /\n\t\t\t\t1;\n        uint _plus = (((((s.P2_plusBalance * s.P2_dailyRewardPercent) / s.REWARD_PERCENT_DECIMAL) * layer.rewardPlusPercent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL) + add_dailyPLUS) /\n\t\t\t\t1;\n\n        \n\n        return (_base+_plus);\n        \n\n    }\n\n    function diamond_p2_getLayerData(uint _layerNumber) internal view returns(uint,uint,uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_Layer memory layer = s.p2_layers[_layerNumber];\n        \n        uint base = (layer.balances.savedBaseBalance * layer.dailyReward_Percent) / \n        s.REWARD_PERCENT_DECIMAL / \n        (layer.totalStakedAien + 1);\n\n        uint plus = (layer.balances.savedPlusBalance * layer.dailyReward_Percent) /\n        s.REWARD_PERCENT_DECIMAL /\n        (layer.totalStakedAien + 1);\n\n        return (base / s.DAY_TO_SEC, plus / s.DAY_TO_SEC, layer.totalStakedAien);\n    }\n\n\n    function onERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 tokenId,\n\t\tbytes memory data\n\t) internal pure returns (bytes4) {\n\t\treturn bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'));\n\t}\n\n    \n\n\n}\n\n"
    },
    "contracts/shared/facets/ConstantFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\n\ncontract ConstantFacet is Modifiers {\n    function getContract(string memory _name) external view returns (address) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.contracts[_name];\n    }\n\n    function setContract(string memory _name, address _addr) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.contracts[_name] = _addr;\n    }\n}\n"
    },
    "contracts/shared/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamond.initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "contracts/shared/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { LibDiamond } from  \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external override view returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facets_ = new Facet[](ds.selectorCount);\n        uint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(ds.facets[selector]));\n                if (_facet == facet) {\n                    _facetFunctionSelectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = new address[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {                    \n                    continue;\n                }\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts/shared/facets/DistributeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage, Modifiers} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {LibDistribute} from \"../libraries/LibDistribute.sol\";\n\ncontract DistributeFacet is Modifiers {\n    // 1차로 Distribute facet에 balance를 모으고\n    // 패싯이 변경되었을때 transfer하여 balance migrate하기 위한 함수\n    function Distribute_Transfer_Balance(\n        address _facet,\n        address _tokenAddr,\n        uint _amount\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        IERC20(_tokenAddr).transfer(msgsender, _amount);\n    }\n\n    function Distribute_p0LvUpDistribute(\n        address _agency,\n        uint _agencyAmount,\n        address _influencer,\n        uint _influencerAmount,\n        uint _totalAmount\n    ) external {\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyAmount,\n            _influencer,\n            _influencerAmount,\n            _totalAmount\n        );\n    }\n\n    // function Distribute_swapToDistribute() external {\n    //     LibDistribute.swapToDistribute();\n    // }\n}\n"
    },
    "contracts/shared/facets/Orakl_DataFeedFacet.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.22;\n\n// import {IAggregator} from \"@bisonai/orakl-contracts/src/v0.1/interfaces/IAggregator.sol\";\n// import {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\n\n// contract PriceFeedFacet {\n//     function getLatestData(address _proxy) public returns (int256) {\n//         AppStorage storage s = LibAppStorage.diamondStorage();\n\n//         IAggregator dataFeed = IAggregator(_proxy);\n//         (\n//             uint80 roundId_,\n//             int256 answer_ /* uint startedAt */ /* uint updatedAt */ /* uint80 answeredInRound */,\n//             ,\n//             ,\n\n//         ) = dataFeed.latestRoundData();\n\n//         s.orakl.answer = answer_;\n//         s.orakl.roundId = roundId_;\n\n//         return answer_;\n//     }\n\n//     function decimals(address _proxy) public view returns (uint8) {\n//         IAggregator dataFeed = IAggregator(_proxy);\n//         return dataFeed.decimals();\n//     }\n// }\n"
    },
    "contracts/shared/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n}\n"
    },
    "contracts/shared/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/shared/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/shared/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC1155 {\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function burn(address account, uint256 id, uint256 value) external;\n\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/shared/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/shared/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n//import \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\n/* interface IERC721 is IERC165 { */\ninterface IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n\n    function burn(uint256 _tokenId) external;\n\n    function safeMintByMinter(address _to) external;\n\n    function nextTokenId() external view returns (uint256);\n}\n"
    },
    "contracts/shared/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/shared/interfaces/Iitem.sol": {
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.22;\n\ninterface Iitem {\n    function mint(\n        address _addr,\n        uint _id,\n        uint _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "contracts/shared/interfaces/IKlaySwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// 0xc6a2ad8cc6e4a7e08fc37cc5954be07d499e7654 KSP\n// 0x7A74B3be679E194E1D6A0C29A343ef8D2a5AC876 Util\ninterface IKlaySwap {\n    function estimateSwap(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        address[] memory path\n    ) external view returns (uint amountOut);\n\n    function exchangeKctPos(\n        address tokenA,\n        uint amountA,\n        address tokenB,\n        uint amountB,\n        address[] memory path\n    ) external;\n}\n\n\n\n\n"
    },
    "contracts/shared/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {LibDiamond} from \"./LibDiamond.sol\";\nimport {EnumerableSet} from \"../../shared/libraries/LibEnumerableSet.sol\";\nimport {LibMeta} from \"./LibMeta.sol\";\n\nusing EnumerableSet for EnumerableSet.UintSet;\n// i-Tez Structs\n//- P0 struct\nstruct P0_State {\n    uint24 maxProb;\n    // 퍼프렌즈를 이용한 PF POWER 변환시 개당 수수료\n    uint addProbFee;\n    // 퍼프렌즈를 이용한 PF POWER 변환시 획득 경험치\n    uint16 addProbExp;\n    // bool\n    bool isVRF;\n}\nstruct P0_PerFriendsProb {\n    string pfGrade;\n    uint24 gradeProb;\n}\n\nstruct P0_GradeInfo {\n    // 다음 level이 열렸는지 확인\n    bool isOpen;\n    // level별 mix fee\n    uint mixFee;\n    // 레벨업 성공시 level별 초기 base 확률\n    uint24 initBaseProb;\n    // level별 추가 확률 밸런스 조정값\n    uint16 mixExp;\n    // level별 합성 실패시 추가 확률 min,max\n    uint24 failedAddProbMin;\n    // 1000 = 0.1%, 10000 = 0.01%\n    uint24 failedAddProbMax;\n}\n\nstruct P0_MergePfGrade {\n    uint8 grade;\n    string gradeName;\n    uint mergeFee;\n    uint mergeUseItemAmount;\n    uint latestId;\n    uint setMatadataId;\n    bool isOpen;\n}\nstruct P0_MergeState {\n    uint agencyIncomePercent;\n    uint influencerIncomePercent;\n}\n// //- Distribute struct\nstruct Distribute_State {\n    uint beforeP2Usdt;\n    uint beforeP2Per;\n    uint beforeTeamUsdt;\n    // distribute ratios\n    uint24 p1Ratio;\n    uint24 p2BaseRatio;\n    // uint24 p2PerRatio;\n    uint24 p2PlusRatio;\n    // uint24 p2UsdtRatio;\n    uint24 burnRatio;\n    uint24 teamFeeRatio;\n    // uint24 teamUsdtRatio;\n}\n// DB > Filtered User Struct\nstruct User {\n    // DB > idx\n    uint userId;\n    // token itme ID\n    uint itemId;\n    address incomeAddr;\n    uint feeBalance;\n    bool isAble;\n    uint mintCount;\n    uint useLevelupCount;\n    uint useMergeCount;\n    //레퍼럴로 얻은 수익\n    uint referralIncome;\n    address agency;\n    uint agencyIncome;\n}\n\n// struct P3_AienCollection {\n//     address nftAddress;\n//     string name;\n//     string symbol;\n//     uint highestPrice;\n//     uint floorPrice;\n//     uint totalTradeVolume;\n//     uint totalTradeCount;\n// }\n\n// struct P3_Aien {\n//     uint tokenId;\n//     uint lastTradePrice;\n//     // maybe add tx history\n// }\n\n// struct P3_AienOrder {\n//     uint orderId;\n//     address seller;\n//     address buyer;\n//     uint tokenId;\n//     uint8 level;\n//     uint32 baseProb;\n//     uint32 addProb;\n//     uint price;\n//     uint tradeTime;\n//     uint8 orderType;\n// }\n\n// struct P3_PfCollection {\n//     address nftAddress;\n//     string name;\n//     string symbol;\n//     uint highestPrice;\n//     uint floorPrice;\n//     uint totalTradeVolume;\n//     uint totalTradeCount;\n// }\n\n// struct P3_PfOrder {\n//     uint orderId;\n//     address seller;\n//     address buyer;\n//     uint tokenId;\n//     uint8 grade;\n//     uint price;\n//     uint tradeTime;\n//     uint8 orderType;\n// }\n\n//\n//\n//\n//\n// P2 start\nstruct P2_State {\n    // P2 global state\n    bool isP2Stop;\n    // \n    uint P2_baseBalance;\n    uint P2_plusBalance;\n    // \n    uint P2_dailyRewardPercent;\n    // \n    uint P2_dailyRewardUpdateBlock;\n    uint P2_lastRewardBlock;\n    // \n    uint MAX_STAKING_LIMIT;\n}\n\nstruct P2_User {\n    // 블랙유저 찾아야함\n    bool isBlockUser;\n\tuint plusRewarded;\n\tuint baseRewarded;\n\tEnumerableSet.UintSet tokenIds;\n}\n\nstruct P2_Aien {\n    address staker;\n\tuint level;\n\t// requires value\n\tuint rewardPlus;\n\tuint rewardBase;\n\tuint rewardBaseDebt;\n\tuint rewardPlusDebt;\n\t////////////////////\n\tuint plus_received;\n\tuint base_received;\n}\n\nstruct P2_Balances {\n// 로직상 계산에 필요한 밸런스 변수 (실제와 다를 수 있음)\n\tuint baseBalance;\n\tuint plusBalance;\n\t// 레이어가 오픈 되지 않은 상태에서\n\t// 레이어가 오픈되면 해당 레이어에 저장된 리워드를 데일리 리워드로 추가 분배하기 위한 변수\n\tuint savedBaseBalance;\n\tuint savedPlusBalance;\n\t// 현재 savedUsdt, savedPer를 통해 나온 데일리 리워드\n\tuint add_dailyBASE;\n\tuint add_dailyPLUS;\n\t// 보안상 문제가 생겨\n\t// 예상보다 많은 withdraw를 요청하게 되는 경우\n\t// 지금까지 쌓인 레이어별 토탈 밸런스와\n\t// 지금까지 쌓인 레이어별 출금 밸런스를 비교하여\n\t// 출금 가능한지 체크하는 변수\n\tuint a;\n\tuint b;\n\tuint c;\n\tuint d;\n}\n// 0,\n// 0,\n// 80833997355037257560000,\n// 74403075216168882064000,\n// 0,0,\n// 0,0,0,0,\n\n// 1000,\n// 2000,\n// 100000,\n// 1000,\n// 0,\n// 0,\n// 0,\n// 0,\n// 0,\n// false\n\nstruct P2_Layer {\n    P2_Balances balances;\n\t// P2에서 해당 레이어에 토큰 배정 받을때 리워드 퍼센트\n    // 1~5 // 구 oUSDT\n\tuint rewardBasePercent;\n    // 6~10 // 구 PER\n\tuint rewardPlusPercent;\n    // \n\t// 유저에게 하루에 분배하는 리워드 퍼센트\n\tuint dailyReward_Percent;\n    // 미오픈시 저장한 리워드를 데일리 리워드로 추가 분배하기 위한 퍼센트변수\n\tuint add_dailyReward_Percent;\n    // \n\t// 계산에 필요\n\tuint rewardPlus;\n\tuint rewardBase;\n\t// \n    uint lastRewardBlock;\n\tuint dailyRewardUpdateBlock;\n\tuint totalStakedAien;\n\tbool isOpen;\n}\n\n\n// P0 End\nstruct AppStorage {\n    // address constants\n    mapping(string => address) contracts;\n    // i-Tez/////////////////////////////\n    // P0 ///////////////////////////////\n    P0_State p0_states;\n    P0_GradeInfo[11] p0_gradeInfos;\n    mapping(uint => P0_PerFriendsProb) p0_perFriendsProbs;\n    /////////////////////////////////////\n    // Distribute ///////////////////////\n    Distribute_State distribute_states;\n    uint aienMintFee;\n    // Distribute\n    uint ksSwapLimit;\n    bool isAutoDistribute;\n    // P0 - Item Merge Grade Infos\n    mapping(uint8 => P0_MergePfGrade) p0_mergePfGrades;\n    mapping(uint => string) pfMetaURI;\n    P0_MergeState p0_mergeState;\n    //////////////////////////\n    // P3/////////////////////\n    //\n    // // userAddr => orderIds;\n    // mapping(address => uint[]) p3_userOrders;\n    // //\n    // //\n    // // tokenId => orderIds;\n    // mapping(uint => uint[]) p3_aienTokenOrders;\n    // // orderId => orderInfo\n    // // mapping(uint => P3_Aien_Order) p3_aienOrders;\n    // //\n    // // tokenId => orderIds;\n    // mapping(uint => uint[]) p3_pfTokenOrders;\n    // // orderId => orderInfo\n    // mapping(uint => P3_PfOrder) p3_pfOrders;\n    //\n    //\n    //\n    //\n    // //////////////////////////\n    // P2////////////////////////   \n    bool isP2Stop;\n    uint P2_baseBalance;\n    uint P2_plusBalance;\n    uint P2_dailyRewardPercent;\n    uint P2_dailyRewardUpdateBlock;\n    uint P2_lastRewardBlock;\n    uint P2_MAX_STAKING_LIMIT;\n    uint DAY_TO_SEC;\n    uint REWARD_PERCENT_DECIMAL;\n    uint PRECISION_FACTOR;\n    // \n    uint[5] __gap;\n    mapping(address => P2_User) p2_users;\n    mapping(uint => P2_Aien) p2_aiens;\n    mapping(string => P2_Balances) p2_balances;\n    mapping(uint => P2_Layer) p2_layers;\n    // mapping(uint => P2_AienLoadData) p2_aienLoadDatas;\n    // mapping(uint => P2_LayerLoadData) p2_layerLoadDatas;\n    // mapping(address => P2_UserLoadData) p2_userLoadDatas;\n    \n}\n\nlibrary LibAppStorage {\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\n        assembly {\n            ds.slot := 0\n        }\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x >= 0 ? x : -x);\n    }\n}\n\n/**\n@dev global modifier\n */\ncontract Modifiers {\n    modifier onlyDev() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n}\n"
    },
    "contracts/shared/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/shared/libraries/LibDistribute.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibDiamond} from \"./LibDiamond.sol\";\nimport {LibMeta} from \"./LibMeta.sol\";\nimport {LibP2} from \"../../Channel_iN/libraries/LibP2.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IKlaySwap} from \"../interfaces/IKlaySwap.sol\";\nimport {IP2} from \"../../Channel_iN/interfaces/IP2.sol\";\nimport {IP1} from \"../../Channel_iN/interfaces/IP1.sol\";\n\nlibrary LibDistribute {\n    //\n    //\n    // ─── P0 LV UP DISTRIBUTION ─────────────────────────────────────────────────────\n    function p0LvUpDistribute(\n        address _agency,\n        uint _agencyAmount,\n        address _influencer,\n        uint _influencerAmount,\n        uint _totalAmount\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        (\n            uint p1Amount,\n            uint p2BaseAmount,\n            uint p2PlusAmount,\n            uint burnAmount,\n            uint teamFeeAmount\n        ) = distributeCalc(_totalAmount);\n        address per = s.contracts[\"per\"];\n\n        IERC20(per).transfer(_agency, _agencyAmount);\n        IERC20(per).transfer(_influencer, _influencerAmount);\n        IERC20(per).transfer(s.contracts[\"p1\"], p1Amount);\n        IERC20(per).transfer(s.contracts[\"p2balance\"], p2BaseAmount+ p2PlusAmount);\n        IERC20(per).transfer(s.contracts[\"burn\"], burnAmount);\n        IERC20(per).transfer(s.contracts[\"team\"], teamFeeAmount);\n\n        // // LibP2._P2_Add_Base_Distribution(p2Amount, 0);\n        LibP2._P2_Add_Base_Distribution(p2BaseAmount, 0);\n        LibP2._P2_Add_Plus_Distribution(p2PlusAmount);\n        IP1(s.contracts[\"p1\"]).diamond_P1_addDistributionAmountAll(p1Amount);\n        // // IERC20(PER).transfer(P1, )\n        // // 추가 되어야할 것들\n        // // 1.P1 10% PER\n        // // 2.P2 20% PER\n        // // 3.Burn 1% PER\n        // s.distribute_states.beforeP2Per += p2Amount;\n        // s.distribute_states.beforeP2Usdt += p2AmountForUsdt;\n        // s.distribute_states.beforeTeamUsdt += teamAmountForUsdt;\n    }\n\n    function distributeCalc(\n        uint _amount\n    ) internal view returns (uint, uint, uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint _p1Amount = (_amount * s.distribute_states.p1Ratio) / 100;\n        uint _p2BaseAmount = (_amount * s.distribute_states.p2BaseRatio) / 100;\n        uint _p2PlusAmount = (_amount * s.distribute_states.p2PlusRatio) /\n            100;\n        uint _burnAmount = (_amount * s.distribute_states.burnRatio) / 100;\n        uint _teamFeeAmount = (_amount *\n            s.distribute_states.teamFeeRatio) / 100;\n        return (\n            _p1Amount,\n            _p2BaseAmount,\n            _p2PlusAmount,\n            _burnAmount,\n            _teamFeeAmount\n        );\n    }\n\n    // function swapToDistribute() internal {\n    //     (bool run, uint thisBalance, uint estimateUsdt) = isSwap();\n    //     require(run == true, \"swapToDistribute: swap is not needed\");\n    //     AppStorage storage s = LibAppStorage.diamondStorage();\n\n    //     address[] memory path;\n\n    //     IERC20(s.contracts[\"per\"]).approve(\n    //         s.contracts[\"klayswap\"],\n    //         thisBalance\n    //     );\n\n    //     IKlaySwap(s.contracts[\"klayswap\"]).exchangeKctPos(\n    //         s.contracts[\"per\"],\n    //         thisBalance,\n    //         s.contracts[\"usdt\"],\n    //         estimateUsdt,\n    //         path\n    //     );\n\n    //     _swapToCalculate();\n    // }\n\n    // function _swapToCalculate() internal returns (uint, uint, uint) {\n    //     AppStorage storage s = LibAppStorage.diamondStorage();\n    //     uint usdtBalance = IERC20(s.contracts[\"usdt\"]).balanceOf(address(this));\n    //     uint calculatePercent = s.distribute_states.p2UsdtRatio +\n    //         s.distribute_states.teamUsdtRatio;\n\n    //     uint _p2UsdtAmount = (usdtBalance * s.distribute_states.p2UsdtRatio) /\n    //         calculatePercent;\n    //     uint _teamUsdtAmount = (usdtBalance *\n    //         s.distribute_states.teamUsdtRatio) / calculatePercent;\n\n    //     IERC20(s.contracts[\"per\"]).transfer(s.contracts[\"p2balance\"], _p2UsdtAmount);\n\n    //     IERC20(s.contracts[\"per\"]).transfer(\n    //         s.contracts[\"team\"],\n    //         _teamUsdtAmount\n    //     );\n\n    //     IP2(s.contracts[\"p2balance\"]).addPerUsdtDistribution(_p2UsdtAmount, 0);\n\n    //     s.distribute_states.beforeP2Per = 0;\n    //     s.distribute_states.beforeP2Usdt = 0;\n    //     s.distribute_states.beforeTeamUsdt = 0;\n    // }\n\n    // function getDistributePrice() internal view returns (uint, uint, uint) {\n    //     AppStorage storage s = LibAppStorage.diamondStorage();\n    //     return (\n    //         s.distribute_states.beforeP2Usdt,\n    //         s.distribute_states.beforeTeamUsdt,\n    //         s.distribute_states.beforeP2Per\n    //     );\n    // }\n\n    function isSwap() internal view returns (bool, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address[] memory path;\n        uint _balance = IERC20(s.contracts[\"per\"]).balanceOf(address(this));\n\n        uint estimateUsdt = IKlaySwap(s.contracts[\"klayswaputil\"]).estimateSwap(\n            s.contracts[\"per\"],\n            s.contracts[\"per\"],\n            _balance,\n            path\n        );\n\n        if (estimateUsdt > s.ksSwapLimit && s.isAutoDistribute == true) {\n            return (true, _balance, estimateUsdt);\n        } else {\n            return (false, 0, 0);\n        }\n    }\n}\n"
    },
    "contracts/shared/libraries/LibEnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/shared/libraries/LibMeta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nlibrary LibMeta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"\n            )\n        );\n\n    function domainSeparator(\n        string memory name,\n        string memory version\n    ) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n}\n"
    },
    "contracts/shared/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {    \n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init() external {\n        // adding ERC165 data\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // add your own state variables \n        // EIP-2535 specifies that the `diamondCut` function takes two optional \n        // arguments: address _init and bytes calldata _calldata\n        // These arguments are used to execute an arbitrary function using delegatecall\n        // in order to set state variables in the diamond during deployment or an upgrade\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \n    }\n\n\n}\n"
    },
    "contracts/Tez_Dex/PerDexV2/mock/TestToken1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\n\ncontract TestToken1 is ERC20, ERC20Burnable, ERC20Pausable, Ownable, ERC20Permit, ERC20Votes {\n    constructor(address initialOwner)\n        ERC20(\"TestToken1\", \"T1\")\n        Ownable(initialOwner)\n        ERC20Permit(\"TestToken1\")\n    {\n        _mint(msg.sender, 10000000000 * 10 ** decimals());\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function _update(address from, address to, uint256 value)\n        internal\n        override(ERC20, ERC20Pausable, ERC20Votes)\n    {\n        super._update(from, to, value);\n    }\n\n    function nonces(address owner)\n        public\n        view\n        override(ERC20Permit, Nonces)\n        returns (uint256)\n    {\n        return super.nonces(owner);\n    }\n}\n"
    },
    "contracts/Tez_Dex/PerDexV2/mock/TestToken2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\n\ncontract TestToken2 is ERC20, ERC20Burnable, ERC20Pausable, Ownable, ERC20Permit, ERC20Votes {\n    constructor(address initialOwner)\n        ERC20(\"TestToken2\", \"T1\")\n        Ownable(initialOwner)\n        ERC20Permit(\"TestToken2\")\n    {\n        _mint(msg.sender, 10000000000 * 10 ** decimals());\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n\n    // The following functions are overrides required by Solidity.\n\n    function _update(address from, address to, uint256 value)\n        internal\n        override(ERC20, ERC20Pausable, ERC20Votes)\n    {\n        super._update(from, to, value);\n    }\n\n    function nonces(address owner)\n        public\n        view\n        override(ERC20Permit, Nonces)\n        returns (uint256)\n    {\n        return super.nonces(owner);\n    }\n}\n"
    },
    "contracts/Tokens/aien/Aien.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.9;\n\n// import \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\n\n// contract AienTest is ERC721Upgradeable, PausableUpgradeable, OwnableUpgradeable, ERC721BurnableUpgradeable, UUPSUpgradeable {\n//     using CountersUpgradeable for CountersUpgradeable.Counter;\n\n//     CountersUpgradeable.Counter private _tokenIdCounter;\n    \n//     string public strUri;\n//     address public minter;\n\n    \n//     modifier onlyMinter() {\n//         require(msg.sender == minter, \"not minter\");\n//         _;\n//     }\n\n//     /// @custom:oz-upgrades-unsafe-allow constructor\n//     constructor() {\n//         _disableInitializers();\n//     }\n\n//     function initialize() public initializer {\n//         __ERC721_init(\"Aien\", \"Aien\");\n//         __Pausable_init();\n//         __Ownable_init();\n//         __ERC721Burnable_init();\n//         __UUPSUpgradeable_init();\n\n\n//         _tokenIdCounter._value = 1;\n//     }\n\n//     function _baseURI() internal view override returns (string memory) {\n//         return  strUri;\n//     }\n\n//     function pause() public onlyOwner {\n//         _pause();\n//     }\n\n//     function unpause() public onlyOwner {\n//         _unpause();\n//     }\n\n//     // NFT 민팅 하기 (Owner로 민트)\n//     function safeMint(address to) public onlyOwner {\n//         uint256 tokenId = _tokenIdCounter.current();\n//         _tokenIdCounter.increment();\n//         _safeMint(to, tokenId);\n//     }\n\n//     // NFT 민팅 하기 (Minter로 민트)\n//     function safeMintByMinter(address to) public onlyMinter {\n//         uint256 tokenId = _tokenIdCounter.current();\n//         _tokenIdCounter.increment();\n//         _safeMint(to, tokenId);\n//     }\n\n//     function nextTokenId() public view returns (uint256) {\n//         return _tokenIdCounter.current();\n//     }\n\n//     function _beforeTokenTransfer(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         uint256 batchSize\n//     ) internal  whenNotPaused override {\n//         super._beforeTokenTransfer(from, to, tokenId, batchSize);\n//     }\n\n//     function _authorizeUpgrade(address newImplementation) internal onlyOwner override {\n//     }\n\n//     // The following functions are overrides required by Solidity.\n//     function _burn(uint256 tokenId) internal override(ERC721Upgradeable) {\n//         super._burn(tokenId);\n//     }\n\n//     function setURI(string memory _uri) public onlyOwner {\n//         strUri = _uri;\n//     }\n\n//     function setMinter(address _minter) public onlyOwner {\n//         minter = _minter;\n//     }\n\n//     function tokenURI(uint256 tokenId)\n//         public\n//         view\n//         override(ERC721Upgradeable)\n//         returns (string memory)\n//     {\n//         return super.tokenURI(tokenId);\n//     }\n\n//     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable) returns (bool) {\n//         return super.supportsInterface(interfaceId);\n//     }\n// }\n"
    },
    "contracts/Tokens/channel_in_item/channel_in_item_V1.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.9;\n\n// import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';\n// import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\n// import '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\n// import '@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol';\n// import '@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol';\n// import '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n// interface IDB {\n// \tfunction influencerMint(uint _amount, uint _itemId, bytes calldata _data) external;\n// }\n\n// contract channel_in_item_V1 is\n// \tInitializable,\n// \tERC1155Upgradeable,\n// \tOwnableUpgradeable,\n// \tPausableUpgradeable,\n// \tERC1155BurnableUpgradeable,\n// \tERC1155SupplyUpgradeable\n// {\n// \tmapping(address => bool) public blackList;\n\n// \t/// @custom:oz-upgrades-unsafe-allow constructor\n// \tconstructor() {\n// \t\t_disableInitializers();\n// \t}\n\n// \tfunction initialize() public initializer {\n// \t\t__ERC1155_init('');\n// \t\t__Ownable_init();\n// \t\t__Pausable_init();\n// \t\t__ERC1155Burnable_init();\n// \t\t__ERC1155Supply_init();\n// \t}\n\n// \tfunction setURI(string memory newuri) public onlyOwner {\n// \t\t_setURI(newuri);\n// \t}\n\n// \tfunction pause() public onlyOwner {\n// \t\t_pause();\n// \t}\n\n// \tfunction unpause() public onlyOwner {\n// \t\t_unpause();\n// \t}\n\n// \tfunction mint(address account, uint256 id, uint256 amount, bytes memory data) public onlyOwner {\n// \t\t_mint(account, id, amount, data);\n\n// \t\t// unkwon contract\n// \t\t// IDB(address(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512)).influencerMint(amount, id, data);\n\n// \t\tif (id > 50) {\n// \t\t\t// // mainnet contract\n// \t\t\tIDB(address(0x0967358cB6a94aCF45A99Fb4ED199C081bbe2121)).influencerMint(amount, id, data);\n\n// \t\t\t// test contract\n// \t\t\t// IDB(address(0x4f47CF617Cdd6eA9d1b235Af05650cd0e83B8C62)).influencerMint(amount, id, data);\n// \t\t}\n// \t}\n\n// \tfunction mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public onlyOwner {\n// \t\t_mintBatch(to, ids, amounts, data);\n// \t}\n\n// \tfunction _beforeTokenTransfer(\n// \t\taddress operator,\n// \t\taddress from,\n// \t\taddress to,\n// \t\tuint256[] memory ids,\n// \t\tuint256[] memory amounts,\n// \t\tbytes memory data\n// \t) internal override(ERC1155Upgradeable, ERC1155SupplyUpgradeable) whenNotPaused {\n// \t\trequire(!blackList[from] && !blackList[operator] && !blackList[to], 'blackList User');\n// \t\tsuper._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n// \t}\n\n// \tfunction _setBlackList(address _user, bool _bool) public onlyOwner {\n// \t\tblackList[_user] = _bool;\n// \t}\n// }\n"
    },
    "contracts/Tokens/pen/pen.sol": {
      "content": "// pragma solidity ^0.5.0;\n\n\n// // address : 0xa37ac8c6b92ffe18b6826395af7c44c89e334de3\n// // network : cypress\n\n// /*\n//  * @dev Provides information about the current execution context, including the\n//  * sender of the transaction and its data. While these are generally available\n//  * via msg.sender and msg.data, they should not be accessed in such a direct\n//  * manner, since when dealing with GSN meta-transactions the account sending and\n//  * paying for execution may not be the actual sender (as far as an application\n//  * is concerned).\n//  *\n//  * This contract is only required for intermediate, library-like contracts.\n//  */\n// contract Context {\n//     // Empty internal constructor, to prevent people from mistakenly deploying\n//     // an instance of this contract, which should be used via inheritance.\n//     constructor() internal {}\n\n//     // solhint-disable-previous-line no-empty-blocks\n\n//     function _msgSender() internal view returns (address payable) {\n//         return msg.sender;\n//     }\n\n//     function _msgData() internal view returns (bytes memory) {\n//         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n//         return msg.data;\n//     }\n// }\n\n// /**\n//  * @dev Contract module which provides a basic access control mechanism, where\n//  * there is an account (an owner) that can be granted exclusive access to\n//  * specific functions.\n//  *\n//  * This module is used through inheritance. It will make available the modifier\n//  * `onlyOwner`, which can be applied to your functions to restrict their use to\n//  * the owner.\n//  */\n// contract Ownable is Context {\n//     address private _owner;\n\n//     event OwnershipTransferred(\n//         address indexed previousOwner,\n//         address indexed newOwner\n//     );\n\n//     /**\n//      * @dev Initializes the contract setting the deployer as the initial owner.\n//      */\n//     constructor() internal {\n//         address msgSender = _msgSender();\n//         _owner = msgSender;\n//         emit OwnershipTransferred(address(0), msgSender);\n//     }\n\n//     /**\n//      * @dev Returns the address of the current owner.\n//      */\n//     function owner() public view returns (address) {\n//         return _owner;\n//     }\n\n//     /**\n//      * @dev Throws if called by any account other than the owner.\n//      */\n//     modifier onlyOwner() {\n//         require(isOwner(), \"Ownable: caller is not the owner\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Returns true if the caller is the current owner.\n//      */\n//     function isOwner() public view returns (bool) {\n//         return _msgSender() == _owner;\n//     }\n\n//     /**\n//      * @dev Leaves the contract without owner. It will not be possible to call\n//      * `onlyOwner` functions anymore. Can only be called by the current owner.\n//      *\n//      * NOTE: Renouncing ownership will leave the contract without an owner,\n//      * thereby removing any functionality that is only available to the owner.\n//      */\n//     function renounceOwnership() public onlyOwner {\n//         emit OwnershipTransferred(_owner, address(0));\n//         _owner = address(0);\n//     }\n\n//     /**\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\n//      * Can only be called by the current owner.\n//      */\n//     function transferOwnership(address newOwner) public onlyOwner {\n//         _transferOwnership(newOwner);\n//     }\n\n//     /**\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\n//      */\n//     function _transferOwnership(address newOwner) internal {\n//         require(\n//             newOwner != address(0),\n//             \"Ownable: new owner is the zero address\"\n//         );\n//         emit OwnershipTransferred(_owner, newOwner);\n//         _owner = newOwner;\n//     }\n// }\n\n// /**\n//  *\n//  * @dev Wrappers over Solidity's arithmetic operations with added overflow\n//  * checks.\n//  *\n//  * Arithmetic operations in Solidity wrap on overflow. This can easily result\n//  * in bugs, because programmers usually assume that an overflow raises an\n//  * error, which is the standard behavior in high level programming languages.\n//  * `SafeMath` restores this intuition by reverting the transaction when an\n//  * operation overflows.\n//  *\n//  * Using this library instead of the unchecked operations eliminates an entire\n//  * class of bugs, so it's recommended to use it always.\n//  *\n//  */\n// library SafeMath {\n//     /**\n//      * @dev Returns the addition of two unsigned integers, reverting on\n//      * overflow.\n//      *\n//      * Counterpart to Solidity's `+` operator.\n//      *\n//      * Requirements:\n//      * - Addition cannot overflow.\n//      */\n//     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n//         uint256 c = a + b;\n//         require(c >= a, \"SafeMath: addition overflow\");\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the subtraction of two unsigned integers, reverting on\n//      * overflow (when the result is negative).\n//      *\n//      * Counterpart to Solidity's `-` operator.\n//      *\n//      * Requirements:\n//      * - Subtraction cannot overflow.\n//      */\n//     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b <= a, \"SafeMath: subtraction overflow\");\n//         uint256 c = a - b;\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the multiplication of two unsigned integers, reverting on\n//      * overflow.\n//      *\n//      * Counterpart to Solidity's `*` operator.\n//      *\n//      * Requirements:\n//      * - Multiplication cannot overflow.\n//      */\n//     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n//         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n//         // benefit is lost if 'b' is also tested.\n//         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n//         if (a == 0) {\n//             return 0;\n//         }\n\n//         uint256 c = a * b;\n//         require(c / a == b, \"SafeMath: multiplication overflow\");\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the integer division of two unsigned integers. Reverts on\n//      * division by zero. The result is rounded towards zero.\n//      *\n//      * Counterpart to Solidity's `/` operator. Note: this function uses a\n//      * `revert` opcode (which leaves remaining gas untouched) while Solidity\n//      * uses an invalid opcode to revert (consuming all remaining gas).\n//      *\n//      * Requirements:\n//      * - The divisor cannot be zero.\n//      */\n//     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n//         // Solidity only automatically asserts when dividing by 0\n//         require(b > 0, \"SafeMath: division by zero\");\n//         uint256 c = a / b;\n//         // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n//      * Reverts when dividing by zero.\n//      *\n//      * Counterpart to Solidity's `%` operator. This function uses a `revert`\n//      * opcode (which leaves remaining gas untouched) while Solidity uses an\n//      * invalid opcode to revert (consuming all remaining gas).\n//      *\n//      * Requirements:\n//      * - The divisor cannot be zero.\n//      */\n//     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b != 0, \"SafeMath: modulo by zero\");\n//         return a % b;\n//     }\n// }\n\n// /**\n//  * @dev Interface of the KIP-13 standard, as defined in the\n//  * [KIP-13](http://kips.klaytn.com/KIPs/kip-13-interface_query_standard).\n//  *\n//  * Implementers can declare support of contract interfaces, which can then be\n//  * queried by others.\n//  *\n//  * For an implementation, see `KIP13`.\n//  */\n// interface IKIP13 {\n//     /**\n//      * @dev Returns true if this contract implements the interface defined by\n//      * `interfaceId`. See the corresponding\n//      * [KIP-13 section](http://kips.klaytn.com/KIPs/kip-13-interface_query_standard#how-interface-identifiers-are-defined)\n//      * to learn more about how these ids are created.\n//      *\n//      * This function call must use less than 30 000 gas.\n//      */\n//     function supportsInterface(bytes4 interfaceId) external view returns (bool);\n// }\n\n// /**\n//  * @title Roles\n//  * @dev Library for managing addresses assigned to a Role.\n//  */\n// library Roles {\n//     struct Role {\n//         mapping(address => bool) bearer;\n//     }\n\n//     /**\n//      * @dev Give an account access to this role.\n//      */\n//     function add(Role storage role, address account) internal {\n//         require(!has(role, account), \"Roles: account already has role\");\n//         role.bearer[account] = true;\n//     }\n\n//     /**\n//      * @dev Remove an account's access to this role.\n//      */\n//     function remove(Role storage role, address account) internal {\n//         require(has(role, account), \"Roles: account does not have role\");\n//         role.bearer[account] = false;\n//     }\n\n//     /**\n//      * @dev Check if an account has this role.\n//      * @return bool\n//      */\n//     function has(Role storage role, address account)\n//         internal\n//         view\n//         returns (bool)\n//     {\n//         require(account != address(0), \"Roles: account is the zero address\");\n//         return role.bearer[account];\n//     }\n// }\n\n// contract PauserRole {\n//     using Roles for Roles.Role;\n\n//     event PauserAdded(address indexed account);\n//     event PauserRemoved(address indexed account);\n\n//     Roles.Role private _pausers;\n\n//     constructor() internal {\n//         _addPauser(msg.sender);\n//     }\n\n//     modifier onlyPauser() {\n//         require(\n//             isPauser(msg.sender),\n//             \"PauserRole: caller does not have the Pauser role\"\n//         );\n//         _;\n//     }\n\n//     function isPauser(address account) public view returns (bool) {\n//         return _pausers.has(account);\n//     }\n\n//     function addPauser(address account) public onlyPauser {\n//         _addPauser(account);\n//     }\n\n//     function renouncePauser() public {\n//         _removePauser(msg.sender);\n//     }\n\n//     function _addPauser(address account) internal {\n//         _pausers.add(account);\n//         emit PauserAdded(account);\n//     }\n\n//     function _removePauser(address account) internal {\n//         _pausers.remove(account);\n//         emit PauserRemoved(account);\n//     }\n// }\n\n// /**\n//  * @dev Implementation of the `IKIP13` interface.\n//  *\n//  * Contracts may inherit from this and call `_registerInterface` to declare\n//  * their support of an interface.\n//  */\n// contract KIP13 is IKIP13 {\n//     /*\n//      * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP13 = 0x01ffc9a7;\n\n//     /**\n//      * @dev Mapping of interface ids to whether or not it's supported.\n//      */\n//     mapping(bytes4 => bool) private _supportedInterfaces;\n\n//     constructor() internal {\n//         // Derived contracts need only register support for their own interfaces,\n//         // we register support for KIP13 itself here\n//         _registerInterface(_INTERFACE_ID_KIP13);\n//     }\n\n//     /**\n//      * @dev See `IKIP13.supportsInterface`.\n//      *\n//      * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n//      */\n//     function supportsInterface(bytes4 interfaceId)\n//         external\n//         view\n//         returns (bool)\n//     {\n//         return _supportedInterfaces[interfaceId];\n//     }\n\n//     /**\n//      * @dev Registers the contract as an implementer of the interface defined by\n//      * `interfaceId`. Support of the actual KIP13 interface is automatic and\n//      * registering its interface id is not required.\n//      *\n//      * See `IKIP13.supportsInterface`.\n//      *\n//      * Requirements:\n//      *\n//      * - `interfaceId` cannot be the KIP13 invalid interface (`0xffffffff`).\n//      */\n//     function _registerInterface(bytes4 interfaceId) internal {\n//         require(interfaceId != 0xffffffff, \"KIP13: invalid interface id\");\n//         _supportedInterfaces[interfaceId] = true;\n//     }\n// }\n\n// /**\n//  * @dev Required interface of an KIP17 compliant contract.\n//  */\n// contract IKIP17 is IKIP13 {\n//     event Transfer(\n//         address indexed from,\n//         address indexed to,\n//         uint256 indexed tokenId\n//     );\n//     event Approval(\n//         address indexed owner,\n//         address indexed approved,\n//         uint256 indexed tokenId\n//     );\n//     event ApprovalForAll(\n//         address indexed owner,\n//         address indexed operator,\n//         bool approved\n//     );\n\n//     /**\n//      * @dev Returns the number of NFTs in `owner`'s account.\n//      */\n//     function balanceOf(address owner) public view returns (uint256 balance);\n\n//     /**\n//      * @dev Returns the owner of the NFT specified by `tokenId`.\n//      */\n//     function ownerOf(uint256 tokenId) public view returns (address owner);\n\n//     /**\n//      * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n//      * another (`to`).\n//      *\n//      * Requirements:\n//      * - `from`, `to` cannot be zero.\n//      * - `tokenId` must be owned by `from`.\n//      * - If the caller is not `from`, it must be have been allowed to move this\n//      * NFT by either `approve` or `setApproveForAll`.\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public;\n\n//     /**\n//      * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n//      * another (`to`).\n//      *\n//      * Requirements:\n//      * - If the caller is not `from`, it must be approved to move this NFT by\n//      * either `approve` or `setApproveForAll`.\n//      */\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public;\n\n//     function approve(address to, uint256 tokenId) public;\n\n//     function getApproved(uint256 tokenId)\n//         public\n//         view\n//         returns (address operator);\n\n//     function setApprovalForAll(address operator, bool _approved) public;\n\n//     function isApprovedForAll(address owner, address operator)\n//         public\n//         view\n//         returns (bool);\n\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public;\n// }\n\n// /**\n//  * @title ERC721 token receiver interface\n//  * @dev Interface for any contract that wants to support safeTransfers\n//  * from ERC721 asset contracts.\n//  */\n// contract IERC721Receiver {\n//     /**\n//      * @notice Handle the receipt of an NFT\n//      * @dev The ERC721 smart contract calls this function on the recipient\n//      * after a `safeTransfer`. This function MUST return the function selector,\n//      * otherwise the caller will revert the transaction. The selector to be\n//      * returned can be obtained as `this.onERC721Received.selector`. This\n//      * function MAY throw to revert and reject the transfer.\n//      * Note: the ERC721 contract address is always the message sender.\n//      * @param operator The address which called `safeTransferFrom` function\n//      * @param from The address which previously owned the token\n//      * @param tokenId The NFT identifier which is being transferred\n//      * @param data Additional data with no specified format\n//      * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n//      */\n//     function onERC721Received(\n//         address operator,\n//         address from,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public returns (bytes4);\n// }\n\n// /**\n//  * @title KIP17 token receiver interface\n//  * @dev Interface for any contract that wants to support safeTransfers\n//  * from KIP17 asset contracts.\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Receiver {\n//     /**\n//      * @notice Handle the receipt of an NFT\n//      * @dev The KIP17 smart contract calls this function on the recipient\n//      * after a `safeTransfer`. This function MUST return the function selector,\n//      * otherwise the caller will revert the transaction. The selector to be\n//      * returned can be obtained as `this.onKIP17Received.selector`. This\n//      * function MAY throw to revert and reject the transfer.\n//      * Note: the KIP17 contract address is always the message sender.\n//      * @param operator The address which called `safeTransferFrom` function\n//      * @param from The address which previously owned the token\n//      * @param tokenId The NFT identifier which is being transferred\n//      * @param data Additional data with no specified format\n//      * @return bytes4 `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`\n//      */\n//     function onKIP17Received(\n//         address operator,\n//         address from,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public returns (bytes4);\n// }\n\n// /**\n//  * @dev Collection of functions related to the address type,\n//  */\n// library Address {\n//     /**\n//      * @dev Returns true if `account` is a contract.\n//      *\n//      * This test is non-exhaustive, and there may be false-negatives: during the\n//      * execution of a contract's constructor, its address will be reported as\n//      * not containing a contract.\n//      *\n//      * > It is unsafe to assume that an address for which this function returns\n//      * false is an externally-owned account (EOA) and not a contract.\n//      */\n//     function isContract(address account) internal view returns (bool) {\n//         // This method relies in extcodesize, which returns 0 for contracts in\n//         // construction, since the code is only stored at the end of the\n//         // constructor execution.\n\n//         uint256 size;\n//         // solhint-disable-next-line no-inline-assembly\n//         assembly {\n//             size := extcodesize(account)\n//         }\n//         return size > 0;\n//     }\n// }\n\n// /**\n//  * @title Counters\n//  * @author Matt Condon (@shrugs)\n//  * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n//  * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n//  *\n//  * Include with `using Counters for Counters.Counter;`\n//  * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n//  * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n//  * directly accessed.\n//  */\n// library Counters {\n//     using SafeMath for uint256;\n\n//     struct Counter {\n//         // This variable should never be directly accessed by users of the library: interactions must be restricted to\n//         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n//         // this feature: see https://github.com/ethereum/solidity/issues/4637\n//         uint256 _value; // default: 0\n//     }\n\n//     function current(Counter storage counter) internal view returns (uint256) {\n//         return counter._value;\n//     }\n\n//     function increment(Counter storage counter) internal {\n//         counter._value += 1;\n//     }\n\n//     function decrement(Counter storage counter) internal {\n//         counter._value = counter._value.sub(1);\n//     }\n// }\n\n// /**\n//  * @title KIP17 Non-Fungible Token Standard basic implementation\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17 is KIP13, IKIP17 {\n//     using SafeMath for uint256;\n//     using Address for address;\n//     using Counters for Counters.Counter;\n\n//     // Equals to `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`\n//     // which can be also obtained as `IKIP17Receiver(0).onKIP17Received.selector`\n//     bytes4 private constant _KIP17_RECEIVED = 0x6745782b;\n\n//     // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n//     // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n//     bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n//     // Mapping from token ID to owner\n//     mapping(uint256 => address) private _tokenOwner;\n\n//     // Mapping from token ID to approved address\n//     mapping(uint256 => address) private _tokenApprovals;\n\n//     // Mapping from owner to number of owned token\n//     mapping(address => Counters.Counter) private _ownedTokensCount;\n\n//     // Mapping from owner to operator approvals\n//     mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n//     /*\n//      *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n//      *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n//      *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n//      *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n//      *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n//      *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c\n//      *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n//      *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n//      *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n//      *\n//      *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n//      *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17 = 0x80ac58cd;\n\n//     constructor() public {\n//         // register the supported interfaces to conform to KIP17 via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17);\n//     }\n\n//     /**\n//      * @dev Gets the balance of the specified address.\n//      * @param owner address to query the balance of\n//      * @return uint256 representing the amount owned by the passed address\n//      */\n//     function balanceOf(address owner) public view returns (uint256) {\n//         require(\n//             owner != address(0),\n//             \"KIP17: balance query for the zero address\"\n//         );\n\n//         return _ownedTokensCount[owner].current();\n//     }\n\n//     /**\n//      * @dev Gets the owner of the specified token ID.\n//      * @param tokenId uint256 ID of the token to query the owner of\n//      * @return address currently marked as the owner of the given token ID\n//      */\n//     function ownerOf(uint256 tokenId) public view returns (address) {\n//         address owner = _tokenOwner[tokenId];\n//         require(\n//             owner != address(0),\n//             \"KIP17: owner query for nonexistent token\"\n//         );\n\n//         return owner;\n//     }\n\n//     /**\n//      * @dev Approves another address to transfer the given token ID\n//      * The zero address indicates there is no approved address.\n//      * There can only be one approved address per token at a given time.\n//      * Can only be called by the token owner or an approved operator.\n//      * @param to address to be approved for the given token ID\n//      * @param tokenId uint256 ID of the token to be approved\n//      */\n//     function approve(address to, uint256 tokenId) public {\n//         address owner = ownerOf(tokenId);\n//         require(to != owner, \"KIP17: approval to current owner\");\n\n//         require(\n//             msg.sender == owner || isApprovedForAll(owner, msg.sender),\n//             \"KIP17: approve caller is not owner nor approved for all\"\n//         );\n\n//         _tokenApprovals[tokenId] = to;\n//         emit Approval(owner, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Gets the approved address for a token ID, or zero if no address set\n//      * Reverts if the token ID does not exist.\n//      * @param tokenId uint256 ID of the token to query the approval of\n//      * @return address currently approved for the given token ID\n//      */\n//     function getApproved(uint256 tokenId) public view returns (address) {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17: approved query for nonexistent token\"\n//         );\n\n//         return _tokenApprovals[tokenId];\n//     }\n\n//     /**\n//      * @dev Sets or unsets the approval of a given operator\n//      * An operator is allowed to transfer all tokens of the sender on their behalf.\n//      * @param to operator address to set the approval\n//      * @param approved representing the status of the approval to be set\n//      */\n//     function setApprovalForAll(address to, bool approved) public {\n//         require(to != msg.sender, \"KIP17: approve to caller\");\n\n//         _operatorApprovals[msg.sender][to] = approved;\n//         emit ApprovalForAll(msg.sender, to, approved);\n//     }\n\n//     /**\n//      * @dev Tells whether an operator is approved by a given owner.\n//      * @param owner owner address which you want to query the approval of\n//      * @param operator operator address which you want to query the approval of\n//      * @return bool whether the given operator is approved by the given owner\n//      */\n//     function isApprovedForAll(address owner, address operator)\n//         public\n//         view\n//         returns (bool)\n//     {\n//         return _operatorApprovals[owner][operator];\n//     }\n\n//     /**\n//      * @dev Transfers the ownership of a given token ID to another address.\n//      * Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\n//      * Requires the msg.sender to be the owner, approved, or operator.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public {\n//         //solhint-disable-next-line max-line-length\n//         require(\n//             _isApprovedOrOwner(msg.sender, tokenId),\n//             \"KIP17: transfer caller is not owner nor approved\"\n//         );\n\n//         _transferFrom(from, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Safely transfers the ownership of a given token ID to another address\n//      * If the target address is a contract, it must implement `onKIP17Received`,\n//      * which is called upon a safe transfer, and return the magic value\n//      * `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`; otherwise,\n//      * the transfer is reverted.\n//      * Requires the msg.sender to be the owner, approved, or operator\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public {\n//         safeTransferFrom(from, to, tokenId, \"\");\n//     }\n\n//     /**\n//      * @dev Safely transfers the ownership of a given token ID to another address\n//      * If the target address is a contract, it must implement `onKIP17Received`,\n//      * which is called upon a safe transfer, and return the magic value\n//      * `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`; otherwise,\n//      * the transfer is reverted.\n//      * Requires the msg.sender to be the owner, approved, or operator\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @param _data bytes data to send along with a safe transfer check\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory _data\n//     ) public {\n//         transferFrom(from, to, tokenId);\n//         require(\n//             _checkOnKIP17Received(from, to, tokenId, _data),\n//             \"KIP17: transfer to non KIP17Receiver implementer\"\n//         );\n//     }\n\n//     /**\n//      * @dev Returns whether the specified token exists.\n//      * @param tokenId uint256 ID of the token to query the existence of\n//      * @return bool whether the token exists\n//      */\n//     function _exists(uint256 tokenId) internal view returns (bool) {\n//         address owner = _tokenOwner[tokenId];\n//         return owner != address(0);\n//     }\n\n//     /**\n//      * @dev Returns whether the given spender can transfer a given token ID.\n//      * @param spender address of the spender to query\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @return bool whether the msg.sender is approved for the given token ID,\n//      * is an operator of the owner, or is the owner of the token\n//      */\n//     function _isApprovedOrOwner(address spender, uint256 tokenId)\n//         internal\n//         view\n//         returns (bool)\n//     {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17: operator query for nonexistent token\"\n//         );\n//         address owner = ownerOf(tokenId);\n//         return (spender == owner ||\n//             getApproved(tokenId) == spender ||\n//             isApprovedForAll(owner, spender));\n//     }\n\n//     /**\n//      * @dev Internal function to mint a new token.\n//      * Reverts if the given token ID already exists.\n//      * @param to The address that will own the minted token\n//      * @param tokenId uint256 ID of the token to be minted\n//      */\n//     function _mint(address to, uint256 tokenId) internal {\n//         require(to != address(0), \"KIP17: mint to the zero address\");\n//         require(!_exists(tokenId), \"KIP17: token already minted\");\n\n//         _tokenOwner[tokenId] = to;\n//         _ownedTokensCount[to].increment();\n\n//         emit Transfer(address(0), to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         require(\n//             ownerOf(tokenId) == owner,\n//             \"KIP17: burn of token that is not own\"\n//         );\n\n//         _clearApproval(tokenId);\n\n//         _ownedTokensCount[owner].decrement();\n//         _tokenOwner[tokenId] = address(0);\n\n//         emit Transfer(owner, address(0), tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(uint256 tokenId) internal {\n//         _burn(ownerOf(tokenId), tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to transfer ownership of a given token ID to another address.\n//      * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) internal {\n//         require(\n//             ownerOf(tokenId) == from,\n//             \"KIP17: transfer of token that is not own\"\n//         );\n//         require(to != address(0), \"KIP17: transfer to the zero address\");\n\n//         _clearApproval(tokenId);\n\n//         _ownedTokensCount[from].decrement();\n//         _ownedTokensCount[to].increment();\n\n//         _tokenOwner[tokenId] = to;\n\n//         emit Transfer(from, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to invoke `onKIP17Received` on a target address.\n//      * The call is not executed if the target address is not a contract.\n//      *\n//      * This function is deprecated.\n//      * @param from address representing the previous owner of the given token ID\n//      * @param to target address that will receive the tokens\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @param _data bytes optional data to send along with the call\n//      * @return bool whether the call correctly returned the expected magic value\n//      */\n//     function _checkOnKIP17Received(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory _data\n//     ) internal returns (bool) {\n//         if (!to.isContract()) {\n//             return true;\n//         }\n\n//         // Logic for compatibility with ERC721.\n//         bytes4 retval = IERC721Receiver(to).onERC721Received(\n//             msg.sender,\n//             from,\n//             tokenId,\n//             _data\n//         );\n//         if (retval == _ERC721_RECEIVED) {\n//             return true;\n//         }\n\n//         retval = IKIP17Receiver(to).onKIP17Received(\n//             msg.sender,\n//             from,\n//             tokenId,\n//             _data\n//         );\n//         return (retval == _KIP17_RECEIVED);\n//     }\n\n//     /**\n//      * @dev Private function to clear current approval of a given token ID.\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _clearApproval(uint256 tokenId) private {\n//         if (_tokenApprovals[tokenId] != address(0)) {\n//             _tokenApprovals[tokenId] = address(0);\n//         }\n//     }\n// }\n\n// contract MinterRole {\n//     using Roles for Roles.Role;\n\n//     event MinterAdded(address indexed account);\n//     event MinterRemoved(address indexed account);\n\n//     Roles.Role private _minters;\n\n//     constructor() internal {\n//         _addMinter(msg.sender);\n//     }\n\n//     modifier onlyMinter() {\n//         require(\n//             isMinter(msg.sender),\n//             \"MinterRole: caller does not have the Minter role\"\n//         );\n//         _;\n//     }\n\n//     function isMinter(address account) public view returns (bool) {\n//         return _minters.has(account);\n//     }\n\n//     function addMinter(address account) public onlyMinter {\n//         _addMinter(account);\n//     }\n\n//     function renounceMinter() public {\n//         _removeMinter(msg.sender);\n//     }\n\n//     function _addMinter(address account) internal {\n//         _minters.add(account);\n//         emit MinterAdded(account);\n//     }\n\n//     function _removeMinter(address account) internal {\n//         _minters.remove(account);\n//         emit MinterRemoved(account);\n//     }\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token Standard, optional metadata extension\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Metadata is IKIP17 {\n//     function name() external view returns (string memory);\n\n//     function symbol() external view returns (string memory);\n\n//     function tokenURI(uint256 tokenId) external view returns (string memory);\n// }\n\n// contract KIP17Metadata is KIP13, KIP17, IKIP17Metadata {\n//     // Token name\n//     string private _name;\n\n//     // Token symbol\n//     string private _symbol;\n\n//     // Optional mapping for token URIs\n//     mapping(uint256 => string) private _tokenURIs;\n\n//     /*\n//      *     bytes4(keccak256('name()')) == 0x06fdde03\n//      *     bytes4(keccak256('symbol()')) == 0x95d89b41\n//      *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n//      *\n//      *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_METADATA = 0x5b5e139f;\n\n//     /**\n//      * @dev Constructor function\n//      */\n//     constructor(string memory name, string memory symbol) public {\n//         _name = name;\n//         _symbol = symbol;\n\n//         // register the supported interfaces to conform to KIP17 via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_METADATA);\n//     }\n\n//     /**\n//      * @dev Gets the token name.\n//      * @return string representing the token name\n//      */\n//     function name() external view returns (string memory) {\n//         return _name;\n//     }\n\n//     /**\n//      * @dev Gets the token symbol.\n//      * @return string representing the token symbol\n//      */\n//     function symbol() external view returns (string memory) {\n//         return _symbol;\n//     }\n\n//     /**\n//      * @dev Returns an URI for a given token ID.\n//      * Throws if the token ID does not exist. May return an empty string.\n//      * @param tokenId uint256 ID of the token to query\n//      */\n//     function tokenURI(uint256 tokenId) external view returns (string memory) {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17Metadata: URI query for nonexistent token\"\n//         );\n//         return _tokenURIs[tokenId];\n//     }\n\n//     /**\n//      * @dev Internal function to set the token URI for a given token.\n//      * Reverts if the token ID does not exist.\n//      * @param tokenId uint256 ID of the token to set its URI\n//      * @param uri string URI to assign\n//      */\n//     function _setTokenURI(uint256 tokenId, string memory uri) internal {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17Metadata: URI set of nonexistent token\"\n//         );\n//         _tokenURIs[tokenId] = uri;\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned by the msg.sender\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         super._burn(owner, tokenId);\n\n//         // Clear metadata (if any)\n//         if (bytes(_tokenURIs[tokenId]).length != 0) {\n//             delete _tokenURIs[tokenId];\n//         }\n//     }\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token Standard, optional enumeration extension\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Enumerable is IKIP17 {\n//     function totalSupply() public view returns (uint256);\n\n//     function tokenOfOwnerByIndex(address owner, uint256 index)\n//         public\n//         view\n//         returns (uint256 tokenId);\n\n//     function tokenByIndex(uint256 index) public view returns (uint256);\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token with optional enumeration extension logic\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Enumerable is KIP13, KIP17, IKIP17Enumerable {\n//     // Mapping from owner to list of owned token IDs\n//     mapping(address => uint256[]) private _ownedTokens;\n\n//     // Mapping from token ID to index of the owner tokens list\n//     mapping(uint256 => uint256) private _ownedTokensIndex;\n\n//     // Array with all token ids, used for enumeration\n//     uint256[] private _allTokens;\n\n//     // Mapping from token id to position in the allTokens array\n//     mapping(uint256 => uint256) private _allTokensIndex;\n\n//     /*\n//      *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n//      *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n//      *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n//      *\n//      *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_ENUMERABLE = 0x780e9d63;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Enumerable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_ENUMERABLE);\n//     }\n\n//     /**\n//      * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n//      * @param owner address owning the tokens list to be accessed\n//      * @param index uint256 representing the index to be accessed of the requested tokens list\n//      * @return uint256 token ID at the given index of the tokens list owned by the requested address\n//      */\n//     function tokenOfOwnerByIndex(address owner, uint256 index)\n//         public\n//         view\n//         returns (uint256)\n//     {\n//         require(\n//             index < balanceOf(owner),\n//             \"KIP17Enumerable: owner index out of bounds\"\n//         );\n//         return _ownedTokens[owner][index];\n//     }\n\n//     /**\n//      * @dev Gets the total amount of tokens stored by the contract.\n//      * @return uint256 representing the total amount of tokens\n//      */\n//     function totalSupply() public view returns (uint256) {\n//         return _allTokens.length;\n//     }\n\n//     /**\n//      * @dev Gets the token ID at a given index of all the tokens in this contract\n//      * Reverts if the index is greater or equal to the total number of tokens.\n//      * @param index uint256 representing the index to be accessed of the tokens list\n//      * @return uint256 token ID at the given index of the tokens list\n//      */\n//     function tokenByIndex(uint256 index) public view returns (uint256) {\n//         require(\n//             index < totalSupply(),\n//             \"KIP17Enumerable: global index out of bounds\"\n//         );\n//         return _allTokens[index];\n//     }\n\n//     /**\n//      * @dev Internal function to transfer ownership of a given token ID to another address.\n//      * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) internal {\n//         super._transferFrom(from, to, tokenId);\n\n//         _removeTokenFromOwnerEnumeration(from, tokenId);\n\n//         _addTokenToOwnerEnumeration(to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to mint a new token.\n//      * Reverts if the given token ID already exists.\n//      * @param to address the beneficiary that will own the minted token\n//      * @param tokenId uint256 ID of the token to be minted\n//      */\n//     function _mint(address to, uint256 tokenId) internal {\n//         super._mint(to, tokenId);\n\n//         _addTokenToOwnerEnumeration(to, tokenId);\n\n//         _addTokenToAllTokensEnumeration(tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         super._burn(owner, tokenId);\n\n//         _removeTokenFromOwnerEnumeration(owner, tokenId);\n//         // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n//         _ownedTokensIndex[tokenId] = 0;\n\n//         _removeTokenFromAllTokensEnumeration(tokenId);\n//     }\n\n//     /**\n//      * @dev Gets the list of token IDs of the requested owner.\n//      * @param owner address owning the tokens\n//      * @return uint256[] List of token IDs owned by the requested address\n//      */\n//     function _tokensOfOwner(address owner)\n//         internal\n//         view\n//         returns (uint256[] storage)\n//     {\n//         return _ownedTokens[owner];\n//     }\n\n//     /**\n//      * @dev Private function to add a token to this extension's ownership-tracking data structures.\n//      * @param to address representing the new owner of the given token ID\n//      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n//      */\n//     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n//         _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n//         _ownedTokens[to].push(tokenId);\n//     }\n\n//     /**\n//      * @dev Private function to add a token to this extension's token tracking data structures.\n//      * @param tokenId uint256 ID of the token to be added to the tokens list\n//      */\n//     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n//         _allTokensIndex[tokenId] = _allTokens.length;\n//         _allTokens.push(tokenId);\n//     }\n\n//     /**\n//      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n//      * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n//      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n//      * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n//      * @param from address representing the previous owner of the given token ID\n//      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n//      */\n//     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n//         private\n//     {\n//         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n//         // then delete the last slot (swap and pop).\n\n//         uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n//         uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n//         // When the token to delete is the last token, the swap operation is unnecessary\n//         if (tokenIndex != lastTokenIndex) {\n//             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n//             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n//             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n//         }\n\n//         // This also deletes the contents at the last position of the array\n//         _ownedTokens[from].length--;\n\n//         // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n//         // lastTokenId, or just over the end of the array if the token was the last one).\n//     }\n\n//     /**\n//      * @dev Private function to remove a token from this extension's token tracking data structures.\n//      * This has O(1) time complexity, but alters the order of the _allTokens array.\n//      * @param tokenId uint256 ID of the token to be removed from the tokens list\n//      */\n//     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n//         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n//         // then delete the last slot (swap and pop).\n\n//         uint256 lastTokenIndex = _allTokens.length.sub(1);\n//         uint256 tokenIndex = _allTokensIndex[tokenId];\n\n//         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n//         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n//         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n//         uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n//         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n//         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n//         // This also deletes the contents at the last position of the array\n//         _allTokens.length--;\n//         _allTokensIndex[tokenId] = 0;\n//     }\n// }\n\n// /**\n//  * @title Full KIP-17 Token\n//  * This implementation includes all the required and some optional functionality of the KIP-17 standard\n//  * Moreover, it includes approve all functionality using operator terminology\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Full is KIP17, KIP17Enumerable, KIP17Metadata {\n//     constructor(string memory name, string memory symbol)\n//         public\n//         KIP17Metadata(name, symbol)\n//     {\n//         // solhint-disable-previous-line no-empty-blocks\n//     }\n// }\n\n// /**\n//  * @title KIP17MetadataMintable\n//  * @dev KIP17 minting logic with metadata.\n//  */\n// contract KIP17MetadataMintable is KIP13, KIP17, KIP17Metadata, MinterRole {\n//     /*\n//      *     bytes4(keccak256('mintWithTokenURI(address,uint256,string)')) == 0x50bb4e7f\n//      *     bytes4(keccak256('isMinter(address)')) == 0xaa271e1a\n//      *     bytes4(keccak256('addMinter(address)')) == 0x983b2d56\n//      *     bytes4(keccak256('renounceMinter()')) == 0x98650275\n//      *\n//      *     => 0x50bb4e7f ^ 0xaa271e1a ^ 0x983b2d56 ^ 0x98650275 == 0xfac27f46\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_METADATA_MINTABLE = 0xfac27f46;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Mintable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_METADATA_MINTABLE);\n//     }\n\n//     /**\n//      * @dev Function to mint tokens.\n//      * @param to The address that will receive the minted tokens.\n//      * @param tokenId The token id to mint.\n//      * @param tokenURI The token URI of the minted token.\n//      * @return A boolean that indicates if the operation was successful.\n//      */\n//     function mintWithTokenURI(\n//         address to,\n//         uint256 tokenId,\n//         string memory tokenURI\n//     ) public onlyMinter returns (bool) {\n//         _mint(to, tokenId);\n//         _setTokenURI(tokenId, tokenURI);\n//         return true;\n//     }\n// }\n\n// /**\n//  * @title KIP17Mintable\n//  * @dev KIP17 minting logic.\n//  */\n// contract KIP17Mintable is KIP17, MinterRole {\n//     /*\n//      *     bytes4(keccak256('isMinter(address)')) == 0xaa271e1a\n//      *     bytes4(keccak256('addMinter(address)')) == 0x983b2d56\n//      *     bytes4(keccak256('renounceMinter()')) == 0x98650275\n//      *     bytes4(keccak256('mint(address,uint256)')) == 0x40c10f19\n//      *\n//      *     => 0xaa271e1a ^ 0x983b2d56 ^ 0x98650275 ^ 0x40c10f19 == 0xeab83e20\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_MINTABLE = 0xeab83e20;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Mintable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_MINTABLE);\n//     }\n\n//     /**\n//      * @dev Function to mint tokens.\n//      * @param to The address that will receive the minted tokens.\n//      * @param tokenId The token id to mint.\n//      * @return A boolean that indicates if the operation was successful.\n//      */\n//     function mint(address to, uint256 tokenId)\n//         public\n//         onlyMinter\n//         returns (bool)\n//     {\n//         _mint(to, tokenId);\n//         return true;\n//     }\n// }\n\n// /**\n//  * @title KIP17 Burnable Token\n//  * @dev KIP17 Token that can be irreversibly burned (destroyed).\n//  * See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Burnable is KIP13, KIP17 {\n//     /*\n//      *     bytes4(keccak256('burn(uint256)')) == 0x42966c68\n//      *\n//      *     => 0x42966c68 == 0x42966c68\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_BURNABLE = 0x42966c68;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Burnable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_BURNABLE);\n//     }\n\n//     /**\n//      * @dev Burns a specific KIP17 token.\n//      * @param tokenId uint256 id of the KIP17 token to be burned.\n//      */\n//     function burn(uint256 tokenId) public {\n//         //solhint-disable-next-line max-line-length\n//         require(\n//             _isApprovedOrOwner(msg.sender, tokenId),\n//             \"KIP17Burnable: caller is not owner nor approved\"\n//         );\n//         _burn(tokenId);\n//     }\n// }\n\n// /**\n//  * @dev Contract module which allows children to implement an emergency stop\n//  * mechanism that can be triggered by an authorized account.\n//  *\n//  * This module is used through inheritance. It will make available the\n//  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n//  * the functions of your contract. Note that they will not be pausable by\n//  * simply including this module, only once the modifiers are put in place.\n//  */\n// contract Pausable is PauserRole {\n//     /**\n//      * @dev Emitted when the pause is triggered by a pauser (`account`).\n//      */\n//     event Paused(address account);\n\n//     /**\n//      * @dev Emitted when the pause is lifted by a pauser (`account`).\n//      */\n//     event Unpaused(address account);\n\n//     bool private _paused;\n\n//     /**\n//      * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n//      * to the deployer.\n//      */\n//     constructor() internal {\n//         _paused = false;\n//     }\n\n//     /**\n//      * @dev Returns true if the contract is paused, and false otherwise.\n//      */\n//     function paused() public view returns (bool) {\n//         return _paused;\n//     }\n\n//     /**\n//      * @dev Modifier to make a function callable only when the contract is not paused.\n//      */\n//     modifier whenNotPaused() {\n//         require(!_paused, \"Pausable: paused\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Modifier to make a function callable only when the contract is paused.\n//      */\n//     modifier whenPaused() {\n//         require(_paused, \"Pausable: not paused\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Called by a pauser to pause, triggers stopped state.\n//      */\n//     function pause() public onlyPauser whenNotPaused {\n//         _paused = true;\n//         emit Paused(msg.sender);\n//     }\n\n//     /**\n//      * @dev Called by a pauser to unpause, returns to normal state.\n//      */\n//     function unpause() public onlyPauser whenPaused {\n//         _paused = false;\n//         emit Unpaused(msg.sender);\n//     }\n// }\n\n// /**\n//  * @title KIP17 Non-Fungible Pausable token\n//  * @dev KIP17 modified with pausable transfers.\n//  */\n// contract KIP17Pausable is KIP13, KIP17, Pausable {\n//     /*\n//      *     bytes4(keccak256('paused()')) == 0x5c975abb\n//      *     bytes4(keccak256('pause()')) == 0x8456cb59\n//      *     bytes4(keccak256('unpause()')) == 0x3f4ba83a\n//      *     bytes4(keccak256('isPauser(address)')) == 0x46fbf68e\n//      *     bytes4(keccak256('addPauser(address)')) == 0x82dc1ec4\n//      *     bytes4(keccak256('renouncePauser()')) == 0x6ef8d66d\n//      *\n//      *     => 0x5c975abb ^ 0x8456cb59 ^ 0x3f4ba83a ^ 0x46fbf68e ^ 0x82dc1ec4 ^ 0x6ef8d66d == 0x4d5507ff\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_PAUSABLE = 0x4d5507ff;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Pausable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_PAUSABLE);\n//     }\n\n//     function approve(address to, uint256 tokenId) public whenNotPaused {\n//         super.approve(to, tokenId);\n//     }\n\n//     function setApprovalForAll(address to, bool approved) public whenNotPaused {\n//         super.setApprovalForAll(to, approved);\n//     }\n\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public whenNotPaused {\n//         super.transferFrom(from, to, tokenId);\n//     }\n// }\n\n// contract KIP17Token is\n//     KIP17Full,\n//     KIP17Mintable,\n//     KIP17MetadataMintable,\n//     KIP17Burnable,\n//     KIP17Pausable,\n//     Ownable\n// {\n//     constructor(string memory name, string memory symbol)\n//         public\n//         KIP17Full(name, symbol)\n//     {}\n// }\n"
    },
    "contracts/Tokens/per/per.sol": {
      "content": "// /**\n//     dev_team.gutalik\n// */\n// pragma solidity ^0.4.24;\n// /**\n//     * @title SafeMath\n// * @dev Math operations with safety checks that revert on error\n// */\n// library SafeMath {\n//     /**\n//         * @dev Multiplies two numbers, reverts on overflow.\n//         */\n//     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n//         if (a == 0) {\n//             return 0;\n//         }\n//         uint256 c = a * b;\n//         require(c / a == b);\n//         return c;\n//     }\n//     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b > 0);\n//         uint256 c = a / b;\n//         return c;\n//     }\n//     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b <= a);\n//         uint256 c = a - b;\n//         return c;\n//     }\n//     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n//         uint256 c = a + b;\n//         require(c >= a);\n//         return c;\n//     }\n//     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b != 0);\n//         return a % b;\n//     }\n// }\n// contract owned {\n//     address public owner;\n//     constructor() public {\n//         owner = msg.sender;\n//     }\n//     modifier onlyOwner {\n//         require(msg.sender == owner);\n//         _;\n//     }\n//     function transferOwnership(address newOwner) onlyOwner public {\n//         owner = newOwner;\n//     }\n// }\n// interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n// contract TokenERC20 is owned{\n//     using SafeMath for uint256;\n//     // Public variables of the token\n//     string public name;\n//     string public symbol;\n//     uint8 public decimals = 18;\n//     // 18 decimals is the strongly suggested default, avoid changing it\n//     uint256 public totalSupply;\n//     bool public released = true;\n//     // This creates an array with all balances\n//     mapping (address => uint256) public balanceOf;\n//     mapping (address => mapping (address => uint256)) public allowance;\n//     // This generates a public event on the blockchain that will notify clients\n//     event Transfer(address indexed from, address indexed to, uint256 value);\n//     // This generates a public event on the blockchain that will notify clients\n//     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n//     // This notifies clients about the amount burnt\n//     event Burn(address indexed from, uint256 value);\n//     constructor(\n//         uint256 initialSupply,\n//         string tokenName,\n//         string tokenSymbol\n//     ) public {\n//         totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount\n//         balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens\n//         name = tokenName; // Set the name for display purposes\n//         symbol = tokenSymbol; // Set the symbol for display purposes\n//     }\n//     function release() public onlyOwner{\n//         require (owner == msg.sender);\n//         released = !released;\n//     }\n//     modifier onlyReleased() {\n//         require(released);\n//         _;\n//     }\n//     function _transfer(address _from, address _to, uint _value) internal onlyReleased {\n//         // Prevent transfer to 0x0 address. Use burn() instead\n//         require(_to != 0x0);\n//         // Check if the sender has enough\n//         require(balanceOf[_from] >= _value);\n//         // Check for overflows\n//         require(balanceOf[_to] + _value > balanceOf[_to]);\n//         // Save this for an assertion in the future\n//         uint previousBalances = balanceOf[_from].add(balanceOf[_to]);\n//         // Subtract from the sender\n//         balanceOf[_from] = balanceOf[_from].sub(_value);\n//         // Add the same to the recipient\n//         balanceOf[_to] = balanceOf[_to].add(_value);\n//         emit Transfer(_from, _to, _value);\n//         // Asserts are used to use static analysis to find bugs in your code. They should never fail\n//         assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n//     }\n//     /**\n//         * Transfer tokens\n//     *\n//         * Send `_value` tokens to `_to` from your account\n//     *\n//         * @param _to The address of the recipient\n//     * @param _value the amount to send\n//     */\n//     function transfer(address _to, uint256 _value) public onlyReleased returns (bool success) {\n//         _transfer(msg.sender, _to, _value);\n//         return true;\n//     }\n//     /**\n//         * Transfer tokens from other address\n//     *\n//         * Send `_value` tokens to `_to` in behalf of `_from`\n//     *\n//         * @param _from The address of the sender\n//     * @param _to The address of the recipient\n//     * @param _value the amount to send\n//     */\n//     function transferFrom(address _from, address _to, uint256 _value) public onlyReleased returns (bool success) {\n//         require(_value <= allowance[_from][msg.sender]); // Check allowance\n//         allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n//         _transfer(_from, _to, _value);\n//         return true;\n//     }\n//     /**\n//         * Set allowance for other address\n//     *\n//         * Allows `_spender` to spend no more than `_value` tokens in your behalf\n//     *\n//         * @param _spender The address authorized to spend\n//     * @param _value the max amount they can spend\n//     */\n//     function approve(address _spender, uint256 _value) public onlyReleased\n//     returns (bool success) {\n//         require(_spender != address(0));\n//         allowance[msg.sender][_spender] = _value;\n//         emit Approval(msg.sender, _spender, _value);\n//         return true;\n//     }\n//     function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n//     public onlyReleased\n//     returns (bool success) {\n//         tokenRecipient spender = tokenRecipient(_spender);\n//         if (approve(_spender, _value)) {\n//             spender.receiveApproval(msg.sender, _value, this, _extraData);\n//             return true;\n//         }\n//     }\n//     /**\n//         * Destroy tokens\n//     *\n//         * Remove `_value` tokens from the system irreversibly\n//     *\n//         * @param _value the amount of money to burn\n//     */\n//     function burn(uint256 _value) public onlyReleased returns (bool success) {\n//         require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\n//         balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); // Subtract from the sender\n//         totalSupply = totalSupply.sub(_value); // Updates totalSupply\n//         emit Burn(msg.sender, _value);\n//         return true;\n//     }\n//     /**\n//         * Destroy tokens from other account\n//     *\n//         * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n//         *\n//         * @param _from the address of the sender\n//     * @param _value the amount of money to burn\n//     */\n//     function burnFrom(address _from, uint256 _value) public onlyReleased returns (bool success) {\n//         require(balanceOf[_from] >= _value); // Check if the targeted balance is enough\n//         require(_value <= allowance[_from][msg.sender]); // Check allowance\n//         balanceOf[_from] = balanceOf[_from].sub(_value); // Subtract from the targeted balance\n//         allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); // Subtract from the sender's allowance\n//         totalSupply = totalSupply.sub(_value); // Update totalSupply\n//         emit Burn(_from, _value);\n//         return true;\n//     }\n// }\n// contract PER is owned, TokenERC20 {\n//     mapping (address => bool) public frozenAccount;\n//     /* This generates a public event on the blockchain that will notify clients */\n//     event FrozenFunds(address target, bool frozen);\n//     /* Initializes contract with initial supply tokens to the creator of the contract */\n//     constructor(\n//         uint256 initialSupply,\n//         string tokenName,\n//         string tokenSymbol\n//     ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {\n//     }\n//     /* Internal transfer, only can be called by this contract */\n//     function _transfer(address _from, address _to, uint _value) internal onlyReleased {\n//         require (_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead\n//         require (balanceOf[_from] >= _value); // Check if the sender has enough\n//         require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n//         require(!frozenAccount[_from]); // Check if sender is frozen\n//         require(!frozenAccount[_to]); // Check if recipient is frozen\n//         balanceOf[_from] = balanceOf[_from].sub(_value); // Subtract from the sender\n//         balanceOf[_to] = balanceOf[_to].add(_value); // Add the same to the recipient\n//         emit Transfer(_from, _to, _value);\n//     }\n//     /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n//     /// @param target Address to be frozen\n//     /// @param freeze either to freeze it or not\n//     function freezeAccount(address target, bool freeze) onlyOwner public {\n//         frozenAccount[target] = freeze;\n//         emit FrozenFunds(target, freeze);\n//     }\n// }"
    },
    "contracts/Tokens/perfriends_item/pf_item.sol": {
      "content": "// pragma solidity ^0.8.0;\n\n// // contract perfriendsItem {\n\n// // }\n"
    },
    "contracts/Tokens/perfriends/perfriends.sol": {
      "content": "// pragma solidity ^0.5.0;\n\n\n\n// // address : 0x0ed55aee0399064cfe51dd3cc10d99734bb796c7\n// // network : cypress\n\n// /*\n//  * @dev Provides information about the current execution context, including the\n//  * sender of the transaction and its data. While these are generally available\n//  * via msg.sender and msg.data, they should not be accessed in such a direct\n//  * manner, since when dealing with GSN meta-transactions the account sending and\n//  * paying for execution may not be the actual sender (as far as an application\n//  * is concerned).\n//  *\n//  * This contract is only required for intermediate, library-like contracts.\n//  */\n// contract Context {\n//     // Empty internal constructor, to prevent people from mistakenly deploying\n//     // an instance of this contract, which should be used via inheritance.\n//     constructor() internal {}\n\n//     // solhint-disable-previous-line no-empty-blocks\n\n//     function _msgSender() internal view returns (address payable) {\n//         return msg.sender;\n//     }\n\n//     function _msgData() internal view returns (bytes memory) {\n//         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n//         return msg.data;\n//     }\n// }\n\n// /**\n//  * @dev Contract module which provides a basic access control mechanism, where\n//  * there is an account (an owner) that can be granted exclusive access to\n//  * specific functions.\n//  *\n//  * This module is used through inheritance. It will make available the modifier\n//  * `onlyOwner`, which can be applied to your functions to restrict their use to\n//  * the owner.\n//  */\n// contract Ownable is Context {\n//     address private _owner;\n\n//     event OwnershipTransferred(\n//         address indexed previousOwner,\n//         address indexed newOwner\n//     );\n\n//     /**\n//      * @dev Initializes the contract setting the deployer as the initial owner.\n//      */\n//     constructor() internal {\n//         address msgSender = _msgSender();\n//         _owner = msgSender;\n//         emit OwnershipTransferred(address(0), msgSender);\n//     }\n\n//     /**\n//      * @dev Returns the address of the current owner.\n//      */\n//     function owner() public view returns (address) {\n//         return _owner;\n//     }\n\n//     /**\n//      * @dev Throws if called by any account other than the owner.\n//      */\n//     modifier onlyOwner() {\n//         require(isOwner(), \"Ownable: caller is not the owner\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Returns true if the caller is the current owner.\n//      */\n//     function isOwner() public view returns (bool) {\n//         return _msgSender() == _owner;\n//     }\n\n//     /**\n//      * @dev Leaves the contract without owner. It will not be possible to call\n//      * `onlyOwner` functions anymore. Can only be called by the current owner.\n//      *\n//      * NOTE: Renouncing ownership will leave the contract without an owner,\n//      * thereby removing any functionality that is only available to the owner.\n//      */\n//     function renounceOwnership() public onlyOwner {\n//         emit OwnershipTransferred(_owner, address(0));\n//         _owner = address(0);\n//     }\n\n//     /**\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\n//      * Can only be called by the current owner.\n//      */\n//     function transferOwnership(address newOwner) public onlyOwner {\n//         _transferOwnership(newOwner);\n//     }\n\n//     /**\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\n//      */\n//     function _transferOwnership(address newOwner) internal {\n//         require(\n//             newOwner != address(0),\n//             \"Ownable: new owner is the zero address\"\n//         );\n//         emit OwnershipTransferred(_owner, newOwner);\n//         _owner = newOwner;\n//     }\n// }\n\n// /**\n//  *\n//  * @dev Wrappers over Solidity's arithmetic operations with added overflow\n//  * checks.\n//  *\n//  * Arithmetic operations in Solidity wrap on overflow. This can easily result\n//  * in bugs, because programmers usually assume that an overflow raises an\n//  * error, which is the standard behavior in high level programming languages.\n//  * `SafeMath` restores this intuition by reverting the transaction when an\n//  * operation overflows.\n//  *\n//  * Using this library instead of the unchecked operations eliminates an entire\n//  * class of bugs, so it's recommended to use it always.\n//  *\n//  */\n// library SafeMath {\n//     /**\n//      * @dev Returns the addition of two unsigned integers, reverting on\n//      * overflow.\n//      *\n//      * Counterpart to Solidity's `+` operator.\n//      *\n//      * Requirements:\n//      * - Addition cannot overflow.\n//      */\n//     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n//         uint256 c = a + b;\n//         require(c >= a, \"SafeMath: addition overflow\");\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the subtraction of two unsigned integers, reverting on\n//      * overflow (when the result is negative).\n//      *\n//      * Counterpart to Solidity's `-` operator.\n//      *\n//      * Requirements:\n//      * - Subtraction cannot overflow.\n//      */\n//     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b <= a, \"SafeMath: subtraction overflow\");\n//         uint256 c = a - b;\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the multiplication of two unsigned integers, reverting on\n//      * overflow.\n//      *\n//      * Counterpart to Solidity's `*` operator.\n//      *\n//      * Requirements:\n//      * - Multiplication cannot overflow.\n//      */\n//     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n//         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n//         // benefit is lost if 'b' is also tested.\n//         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n//         if (a == 0) {\n//             return 0;\n//         }\n\n//         uint256 c = a * b;\n//         require(c / a == b, \"SafeMath: multiplication overflow\");\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the integer division of two unsigned integers. Reverts on\n//      * division by zero. The result is rounded towards zero.\n//      *\n//      * Counterpart to Solidity's `/` operator. Note: this function uses a\n//      * `revert` opcode (which leaves remaining gas untouched) while Solidity\n//      * uses an invalid opcode to revert (consuming all remaining gas).\n//      *\n//      * Requirements:\n//      * - The divisor cannot be zero.\n//      */\n//     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n//         // Solidity only automatically asserts when dividing by 0\n//         require(b > 0, \"SafeMath: division by zero\");\n//         uint256 c = a / b;\n//         // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n//      * Reverts when dividing by zero.\n//      *\n//      * Counterpart to Solidity's `%` operator. This function uses a `revert`\n//      * opcode (which leaves remaining gas untouched) while Solidity uses an\n//      * invalid opcode to revert (consuming all remaining gas).\n//      *\n//      * Requirements:\n//      * - The divisor cannot be zero.\n//      */\n//     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b != 0, \"SafeMath: modulo by zero\");\n//         return a % b;\n//     }\n// }\n\n// /**\n//  * @dev Interface of the KIP-13 standard, as defined in the\n//  * [KIP-13](http://kips.klaytn.com/KIPs/kip-13-interface_query_standard).\n//  *\n//  * Implementers can declare support of contract interfaces, which can then be\n//  * queried by others.\n//  *\n//  * For an implementation, see `KIP13`.\n//  */\n// interface IKIP13 {\n//     /**\n//      * @dev Returns true if this contract implements the interface defined by\n//      * `interfaceId`. See the corresponding\n//      * [KIP-13 section](http://kips.klaytn.com/KIPs/kip-13-interface_query_standard#how-interface-identifiers-are-defined)\n//      * to learn more about how these ids are created.\n//      *\n//      * This function call must use less than 30 000 gas.\n//      */\n//     function supportsInterface(bytes4 interfaceId) external view returns (bool);\n// }\n\n// /**\n//  * @title Roles\n//  * @dev Library for managing addresses assigned to a Role.\n//  */\n// library Roles {\n//     struct Role {\n//         mapping(address => bool) bearer;\n//     }\n\n//     /**\n//      * @dev Give an account access to this role.\n//      */\n//     function add(Role storage role, address account) internal {\n//         require(!has(role, account), \"Roles: account already has role\");\n//         role.bearer[account] = true;\n//     }\n\n//     /**\n//      * @dev Remove an account's access to this role.\n//      */\n//     function remove(Role storage role, address account) internal {\n//         require(has(role, account), \"Roles: account does not have role\");\n//         role.bearer[account] = false;\n//     }\n\n//     /**\n//      * @dev Check if an account has this role.\n//      * @return bool\n//      */\n//     function has(Role storage role, address account)\n//         internal\n//         view\n//         returns (bool)\n//     {\n//         require(account != address(0), \"Roles: account is the zero address\");\n//         return role.bearer[account];\n//     }\n// }\n\n// contract PauserRole {\n//     using Roles for Roles.Role;\n\n//     event PauserAdded(address indexed account);\n//     event PauserRemoved(address indexed account);\n\n//     Roles.Role private _pausers;\n\n//     constructor() internal {\n//         _addPauser(msg.sender);\n//     }\n\n//     modifier onlyPauser() {\n//         require(\n//             isPauser(msg.sender),\n//             \"PauserRole: caller does not have the Pauser role\"\n//         );\n//         _;\n//     }\n\n//     function isPauser(address account) public view returns (bool) {\n//         return _pausers.has(account);\n//     }\n\n//     function addPauser(address account) public onlyPauser {\n//         _addPauser(account);\n//     }\n\n//     function renouncePauser() public {\n//         _removePauser(msg.sender);\n//     }\n\n//     function _addPauser(address account) internal {\n//         _pausers.add(account);\n//         emit PauserAdded(account);\n//     }\n\n//     function _removePauser(address account) internal {\n//         _pausers.remove(account);\n//         emit PauserRemoved(account);\n//     }\n// }\n\n// /**\n//  * @dev Implementation of the `IKIP13` interface.\n//  *\n//  * Contracts may inherit from this and call `_registerInterface` to declare\n//  * their support of an interface.\n//  */\n// contract KIP13 is IKIP13 {\n//     /*\n//      * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP13 = 0x01ffc9a7;\n\n//     /**\n//      * @dev Mapping of interface ids to whether or not it's supported.\n//      */\n//     mapping(bytes4 => bool) private _supportedInterfaces;\n\n//     constructor() internal {\n//         // Derived contracts need only register support for their own interfaces,\n//         // we register support for KIP13 itself here\n//         _registerInterface(_INTERFACE_ID_KIP13);\n//     }\n\n//     /**\n//      * @dev See `IKIP13.supportsInterface`.\n//      *\n//      * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n//      */\n//     function supportsInterface(bytes4 interfaceId)\n//         external\n//         view\n//         returns (bool)\n//     {\n//         return _supportedInterfaces[interfaceId];\n//     }\n\n//     /**\n//      * @dev Registers the contract as an implementer of the interface defined by\n//      * `interfaceId`. Support of the actual KIP13 interface is automatic and\n//      * registering its interface id is not required.\n//      *\n//      * See `IKIP13.supportsInterface`.\n//      *\n//      * Requirements:\n//      *\n//      * - `interfaceId` cannot be the KIP13 invalid interface (`0xffffffff`).\n//      */\n//     function _registerInterface(bytes4 interfaceId) internal {\n//         require(interfaceId != 0xffffffff, \"KIP13: invalid interface id\");\n//         _supportedInterfaces[interfaceId] = true;\n//     }\n// }\n\n// /**\n//  * @dev Required interface of an KIP17 compliant contract.\n//  */\n// contract IKIP17 is IKIP13 {\n//     event Transfer(\n//         address indexed from,\n//         address indexed to,\n//         uint256 indexed tokenId\n//     );\n//     event Approval(\n//         address indexed owner,\n//         address indexed approved,\n//         uint256 indexed tokenId\n//     );\n//     event ApprovalForAll(\n//         address indexed owner,\n//         address indexed operator,\n//         bool approved\n//     );\n\n//     /**\n//      * @dev Returns the number of NFTs in `owner`'s account.\n//      */\n//     function balanceOf(address owner) public view returns (uint256 balance);\n\n//     /**\n//      * @dev Returns the owner of the NFT specified by `tokenId`.\n//      */\n//     function ownerOf(uint256 tokenId) public view returns (address owner);\n\n//     /**\n//      * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n//      * another (`to`).\n//      *\n//      * Requirements:\n//      * - `from`, `to` cannot be zero.\n//      * - `tokenId` must be owned by `from`.\n//      * - If the caller is not `from`, it must be have been allowed to move this\n//      * NFT by either `approve` or `setApproveForAll`.\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public;\n\n//     /**\n//      * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n//      * another (`to`).\n//      *\n//      * Requirements:\n//      * - If the caller is not `from`, it must be approved to move this NFT by\n//      * either `approve` or `setApproveForAll`.\n//      */\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public;\n\n//     function approve(address to, uint256 tokenId) public;\n\n//     function getApproved(uint256 tokenId)\n//         public\n//         view\n//         returns (address operator);\n\n//     function setApprovalForAll(address operator, bool _approved) public;\n\n//     function isApprovedForAll(address owner, address operator)\n//         public\n//         view\n//         returns (bool);\n\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public;\n// }\n\n// /**\n//  * @title ERC721 token receiver interface\n//  * @dev Interface for any contract that wants to support safeTransfers\n//  * from ERC721 asset contracts.\n//  */\n// contract IERC721Receiver {\n//     /**\n//      * @notice Handle the receipt of an NFT\n//      * @dev The ERC721 smart contract calls this function on the recipient\n//      * after a `safeTransfer`. This function MUST return the function selector,\n//      * otherwise the caller will revert the transaction. The selector to be\n//      * returned can be obtained as `this.onERC721Received.selector`. This\n//      * function MAY throw to revert and reject the transfer.\n//      * Note: the ERC721 contract address is always the message sender.\n//      * @param operator The address which called `safeTransferFrom` function\n//      * @param from The address which previously owned the token\n//      * @param tokenId The NFT identifier which is being transferred\n//      * @param data Additional data with no specified format\n//      * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n//      */\n//     function onERC721Received(\n//         address operator,\n//         address from,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public returns (bytes4);\n// }\n\n// /**\n//  * @title KIP17 token receiver interface\n//  * @dev Interface for any contract that wants to support safeTransfers\n//  * from KIP17 asset contracts.\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Receiver {\n//     /**\n//      * @notice Handle the receipt of an NFT\n//      * @dev The KIP17 smart contract calls this function on the recipient\n//      * after a `safeTransfer`. This function MUST return the function selector,\n//      * otherwise the caller will revert the transaction. The selector to be\n//      * returned can be obtained as `this.onKIP17Received.selector`. This\n//      * function MAY throw to revert and reject the transfer.\n//      * Note: the KIP17 contract address is always the message sender.\n//      * @param operator The address which called `safeTransferFrom` function\n//      * @param from The address which previously owned the token\n//      * @param tokenId The NFT identifier which is being transferred\n//      * @param data Additional data with no specified format\n//      * @return bytes4 `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`\n//      */\n//     function onKIP17Received(\n//         address operator,\n//         address from,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public returns (bytes4);\n// }\n\n// /**\n//  * @dev Collection of functions related to the address type,\n//  */\n// library Address {\n//     /**\n//      * @dev Returns true if `account` is a contract.\n//      *\n//      * This test is non-exhaustive, and there may be false-negatives: during the\n//      * execution of a contract's constructor, its address will be reported as\n//      * not containing a contract.\n//      *\n//      * > It is unsafe to assume that an address for which this function returns\n//      * false is an externally-owned account (EOA) and not a contract.\n//      */\n//     function isContract(address account) internal view returns (bool) {\n//         // This method relies in extcodesize, which returns 0 for contracts in\n//         // construction, since the code is only stored at the end of the\n//         // constructor execution.\n\n//         uint256 size;\n//         // solhint-disable-next-line no-inline-assembly\n//         assembly {\n//             size := extcodesize(account)\n//         }\n//         return size > 0;\n//     }\n// }\n\n// /**\n//  * @title Counters\n//  * @author Matt Condon (@shrugs)\n//  * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n//  * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n//  *\n//  * Include with `using Counters for Counters.Counter;`\n//  * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n//  * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n//  * directly accessed.\n//  */\n// library Counters {\n//     using SafeMath for uint256;\n\n//     struct Counter {\n//         // This variable should never be directly accessed by users of the library: interactions must be restricted to\n//         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n//         // this feature: see https://github.com/ethereum/solidity/issues/4637\n//         uint256 _value; // default: 0\n//     }\n\n//     function current(Counter storage counter) internal view returns (uint256) {\n//         return counter._value;\n//     }\n\n//     function increment(Counter storage counter) internal {\n//         counter._value += 1;\n//     }\n\n//     function decrement(Counter storage counter) internal {\n//         counter._value = counter._value.sub(1);\n//     }\n// }\n\n// /**\n//  * @title KIP17 Non-Fungible Token Standard basic implementation\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17 is KIP13, IKIP17 {\n//     using SafeMath for uint256;\n//     using Address for address;\n//     using Counters for Counters.Counter;\n\n//     // Equals to `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`\n//     // which can be also obtained as `IKIP17Receiver(0).onKIP17Received.selector`\n//     bytes4 private constant _KIP17_RECEIVED = 0x6745782b;\n\n//     // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n//     // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n//     bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n//     // Mapping from token ID to owner\n//     mapping(uint256 => address) private _tokenOwner;\n\n//     // Mapping from token ID to approved address\n//     mapping(uint256 => address) private _tokenApprovals;\n\n//     // Mapping from owner to number of owned token\n//     mapping(address => Counters.Counter) private _ownedTokensCount;\n\n//     // Mapping from owner to operator approvals\n//     mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n//     /*\n//      *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n//      *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n//      *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n//      *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n//      *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n//      *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c\n//      *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n//      *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n//      *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n//      *\n//      *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n//      *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17 = 0x80ac58cd;\n\n//     constructor() public {\n//         // register the supported interfaces to conform to KIP17 via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17);\n//     }\n\n//     /**\n//      * @dev Gets the balance of the specified address.\n//      * @param owner address to query the balance of\n//      * @return uint256 representing the amount owned by the passed address\n//      */\n//     function balanceOf(address owner) public view returns (uint256) {\n//         require(\n//             owner != address(0),\n//             \"KIP17: balance query for the zero address\"\n//         );\n\n//         return _ownedTokensCount[owner].current();\n//     }\n\n//     /**\n//      * @dev Gets the owner of the specified token ID.\n//      * @param tokenId uint256 ID of the token to query the owner of\n//      * @return address currently marked as the owner of the given token ID\n//      */\n//     function ownerOf(uint256 tokenId) public view returns (address) {\n//         address owner = _tokenOwner[tokenId];\n//         require(\n//             owner != address(0),\n//             \"KIP17: owner query for nonexistent token\"\n//         );\n\n//         return owner;\n//     }\n\n//     /**\n//      * @dev Approves another address to transfer the given token ID\n//      * The zero address indicates there is no approved address.\n//      * There can only be one approved address per token at a given time.\n//      * Can only be called by the token owner or an approved operator.\n//      * @param to address to be approved for the given token ID\n//      * @param tokenId uint256 ID of the token to be approved\n//      */\n//     function approve(address to, uint256 tokenId) public {\n//         address owner = ownerOf(tokenId);\n//         require(to != owner, \"KIP17: approval to current owner\");\n\n//         require(\n//             msg.sender == owner || isApprovedForAll(owner, msg.sender),\n//             \"KIP17: approve caller is not owner nor approved for all\"\n//         );\n\n//         _tokenApprovals[tokenId] = to;\n//         emit Approval(owner, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Gets the approved address for a token ID, or zero if no address set\n//      * Reverts if the token ID does not exist.\n//      * @param tokenId uint256 ID of the token to query the approval of\n//      * @return address currently approved for the given token ID\n//      */\n//     function getApproved(uint256 tokenId) public view returns (address) {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17: approved query for nonexistent token\"\n//         );\n\n//         return _tokenApprovals[tokenId];\n//     }\n\n//     /**\n//      * @dev Sets or unsets the approval of a given operator\n//      * An operator is allowed to transfer all tokens of the sender on their behalf.\n//      * @param to operator address to set the approval\n//      * @param approved representing the status of the approval to be set\n//      */\n//     function setApprovalForAll(address to, bool approved) public {\n//         require(to != msg.sender, \"KIP17: approve to caller\");\n\n//         _operatorApprovals[msg.sender][to] = approved;\n//         emit ApprovalForAll(msg.sender, to, approved);\n//     }\n\n//     /**\n//      * @dev Tells whether an operator is approved by a given owner.\n//      * @param owner owner address which you want to query the approval of\n//      * @param operator operator address which you want to query the approval of\n//      * @return bool whether the given operator is approved by the given owner\n//      */\n//     function isApprovedForAll(address owner, address operator)\n//         public\n//         view\n//         returns (bool)\n//     {\n//         return _operatorApprovals[owner][operator];\n//     }\n\n//     /**\n//      * @dev Transfers the ownership of a given token ID to another address.\n//      * Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\n//      * Requires the msg.sender to be the owner, approved, or operator.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public {\n//         //solhint-disable-next-line max-line-length\n//         require(\n//             _isApprovedOrOwner(msg.sender, tokenId),\n//             \"KIP17: transfer caller is not owner nor approved\"\n//         );\n\n//         _transferFrom(from, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Safely transfers the ownership of a given token ID to another address\n//      * If the target address is a contract, it must implement `onKIP17Received`,\n//      * which is called upon a safe transfer, and return the magic value\n//      * `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`; otherwise,\n//      * the transfer is reverted.\n//      * Requires the msg.sender to be the owner, approved, or operator\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public {\n//         safeTransferFrom(from, to, tokenId, \"\");\n//     }\n\n//     /**\n//      * @dev Safely transfers the ownership of a given token ID to another address\n//      * If the target address is a contract, it must implement `onKIP17Received`,\n//      * which is called upon a safe transfer, and return the magic value\n//      * `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`; otherwise,\n//      * the transfer is reverted.\n//      * Requires the msg.sender to be the owner, approved, or operator\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @param _data bytes data to send along with a safe transfer check\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory _data\n//     ) public {\n//         transferFrom(from, to, tokenId);\n//         require(\n//             _checkOnKIP17Received(from, to, tokenId, _data),\n//             \"KIP17: transfer to non KIP17Receiver implementer\"\n//         );\n//     }\n\n//     /**\n//      * @dev Returns whether the specified token exists.\n//      * @param tokenId uint256 ID of the token to query the existence of\n//      * @return bool whether the token exists\n//      */\n//     function _exists(uint256 tokenId) internal view returns (bool) {\n//         address owner = _tokenOwner[tokenId];\n//         return owner != address(0);\n//     }\n\n//     /**\n//      * @dev Returns whether the given spender can transfer a given token ID.\n//      * @param spender address of the spender to query\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @return bool whether the msg.sender is approved for the given token ID,\n//      * is an operator of the owner, or is the owner of the token\n//      */\n//     function _isApprovedOrOwner(address spender, uint256 tokenId)\n//         internal\n//         view\n//         returns (bool)\n//     {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17: operator query for nonexistent token\"\n//         );\n//         address owner = ownerOf(tokenId);\n//         return (spender == owner ||\n//             getApproved(tokenId) == spender ||\n//             isApprovedForAll(owner, spender));\n//     }\n\n//     /**\n//      * @dev Internal function to mint a new token.\n//      * Reverts if the given token ID already exists.\n//      * @param to The address that will own the minted token\n//      * @param tokenId uint256 ID of the token to be minted\n//      */\n//     function _mint(address to, uint256 tokenId) internal {\n//         require(to != address(0), \"KIP17: mint to the zero address\");\n//         require(!_exists(tokenId), \"KIP17: token already minted\");\n\n//         _tokenOwner[tokenId] = to;\n//         _ownedTokensCount[to].increment();\n\n//         emit Transfer(address(0), to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         require(\n//             ownerOf(tokenId) == owner,\n//             \"KIP17: burn of token that is not own\"\n//         );\n\n//         _clearApproval(tokenId);\n\n//         _ownedTokensCount[owner].decrement();\n//         _tokenOwner[tokenId] = address(0);\n\n//         emit Transfer(owner, address(0), tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(uint256 tokenId) internal {\n//         _burn(ownerOf(tokenId), tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to transfer ownership of a given token ID to another address.\n//      * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) internal {\n//         require(\n//             ownerOf(tokenId) == from,\n//             \"KIP17: transfer of token that is not own\"\n//         );\n//         require(to != address(0), \"KIP17: transfer to the zero address\");\n\n//         _clearApproval(tokenId);\n\n//         _ownedTokensCount[from].decrement();\n//         _ownedTokensCount[to].increment();\n\n//         _tokenOwner[tokenId] = to;\n\n//         emit Transfer(from, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to invoke `onKIP17Received` on a target address.\n//      * The call is not executed if the target address is not a contract.\n//      *\n//      * This function is deprecated.\n//      * @param from address representing the previous owner of the given token ID\n//      * @param to target address that will receive the tokens\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @param _data bytes optional data to send along with the call\n//      * @return bool whether the call correctly returned the expected magic value\n//      */\n//     function _checkOnKIP17Received(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory _data\n//     ) internal returns (bool) {\n//         if (!to.isContract()) {\n//             return true;\n//         }\n\n//         // Logic for compatibility with ERC721.\n//         bytes4 retval = IERC721Receiver(to).onERC721Received(\n//             msg.sender,\n//             from,\n//             tokenId,\n//             _data\n//         );\n//         if (retval == _ERC721_RECEIVED) {\n//             return true;\n//         }\n\n//         retval = IKIP17Receiver(to).onKIP17Received(\n//             msg.sender,\n//             from,\n//             tokenId,\n//             _data\n//         );\n//         return (retval == _KIP17_RECEIVED);\n//     }\n\n//     /**\n//      * @dev Private function to clear current approval of a given token ID.\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _clearApproval(uint256 tokenId) private {\n//         if (_tokenApprovals[tokenId] != address(0)) {\n//             _tokenApprovals[tokenId] = address(0);\n//         }\n//     }\n// }\n\n// contract MinterRole {\n//     using Roles for Roles.Role;\n\n//     event MinterAdded(address indexed account);\n//     event MinterRemoved(address indexed account);\n\n//     Roles.Role private _minters;\n\n//     constructor() internal {\n//         _addMinter(msg.sender);\n//     }\n\n//     modifier onlyMinter() {\n//         require(\n//             isMinter(msg.sender),\n//             \"MinterRole: caller does not have the Minter role\"\n//         );\n//         _;\n//     }\n\n//     function isMinter(address account) public view returns (bool) {\n//         return _minters.has(account);\n//     }\n\n//     function addMinter(address account) public onlyMinter {\n//         _addMinter(account);\n//     }\n\n//     function renounceMinter() public {\n//         _removeMinter(msg.sender);\n//     }\n\n//     function _addMinter(address account) internal {\n//         _minters.add(account);\n//         emit MinterAdded(account);\n//     }\n\n//     function _removeMinter(address account) internal {\n//         _minters.remove(account);\n//         emit MinterRemoved(account);\n//     }\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token Standard, optional metadata extension\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Metadata is IKIP17 {\n//     function name() external view returns (string memory);\n\n//     function symbol() external view returns (string memory);\n\n//     function tokenURI(uint256 tokenId) external view returns (string memory);\n// }\n\n// contract KIP17Metadata is KIP13, KIP17, IKIP17Metadata {\n//     // Token name\n//     string private _name;\n\n//     // Token symbol\n//     string private _symbol;\n\n//     // Optional mapping for token URIs\n//     mapping(uint256 => string) private _tokenURIs;\n\n//     /*\n//      *     bytes4(keccak256('name()')) == 0x06fdde03\n//      *     bytes4(keccak256('symbol()')) == 0x95d89b41\n//      *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n//      *\n//      *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_METADATA = 0x5b5e139f;\n\n//     /**\n//      * @dev Constructor function\n//      */\n//     constructor(string memory name, string memory symbol) public {\n//         _name = name;\n//         _symbol = symbol;\n\n//         // register the supported interfaces to conform to KIP17 via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_METADATA);\n//     }\n\n//     /**\n//      * @dev Gets the token name.\n//      * @return string representing the token name\n//      */\n//     function name() external view returns (string memory) {\n//         return _name;\n//     }\n\n//     /**\n//      * @dev Gets the token symbol.\n//      * @return string representing the token symbol\n//      */\n//     function symbol() external view returns (string memory) {\n//         return _symbol;\n//     }\n\n//     /**\n//      * @dev Returns an URI for a given token ID.\n//      * Throws if the token ID does not exist. May return an empty string.\n//      * @param tokenId uint256 ID of the token to query\n//      */\n//     function tokenURI(uint256 tokenId) external view returns (string memory) {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17Metadata: URI query for nonexistent token\"\n//         );\n//         return _tokenURIs[tokenId];\n//     }\n\n//     /**\n//      * @dev Internal function to set the token URI for a given token.\n//      * Reverts if the token ID does not exist.\n//      * @param tokenId uint256 ID of the token to set its URI\n//      * @param uri string URI to assign\n//      */\n//     function _setTokenURI(uint256 tokenId, string memory uri) internal {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17Metadata: URI set of nonexistent token\"\n//         );\n//         _tokenURIs[tokenId] = uri;\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned by the msg.sender\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         super._burn(owner, tokenId);\n\n//         // Clear metadata (if any)\n//         if (bytes(_tokenURIs[tokenId]).length != 0) {\n//             delete _tokenURIs[tokenId];\n//         }\n//     }\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token Standard, optional enumeration extension\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Enumerable is IKIP17 {\n//     function totalSupply() public view returns (uint256);\n\n//     function tokenOfOwnerByIndex(address owner, uint256 index)\n//         public\n//         view\n//         returns (uint256 tokenId);\n\n//     function tokenByIndex(uint256 index) public view returns (uint256);\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token with optional enumeration extension logic\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Enumerable is KIP13, KIP17, IKIP17Enumerable {\n//     // Mapping from owner to list of owned token IDs\n//     mapping(address => uint256[]) private _ownedTokens;\n\n//     // Mapping from token ID to index of the owner tokens list\n//     mapping(uint256 => uint256) private _ownedTokensIndex;\n\n//     // Array with all token ids, used for enumeration\n//     uint256[] private _allTokens;\n\n//     // Mapping from token id to position in the allTokens array\n//     mapping(uint256 => uint256) private _allTokensIndex;\n\n//     /*\n//      *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n//      *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n//      *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n//      *\n//      *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_ENUMERABLE = 0x780e9d63;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Enumerable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_ENUMERABLE);\n//     }\n\n//     /**\n//      * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n//      * @param owner address owning the tokens list to be accessed\n//      * @param index uint256 representing the index to be accessed of the requested tokens list\n//      * @return uint256 token ID at the given index of the tokens list owned by the requested address\n//      */\n//     function tokenOfOwnerByIndex(address owner, uint256 index)\n//         public\n//         view\n//         returns (uint256)\n//     {\n//         require(\n//             index < balanceOf(owner),\n//             \"KIP17Enumerable: owner index out of bounds\"\n//         );\n//         return _ownedTokens[owner][index];\n//     }\n\n//     /**\n//      * @dev Gets the total amount of tokens stored by the contract.\n//      * @return uint256 representing the total amount of tokens\n//      */\n//     function totalSupply() public view returns (uint256) {\n//         return _allTokens.length;\n//     }\n\n//     /**\n//      * @dev Gets the token ID at a given index of all the tokens in this contract\n//      * Reverts if the index is greater or equal to the total number of tokens.\n//      * @param index uint256 representing the index to be accessed of the tokens list\n//      * @return uint256 token ID at the given index of the tokens list\n//      */\n//     function tokenByIndex(uint256 index) public view returns (uint256) {\n//         require(\n//             index < totalSupply(),\n//             \"KIP17Enumerable: global index out of bounds\"\n//         );\n//         return _allTokens[index];\n//     }\n\n//     /**\n//      * @dev Internal function to transfer ownership of a given token ID to another address.\n//      * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) internal {\n//         super._transferFrom(from, to, tokenId);\n\n//         _removeTokenFromOwnerEnumeration(from, tokenId);\n\n//         _addTokenToOwnerEnumeration(to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to mint a new token.\n//      * Reverts if the given token ID already exists.\n//      * @param to address the beneficiary that will own the minted token\n//      * @param tokenId uint256 ID of the token to be minted\n//      */\n//     function _mint(address to, uint256 tokenId) internal {\n//         super._mint(to, tokenId);\n\n//         _addTokenToOwnerEnumeration(to, tokenId);\n\n//         _addTokenToAllTokensEnumeration(tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         super._burn(owner, tokenId);\n\n//         _removeTokenFromOwnerEnumeration(owner, tokenId);\n//         // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n//         _ownedTokensIndex[tokenId] = 0;\n\n//         _removeTokenFromAllTokensEnumeration(tokenId);\n//     }\n\n//     /**\n//      * @dev Gets the list of token IDs of the requested owner.\n//      * @param owner address owning the tokens\n//      * @return uint256[] List of token IDs owned by the requested address\n//      */\n//     function _tokensOfOwner(address owner)\n//         internal\n//         view\n//         returns (uint256[] storage)\n//     {\n//         return _ownedTokens[owner];\n//     }\n\n//     /**\n//      * @dev Private function to add a token to this extension's ownership-tracking data structures.\n//      * @param to address representing the new owner of the given token ID\n//      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n//      */\n//     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n//         _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n//         _ownedTokens[to].push(tokenId);\n//     }\n\n//     /**\n//      * @dev Private function to add a token to this extension's token tracking data structures.\n//      * @param tokenId uint256 ID of the token to be added to the tokens list\n//      */\n//     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n//         _allTokensIndex[tokenId] = _allTokens.length;\n//         _allTokens.push(tokenId);\n//     }\n\n//     /**\n//      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n//      * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n//      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n//      * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n//      * @param from address representing the previous owner of the given token ID\n//      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n//      */\n//     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n//         private\n//     {\n//         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n//         // then delete the last slot (swap and pop).\n\n//         uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n//         uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n//         // When the token to delete is the last token, the swap operation is unnecessary\n//         if (tokenIndex != lastTokenIndex) {\n//             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n//             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n//             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n//         }\n\n//         // This also deletes the contents at the last position of the array\n//         _ownedTokens[from].length--;\n\n//         // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n//         // lastTokenId, or just over the end of the array if the token was the last one).\n//     }\n\n//     /**\n//      * @dev Private function to remove a token from this extension's token tracking data structures.\n//      * This has O(1) time complexity, but alters the order of the _allTokens array.\n//      * @param tokenId uint256 ID of the token to be removed from the tokens list\n//      */\n//     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n//         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n//         // then delete the last slot (swap and pop).\n\n//         uint256 lastTokenIndex = _allTokens.length.sub(1);\n//         uint256 tokenIndex = _allTokensIndex[tokenId];\n\n//         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n//         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n//         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n//         uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n//         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n//         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n//         // This also deletes the contents at the last position of the array\n//         _allTokens.length--;\n//         _allTokensIndex[tokenId] = 0;\n//     }\n// }\n\n// /**\n//  * @title Full KIP-17 Token\n//  * This implementation includes all the required and some optional functionality of the KIP-17 standard\n//  * Moreover, it includes approve all functionality using operator terminology\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Full is KIP17, KIP17Enumerable, KIP17Metadata {\n//     constructor(string memory name, string memory symbol)\n//         public\n//         KIP17Metadata(name, symbol)\n//     {\n//         // solhint-disable-previous-line no-empty-blocks\n//     }\n// }\n\n// /**\n//  * @title KIP17MetadataMintable\n//  * @dev KIP17 minting logic with metadata.\n//  */\n// contract KIP17MetadataMintable is KIP13, KIP17, KIP17Metadata, MinterRole {\n//     /*\n//      *     bytes4(keccak256('mintWithTokenURI(address,uint256,string)')) == 0x50bb4e7f\n//      *     bytes4(keccak256('isMinter(address)')) == 0xaa271e1a\n//      *     bytes4(keccak256('addMinter(address)')) == 0x983b2d56\n//      *     bytes4(keccak256('renounceMinter()')) == 0x98650275\n//      *\n//      *     => 0x50bb4e7f ^ 0xaa271e1a ^ 0x983b2d56 ^ 0x98650275 == 0xfac27f46\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_METADATA_MINTABLE = 0xfac27f46;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Mintable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_METADATA_MINTABLE);\n//     }\n\n//     /**\n//      * @dev Function to mint tokens.\n//      * @param to The address that will receive the minted tokens.\n//      * @param tokenId The token id to mint.\n//      * @param tokenURI The token URI of the minted token.\n//      * @return A boolean that indicates if the operation was successful.\n//      */\n//     function mintWithTokenURI(\n//         address to,\n//         uint256 tokenId,\n//         string memory tokenURI\n//     ) public onlyMinter returns (bool) {\n//         _mint(to, tokenId);\n//         _setTokenURI(tokenId, tokenURI);\n//         return true;\n//     }\n// }\n\n// /**\n//  * @title KIP17Mintable\n//  * @dev KIP17 minting logic.\n//  */\n// contract KIP17Mintable is KIP17, MinterRole {\n//     /*\n//      *     bytes4(keccak256('isMinter(address)')) == 0xaa271e1a\n//      *     bytes4(keccak256('addMinter(address)')) == 0x983b2d56\n//      *     bytes4(keccak256('renounceMinter()')) == 0x98650275\n//      *     bytes4(keccak256('mint(address,uint256)')) == 0x40c10f19\n//      *\n//      *     => 0xaa271e1a ^ 0x983b2d56 ^ 0x98650275 ^ 0x40c10f19 == 0xeab83e20\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_MINTABLE = 0xeab83e20;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Mintable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_MINTABLE);\n//     }\n\n//     /**\n//      * @dev Function to mint tokens.\n//      * @param to The address that will receive the minted tokens.\n//      * @param tokenId The token id to mint.\n//      * @return A boolean that indicates if the operation was successful.\n//      */\n//     function mint(address to, uint256 tokenId)\n//         public\n//         onlyMinter\n//         returns (bool)\n//     {\n//         _mint(to, tokenId);\n//         return true;\n//     }\n// }\n\n// /**\n//  * @title KIP17 Burnable Token\n//  * @dev KIP17 Token that can be irreversibly burned (destroyed).\n//  * See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Burnable is KIP13, KIP17 {\n//     /*\n//      *     bytes4(keccak256('burn(uint256)')) == 0x42966c68\n//      *\n//      *     => 0x42966c68 == 0x42966c68\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_BURNABLE = 0x42966c68;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Burnable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_BURNABLE);\n//     }\n\n//     /**\n//      * @dev Burns a specific KIP17 token.\n//      * @param tokenId uint256 id of the KIP17 token to be burned.\n//      */\n//     function burn(uint256 tokenId) public {\n//         //solhint-disable-next-line max-line-length\n//         require(\n//             _isApprovedOrOwner(msg.sender, tokenId),\n//             \"KIP17Burnable: caller is not owner nor approved\"\n//         );\n//         _burn(tokenId);\n//     }\n// }\n\n// /**\n//  * @dev Contract module which allows children to implement an emergency stop\n//  * mechanism that can be triggered by an authorized account.\n//  *\n//  * This module is used through inheritance. It will make available the\n//  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n//  * the functions of your contract. Note that they will not be pausable by\n//  * simply including this module, only once the modifiers are put in place.\n//  */\n// contract Pausable is PauserRole {\n//     /**\n//      * @dev Emitted when the pause is triggered by a pauser (`account`).\n//      */\n//     event Paused(address account);\n\n//     /**\n//      * @dev Emitted when the pause is lifted by a pauser (`account`).\n//      */\n//     event Unpaused(address account);\n\n//     bool private _paused;\n\n//     /**\n//      * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n//      * to the deployer.\n//      */\n//     constructor() internal {\n//         _paused = false;\n//     }\n\n//     /**\n//      * @dev Returns true if the contract is paused, and false otherwise.\n//      */\n//     function paused() public view returns (bool) {\n//         return _paused;\n//     }\n\n//     /**\n//      * @dev Modifier to make a function callable only when the contract is not paused.\n//      */\n//     modifier whenNotPaused() {\n//         require(!_paused, \"Pausable: paused\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Modifier to make a function callable only when the contract is paused.\n//      */\n//     modifier whenPaused() {\n//         require(_paused, \"Pausable: not paused\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Called by a pauser to pause, triggers stopped state.\n//      */\n//     function pause() public onlyPauser whenNotPaused {\n//         _paused = true;\n//         emit Paused(msg.sender);\n//     }\n\n//     /**\n//      * @dev Called by a pauser to unpause, returns to normal state.\n//      */\n//     function unpause() public onlyPauser whenPaused {\n//         _paused = false;\n//         emit Unpaused(msg.sender);\n//     }\n// }\n\n// /**\n//  * @title KIP17 Non-Fungible Pausable token\n//  * @dev KIP17 modified with pausable transfers.\n//  */\n// contract KIP17Pausable is KIP13, KIP17, Pausable {\n//     /*\n//      *     bytes4(keccak256('paused()')) == 0x5c975abb\n//      *     bytes4(keccak256('pause()')) == 0x8456cb59\n//      *     bytes4(keccak256('unpause()')) == 0x3f4ba83a\n//      *     bytes4(keccak256('isPauser(address)')) == 0x46fbf68e\n//      *     bytes4(keccak256('addPauser(address)')) == 0x82dc1ec4\n//      *     bytes4(keccak256('renouncePauser()')) == 0x6ef8d66d\n//      *\n//      *     => 0x5c975abb ^ 0x8456cb59 ^ 0x3f4ba83a ^ 0x46fbf68e ^ 0x82dc1ec4 ^ 0x6ef8d66d == 0x4d5507ff\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_PAUSABLE = 0x4d5507ff;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Pausable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_PAUSABLE);\n//     }\n\n//     function approve(address to, uint256 tokenId) public whenNotPaused {\n//         super.approve(to, tokenId);\n//     }\n\n//     function setApprovalForAll(address to, bool approved) public whenNotPaused {\n//         super.setApprovalForAll(to, approved);\n//     }\n\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public whenNotPaused {\n//         super.transferFrom(from, to, tokenId);\n//     }\n// }\n\n// // contract KIP17Token is\n// contract KIP17TokenTest is\n//     KIP17Full,\n//     KIP17Mintable,\n//     KIP17MetadataMintable,\n//     KIP17Burnable,\n//     KIP17Pausable,\n//     Ownable\n// {\n//     constructor(string memory name, string memory symbol)\n//         public\n//         KIP17Full(name, symbol)\n//     {}\n// }\n"
    },
    "contracts/Tokens/vper/vper.sol": {
      "content": "// pragma solidity ^0.8.0;\n\n// // address : 0xc69ad53109892f1d5b0decf1917eabd0888e5082\n// // network : cypress\n"
    },
    "contracts/Tokens/wklay/wklay.sol": {
      "content": "// // Copied from Klaytn Canonical WKLAY repository \n// // https://github.com/klaytn/canonical-wklay/blob/main/contracts/WKLAY.sol  \n// // Copyright (C) 2022 The Klaytn Authors\n// // Copyright (C) 2015, 2016, 2017 Dapphub\n\n// // This program is free software: you can redistribute it and/or modify\n// // it under the terms of the GNU General Public License as published by\n// // the Free Software Foundation, either version 3 of the License, or\n// // (at your option) any later version.\n\n// // This program is distributed in the hope that it will be useful,\n// // but WITHOUT ANY WARRANTY; without even the implied warranty of\n// // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// // GNU General Public License for more details.\n\n// // You should have received a copy of the GNU General Public License\n// // along with this program.  If not, see <http://www.gnu.org/licenses/>.\n// /**\n\n// @dev\n// // cypress : 0x19Aac5f612f524B754CA7e7c41cbFa2E981A4432\n// // baobab : 0x043c471bEe060e00A56CcD02c0Ca286808a5A436\n//  */\n// pragma solidity >=0.5.9;\n\n// contract WKLAY {\n//     string public name = \"Wrapped Klay\";\n//     string public symbol = \"WKLAY\";\n//     uint8 public decimals = 18;\n\n//     event Approval(address indexed src, address indexed guy, uint256 wad);\n//     event Transfer(address indexed src, address indexed dst, uint256 wad);\n//     event Deposit(address indexed dst, uint256 wad);\n//     event Withdrawal(address indexed src, uint256 wad);\n\n//     mapping(address => uint256) public balanceOf;\n//     mapping(address => mapping(address => uint256)) public allowance;\n\n//     function() external payable {\n//         deposit();\n//     }\n\n//     function deposit() public payable {\n//         balanceOf[msg.sender] += msg.value;\n//         emit Deposit(msg.sender, msg.value);\n//     }\n\n//     function withdraw(uint256 wad) public {\n//         require(balanceOf[msg.sender] >= wad);\n//         balanceOf[msg.sender] -= wad;\n//         msg.sender.transfer(wad);\n//         emit Withdrawal(msg.sender, wad);\n//     }\n\n//     function totalSupply() public view returns (uint256) {\n//         return address(this).balance;\n//     }\n\n//     function approve(address guy, uint256 wad) public returns (bool) {\n//         allowance[msg.sender][guy] = wad;\n//         emit Approval(msg.sender, guy, wad);\n//         return true;\n//     }\n\n//     function transfer(address dst, uint256 wad) public returns (bool) {\n//         return transferFrom(msg.sender, dst, wad);\n//     }\n\n//     function transferFrom(\n//         address src,\n//         address dst,\n//         uint256 wad\n//     ) public returns (bool) {\n//         require(balanceOf[src] >= wad);\n\n//         if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {\n//             require(allowance[src][msg.sender] >= wad);\n//             allowance[src][msg.sender] -= wad;\n//         }\n\n//         balanceOf[src] -= wad;\n//         balanceOf[dst] += wad;\n\n//         emit Transfer(src, dst, wad);\n\n//         return true;\n//     }\n// }"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}