{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Channel_iN/facets/AdminFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IP2} from \"../interfaces/IP2.sol\";\nimport {IP2_Admin} from \"../interfaces/IP2_Admin.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\n\ncontract AdminFacet is Modifiers {\n    /**@dev P0 Admin functions\n     */\n    function admin_p0_setStates(\n        uint24 _maxProb,\n        uint _addProbFee,\n        uint16 _addProbExp,\n        bool _isVRF\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_states.maxProb = _maxProb;\n        s.p0_states.addProbFee = _addProbFee;\n        s.p0_states.addProbExp = _addProbExp;\n        s.p0_states.isVRF = _isVRF;\n    }\n\n    function admin_p0_setGradeInfos(\n        uint8 _gradeIndex,\n        bool _isOpen,\n        uint _mixFee,\n        uint24 _initBaseProb,\n        uint16 _mixExp,\n        uint24 _failedAddProbMin,\n        uint24 _failedAddProbMax\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_gradeInfos[_gradeIndex].isOpen = _isOpen;\n        s.p0_gradeInfos[_gradeIndex].mixFee = _mixFee;\n        s.p0_gradeInfos[_gradeIndex].initBaseProb = _initBaseProb;\n        s.p0_gradeInfos[_gradeIndex].mixExp = _mixExp;\n        s.p0_gradeInfos[_gradeIndex].failedAddProbMin = _failedAddProbMin;\n        s.p0_gradeInfos[_gradeIndex].failedAddProbMax = _failedAddProbMax;\n    }\n\n    function admin_p0_setPerFriendsProb(\n        uint _grade,\n        string memory _pfGrade,\n        uint24 _gradeProb\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_perFriendsProbs[_grade].pfGrade = _pfGrade;\n        s.p0_perFriendsProbs[_grade].gradeProb = uint24(_gradeProb);\n    }\n\n    function admin_p0_getStates()\n        external\n        view\n        returns (uint24, uint, uint16, bool)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_states.maxProb,\n            s.p0_states.addProbFee,\n            s.p0_states.addProbExp,\n            s.p0_states.isVRF\n        );\n    }\n\n    function admin_p0_getGradeInfos(\n        uint8 _gradeIndex\n    ) external view returns (bool, uint, uint24, uint16, uint24, uint24) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_gradeInfos[_gradeIndex].isOpen,\n            s.p0_gradeInfos[_gradeIndex].mixFee,\n            s.p0_gradeInfos[_gradeIndex].initBaseProb,\n            s.p0_gradeInfos[_gradeIndex].mixExp,\n            s.p0_gradeInfos[_gradeIndex].failedAddProbMin,\n            s.p0_gradeInfos[_gradeIndex].failedAddProbMax\n        );\n    }\n\n    function admin_p0_getPerFriendsProb(\n        uint _grade\n    ) external view returns (string memory, uint24) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_perFriendsProbs[_grade].pfGrade,\n            s.p0_perFriendsProbs[_grade].gradeProb\n        );\n    }\n\n    function admin_p0_setMetaData(\n        uint _pfId,\n        uint8 _grade,\n        string memory _seedHash\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.pfMetaURI[_pfId] = _seedHash;\n        s.p0_mergePfGrades[_grade].setMatadataId = _pfId;\n\n        IDB(s.contracts[\"db\"]).adminSetMetaData(_pfId, _grade, _seedHash);\n    }\n\n    function admin_p0_setMergeGradesInfo(\n        uint8 _grade,\n        string memory _gradeName,\n        uint _mergeFee,\n        uint _mergeUseItemAmount,\n        uint _latestId,\n        bool _isOpen\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_mergePfGrades[_grade].grade = _grade;\n        s.p0_mergePfGrades[_grade].gradeName = _gradeName;\n        s.p0_mergePfGrades[_grade].mergeFee = _mergeFee;\n        s.p0_mergePfGrades[_grade].mergeUseItemAmount = _mergeUseItemAmount;\n        s.p0_mergePfGrades[_grade].latestId = _latestId;\n        s.p0_mergePfGrades[_grade].isOpen = _isOpen;\n    }\n\n    function admin_p0_getMetadataMargin(\n        uint8 _grade\n    ) external view returns (uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_mergePfGrades[_grade].latestId,\n            s.p0_mergePfGrades[_grade].setMatadataId,\n            s.p0_mergePfGrades[_grade].setMatadataId -\n                s.p0_mergePfGrades[_grade].latestId\n        );\n    }\n\n    /**@dev P2 Admin functions\n     */\n    function admin_P2_layer_setting(\n        uint _layerNumber,\n        uint _fromP2PerPercent,\n        uint _fromP2UsdtPercent,\n        uint _dailyReward_percent,\n        uint _add_dailyReward_Percent,\n        bool _isOpen\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        IP2_Admin(s.contracts[\"p2\"])._layer_setting(\n            _layerNumber,\n            _fromP2PerPercent,\n            _fromP2UsdtPercent,\n            _dailyReward_percent,\n            _add_dailyReward_Percent,\n            _isOpen\n        );\n    }\n\n    function admin_P2_blockUser(\n        address _user,\n        bool _isBlock,\n        string memory _why\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        IP2_Admin(s.contracts[\"p2\"]).diamond_P2_BlockUser(\n            _user,\n            _isBlock,\n            _why\n        );\n    }\n\n    function admin_P2_setMaxLimit(uint _maxLimit) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        IP2_Admin(s.contracts[\"p2\"]).diamond_P2_setMaxLimit(_maxLimit);\n    }\n\n    /**@dev DistriBute Admin functions\n     */\n    function admin_distribute_setStates(\n        uint24 _p1Ratio,\n        uint24 _p2PerRatio,\n        uint24 _p2UsdtRatio,\n        uint24 _burnRatio,\n        uint24 _teamUsdtRatio\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.distribute_states.p1Ratio = _p1Ratio;\n        s.distribute_states.p2PerRatio = _p2PerRatio;\n        s.distribute_states.p2UsdtRatio = _p2UsdtRatio;\n        s.distribute_states.burnRatio = _burnRatio;\n        s.distribute_states.teamUsdtRatio = _teamUsdtRatio;\n    }\n\n    function admin_distribute_getStates()\n        external\n        view\n        returns (uint24, uint24, uint24, uint24, uint24, uint, uint)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.distribute_states.p1Ratio,\n            s.distribute_states.p2PerRatio,\n            s.distribute_states.p2UsdtRatio,\n            s.distribute_states.burnRatio,\n            s.distribute_states.teamUsdtRatio,\n            s.distribute_states.agencyIncomeRatio,\n            s.distribute_states.influencerIncomeRatio\n        );\n    }\n\n    function admin_distribute_setAuto(bool _isAuto) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.isAutoDistribute = _isAuto;\n    }\n\n    function admin_distribute_ksSwapLimit(uint _limit) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.ksSwapLimit = _limit;\n    }\n\n    function admin_distribute_getBeforAmounts()\n        external\n        view\n        returns (uint, uint, uint)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.distribute_states.beforeP2Usdt,\n            s.distribute_states.beforeP2Per,\n            s.distribute_states.beforeTeamUsdt\n        );\n    }\n\n    /**@dev aien mint variables\n     */\n\n    function admin_setAienMintFee(uint _mintFee) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.aienMintFee = _mintFee;\n    }\n\n    function admin_getAienMintFee() external view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.aienMintFee;\n    }\n\n    function admin_Test(uint _value) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.distribute_states.agencyIncomeRatio = _value;\n    }\n\n    function admin_testCalling() external view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.aienMintFee;\n    }\n}\n"
    },
    "contracts/Channel_iN/interfaces/IDB.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// legacy db contract interface\ninterface IDB {\n    struct pf {\n        uint id;\n        uint class;\n        bool isAien;\n        uint usedAienId;\n    }\n\n    struct pfGrade {\n        uint normal;\n        uint uncommon;\n        uint rare;\n        uint unique;\n        uint legendary;\n        uint myth;\n        uint ancient;\n    }\n\n    struct aien {\n        uint id;\n        // 강화 횟수\n        uint mixCount;\n        //\n        uint p2Level;\n        // 토탈 경험치\n        uint totalExp;\n        // 미션 및, 인플루언서 활동 관련 경험치\n        uint influExp;\n        // 기본 확률\n        uint baseProb;\n        // 토탈 확률\n        uint totalProb;\n        // is PF\n        uint isPFid;\n        // 추가확률\n        uint addProb;\n    }\n\n    struct User {\n        // DB > idx\n        uint userId;\n        // token itme ID\n        uint itemId;\n        address incomeAddr;\n        uint feeBalance;\n        bool isAble;\n        uint mintCount;\n        uint useLevelupCount;\n        uint useMergeCount;\n        // uint ownerIncomePercent;\n        // uint userIncomPercent;\n        //레퍼럴로 얻은 수익\n        uint referralIncome;\n        address agency;\n        uint agencyIncome;\n    }\n\n    function AIENS(uint _key) external view returns (aien memory);\n\n    function PFS(uint _key) external view returns (pf memory);\n\n    function getAien(uint _id) external view;\n\n    function getPF(uint _id) external view;\n\n    function getPfGrade(uint _id) external view returns (uint);\n\n    function setAien(uint _id) external;\n\n    function usePFimg(uint _aienId, uint _pfId) external;\n\n    function setAienAll(\n        uint _id,\n        uint _mixCount,\n        uint _p2Level,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _totalProb,\n        uint _isPFid,\n        uint _addProb\n    ) external;\n\n    function getContractAddr(\n        string memory _name\n    ) external view returns (address);\n\n    function burnValue(uint _burnAmount) external;\n\n    function setAienGradeInfo(uint _toGrade) external;\n\n    function subPfGrades(uint _pfId) external;\n\n    function setLevelUpStatus(uint _toGrade) external;\n\n    function _failedAienSet(\n        uint _id,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _addProb\n    ) external;\n\n    function _successAienSet(\n        uint _id,\n        uint _p2Level,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _addProb\n    ) external;\n\n    function _mergeCalcul(\n        uint _itemId\n    ) external view returns (uint, address, uint, address, uint, uint);\n\n    function _mergeCalcul2(\n        uint _itemId\n    ) external view returns (uint, address, uint, address, uint, uint);\n\n    function _influencerMerge(\n        address _to,\n        uint _itemId,\n        uint _referralIncome\n    ) external returns (uint, string memory);\n\n    function _levelUpCalcul(\n        uint _itemId,\n        uint _fee\n    ) external returns (address, address, uint, uint);\n\n    function _levelUpSucess(uint _id, uint _p2Level) external;\n\n    function _levelUpFailed(uint _id, uint _addProb) external;\n\n    function _mergeCount(\n        address _agency,\n        uint _agencyFee,\n        address _influencer,\n        uint _influencerFee\n    ) external;\n\n    function usePFPower(uint _id, uint _usePower) external;\n\n    function addProbFee() external view returns (uint);\n\n    function PfGrades() external view returns (pfGrade memory);\n\n    function getAienGradeInfo() external view returns (uint[] memory);\n\n    function basicMergeAmount() external view returns (uint);\n\n    function influencerMergeAmount() external view returns (uint);\n\n    function _getMedataMargin() external view returns (uint, uint, uint);\n\n    function getAienLevel(uint _aienId) external view returns (uint);\n\n    function setPerprojectWallet(address _addr) external;\n\n    function setAgencyAddr(address _influencer, address _agency) external;\n\n    function setAgencyIncomePercent(uint _agencyIncomePercent) external;\n\n    function adminSetMergeAmount(\n        uint _influencerMergeAmount,\n        uint _basicMergeAmount,\n        uint _agencyIncomePercent,\n        uint _ownerIncomePercent\n    ) external;\n\n    function getUserFromItem(uint _itemId) external view returns (User memory);\n\n    function adminSetMetaData(\n        uint _pfId,\n        uint8 _grade,\n        string memory _seedHash\n    ) external;\n}\n"
    },
    "contracts/Channel_iN/interfaces/IP2_Admin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ninterface IP2_Admin {\n    // layer Settings\n    function _layer_setting(\n        uint _layerNumber,\n        uint _fromP2PerPercent,\n        uint _fromP2UsdtPercent,\n        uint _dailyReward_percent,\n        uint _add_dailyReward_Percent,\n        bool _isOpen\n    ) external;\n\n    function diamond_P2_BlockUser(\n        address _user,\n        bool _isBlock,\n        string memory _why\n    ) external;\n\n    function diamond_P2_setMaxLimit(uint _maxLimit) external;\n\n    \n\n\n}\n"
    },
    "contracts/Channel_iN/interfaces/IP2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ninterface IP2 {\n    struct User {\n        bool isBlockUser;\n        uint perRewarded;\n        uint usdtRewarded;\n        EnumerableSet.UintSet tokenIds;\n    }\n\n    struct Aien {\n        address staker;\n        uint level;\n        // requires value\n        uint rewardPer;\n        uint rewardUsdt;\n        uint rewardUsdtDebt;\n        uint rewardPerDebt;\n        ////////////////////\n        uint per_received;\n        uint usdt_received;\n    }\n\n    struct Balances {\n        // 로직상 계산에 필요한 밸런스 변수 (실제와 다를 수 있음)\n        uint perBalance;\n        uint usdtBalance;\n        // 레이어가 오픈 되지 않은 상태에서\n        // 레이어가 오픈되면 해당 레이어에 저장된 리워드를 데일리 리워드로 추가 분배하기 위한 변수\n        uint savedPerBalance;\n        uint savedUsdtBalance;\n        // 현재 savedUsdt, savedPer를 통해 나온 데일리 리워드\n        uint add_dailyUSDT;\n        uint add_dailyPER;\n        // 보안상 문제가 생겨\n        // 예상보다 많은 withdraw를 요청하게 되는 경우\n        // 지금까지 쌓인 레이어별 토탈 밸런스와\n        // 지금까지 쌓인 레이어별 출금 밸런스를 비교하여\n        // 출금 가능한지 체크하는 변수\n        uint total_checkWithdrawPER;\n        uint withdrawal_checkWithdrawPER;\n        uint total_checkWithdrawUSDT;\n        uint withdrawal_checkWithdrawUSDT;\n    }\n\n    struct Layer {\n        Balances balances;\n        // P2에서 해당 레이어에 토큰 배정 받을때 리워드 퍼센트\n        uint rewardUsdtPercent;\n        uint rewardPerPercent;\n        // 유저에게 하루에 분배하는 리워드 퍼센트\n        uint dailyReward_Percent;\n        // 계산에 필요\n        uint rewardPer;\n        uint rewardUsdt;\n        // 미오픈시 저장한 리워드를 데일리 리워드로 추가 분배하기 위한 퍼센트변수\n        uint add_dailyReward_Percent;\n        uint lastRewardBlock;\n        uint dailyRewardUpdateBlock;\n        uint totalStakedAien;\n        bool isOpen;\n    }\n\n    struct AienLoadData {\n        //aien정보\n        uint _aienId;\n        uint _aienLevel;\n        // 출금 토탈\n        uint _aien_per_received;\n        uint _aien_usdt_received;\n        //출금 가능\n        uint usdt_withdrawable;\n        uint per_withdrawable;\n        // block당 리워드\n        uint block_reward_per;\n        uint block_reward_usdt;\n    }\n\n    struct LayerLoadData {\n        bool isOpen;\n        uint _layerNumber;\n        uint _24h_reward_per;\n        uint _24h_reward_usdt;\n        uint totalStakedAien;\n    }\n    struct UserLoadData {\n        uint _usdtRewarded;\n        uint _perRewarded;\n        bool _isBlockUser;\n    }\n\n    function aiens(uint _id) external view returns (Aien memory);\n\n    function diamond_P2_deposit(address _sender, uint _aienId) external;\n\n    function diamond_P2_withdraw(address _sender, uint _aienId) external;\n\n    function diamond_P2_harvest(address _sender, uint _aienId) external;\n\n    function diamond_P2_getUserInfo(\n        address _sender\n    )\n        external\n        view\n        returns (\n            UserLoadData memory,\n            AienLoadData[] memory,\n            LayerLoadData[] memory\n        );\n\n    function diamond_P2_getLayerData(\n        uint _number\n    ) external view returns (uint, uint, uint);\n\n    function addPerUsdtDistribution(uint _usdt, uint _per) external;\n\n    function P2_usdtBalance() external view returns (uint);\n\n    function P2_perBalance() external view returns (uint);\n\n    function MAX_STAKING_LIMIT() external view returns (uint);\n\n    function layers(uint _number) external view returns (Layer memory);\n\n    function pendingReward(\n        uint _aienId,\n        uint _layerNumber,\n        uint _withdrawBlock\n    ) external view returns (uint, uint);\n}\n"
    },
    "contracts/shared/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/shared/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {LibDiamond} from \"./LibDiamond.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {LibMeta} from \"./LibMeta.sol\";\n// using EnumerableSet for EnumerableSet.AddressSet;\n// i-Tez Structs\n//- P0 struct\nstruct P0_State {\n    uint24 maxProb;\n    // 퍼프렌즈를 이용한 PF POWER 변환시 개당 수수료\n    uint addProbFee;\n    // 퍼프렌즈를 이용한 PF POWER 변환시 획득 경험치\n    uint16 addProbExp;\n    // bool\n    bool isVRF;\n}\nstruct P0_PerFriendsProb {\n    string pfGrade;\n    uint24 gradeProb;\n}\n\nstruct P0_GradeInfo {\n    // 다음 level이 열렸는지 확인\n    bool isOpen;\n    // level별 mix fee\n    uint mixFee;\n    // 레벨업 성공시 level별 초기 base 확률\n    uint24 initBaseProb;\n    // level별 추가 확률 밸런스 조정값\n    uint16 mixExp;\n    // level별 합성 실패시 추가 확률 min,max\n    uint24 failedAddProbMin;\n    // 1000 = 0.1%, 10000 = 0.01%\n    uint24 failedAddProbMax;\n}\n\nstruct P0_MergePfGrade {\n    uint8 grade;\n    string gradeName;\n    uint mergeFee;\n    uint mergeUseItemAmount;\n    uint latestId;\n    uint setMatadataId;\n    bool isOpen;\n}\nstruct P0_MergeState {\n    uint agencyIncomePercent;\n    uint influencerIncomePercent;\n    // 1e5 = 100%\n    // uint maxIncomePercent;\n}\n// //- Distribute struct\nstruct Distribute_State {\n    uint beforeP2Usdt;\n    uint beforeP2Per;\n    uint beforeTeamUsdt;\n    // distribute ratios\n    uint24 p1Ratio;\n    uint24 p2PerRatio;\n    uint24 p2UsdtRatio;\n    uint24 burnRatio;\n    uint24 teamUsdtRatio;\n    //1e5 = 100%\n    uint agencyIncomeRatio;\n    uint influencerIncomeRatio;\n}\n// DB > Filtered User Struct\nstruct User {\n    // DB > idx\n    uint userId;\n    // token itme ID\n    uint itemId;\n    address incomeAddr;\n    uint feeBalance;\n    bool isAble;\n    uint mintCount;\n    uint useLevelupCount;\n    uint useMergeCount;\n    //레퍼럴로 얻은 수익\n    uint referralIncome;\n    address agency;\n    uint agencyIncome;\n}\n\n// P0 End\nstruct AppStorage {\n    // address constants\n    mapping(string => address) contracts;\n    // i-Tez/////////////////////////////\n    // P0 ///////////////////////////////\n    P0_State p0_states;\n    P0_GradeInfo[11] p0_gradeInfos;\n    mapping(uint => P0_PerFriendsProb) p0_perFriendsProbs;\n    /////////////////////////////////////\n    // Distribute ///////////////////////\n    Distribute_State distribute_states;\n    uint aienMintFee;\n    // Distribute\n    uint ksSwapLimit;\n    bool isAutoDistribute;\n    // P0 - Item Merge Grade Infos\n    mapping(uint8 => P0_MergePfGrade) p0_mergePfGrades;\n    mapping(uint => string) pfMetaURI;\n    P0_MergeState p0_mergeState;\n}\n\nlibrary LibAppStorage {\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\n        assembly {\n            ds.slot := 0\n        }\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x >= 0 ? x : -x);\n    }\n}\n\n/**\n@dev global modifier\n */\ncontract Modifiers {\n    modifier onlyDev() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n\n    // modifier checkRole(uint16 _role) {\n    //     AppStorage storage s = LibAppStorage.diamondStorage();\n    //     require(\n    //         s.roles[_role].accounts.contains(LibMeta.msgSender()),\n    //         \"AccessControl: sender does not have required role\"\n    //     );\n    //     _;\n    // }\n}\n"
    },
    "contracts/shared/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/shared/libraries/LibMeta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nlibrary LibMeta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"\n            )\n        );\n\n    function domainSeparator(\n        string memory name,\n        string memory version\n    ) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}