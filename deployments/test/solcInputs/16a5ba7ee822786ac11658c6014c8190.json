{
  "language": "Solidity",
  "sources": {
    "contracts/Channel_iN/facets/P2Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage, P2_Layer} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {LibP2} from \"../libraries/LibP2.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport \"../../shared/libraries/LibEnumerableSet.sol\";\n\ncontract P2Facet {\n    event P2_Staking_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed layer\n    );\n    event P2_UnStaking_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed layer\n    );\n    event P2_Harvest_Event(\n        address indexed to,\n        uint indexed aienId,\n        uint indexed layer,\n        uint baseReward,\n        uint plusReward\n    );\n\n    function P2_staking(uint _aienId) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // address msgsender = LibMeta.msgSender();\n        uint _aienLevel = P2_getAienLevel(_aienId);\n        LibP2.diamond_P2_deposit(msg.sender, _aienId);\n        IERC721(s.contracts[\"aien\"]).safeTransferFrom(\n            msg.sender,\n            s.contracts[\"p2balance\"],\n            _aienId\n        );\n\n        emit P2_Staking_Event(msg.sender, _aienId, _aienLevel);\n    }\n\n    function P2_unStaking(uint _aienId) external {\n        address msgsender = LibMeta.msgSender();\n\n        uint _aienLevel = P2_getAienLevel(_aienId);\n        (uint base, uint plus) = LibP2.__P2_Pending_Reward(\n            _aienId,\n            _aienLevel\n        );\n\n        emit P2_UnStaking_Event(msgsender, _aienId, _aienLevel);\n        emit P2_Harvest_Event(msgsender, _aienId, _aienLevel, base, plus);\n\n        LibP2.diamond_P2_withdraw(msgsender, _aienId);\n    }\n\n    function P2_harvest(uint _aienId) external {\n        address msgsender = LibMeta.msgSender();\n        uint _aienLevel = P2_getAienLevel(_aienId);\n        (uint base, uint plus) = LibP2.__P2_Pending_Reward(\n            _aienId,\n            _aienLevel\n        );\n        emit P2_Harvest_Event(msgsender, _aienId, _aienLevel, base, plus);\n        LibP2.diamond_P2_harvest(msgsender, _aienId);\n    }\n\n    function P2_getUserInfo()\n        external\n        view\n        returns (\n            LibP2.UserLoadData memory,\n            LibP2.AienLoadData[] memory,\n            LibP2.LayerLoadData[] memory\n        )\n    {\n        address msgsender = LibMeta.msgSender();\n\n        (\n            LibP2.UserLoadData memory userData,\n            LibP2.AienLoadData[] memory aienData,\n            LibP2.LayerLoadData[] memory layerData\n        ) = LibP2.diamond_P2_getUserInfo(msgsender);\n        return (userData, aienData, layerData);\n    }\n\n    function P2_getLayerData(\n        uint _number\n    ) public view returns (uint, uint, uint) {\n        \n        return LibP2.diamond_p2_getLayerData(_number);\n    }\n\n    function P2_getAienLevel(uint _aienId) public view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return IDB(s.contracts[\"db\"]).getAienLevel(_aienId);\n    }\n\n    function P2_baseBalance() public view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.P2_baseBalance;\n    }\n\n    function P2_plusBalance() public view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.P2_plusBalance;\n    }\n\n    function P2_maxStakingLimit() public view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.P2_MAX_STAKING_LIMIT;\n    }\n\n    function P2_layers(uint _number) public view returns (P2_Layer memory) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.p2_layers[_number];\n    //     return IP2(s.contracts[\"p2\"]).layers(_number);\n    }\n}\n"
    },
    "contracts/Channel_iN/interfaces/IDB.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// legacy db contract interface\ninterface IDB {\n    struct pf {\n        uint id;\n        uint class;\n        bool isAien;\n        uint usedAienId;\n    }\n\n    struct pfGrade {\n        uint normal;\n        uint uncommon;\n        uint rare;\n        uint unique;\n        uint legendary;\n        uint myth;\n        uint ancient;\n    }\n\n    struct aien {\n        uint id;\n        // 강화 횟수\n        uint mixCount;\n        //\n        uint p2Level;\n        // 토탈 경험치\n        uint totalExp;\n        // 미션 및, 인플루언서 활동 관련 경험치\n        uint influExp;\n        // 기본 확률\n        uint baseProb;\n        // 토탈 확률\n        uint totalProb;\n        // is PF\n        uint isPFid;\n        // 추가확률\n        uint addProb;\n    }\n\n    struct User {\n        // DB > idx\n        uint userId;\n        // token itme ID\n        uint itemId;\n        address incomeAddr;\n        uint feeBalance;\n        bool isAble;\n        uint mintCount;\n        uint useLevelupCount;\n        uint useMergeCount;\n        // uint ownerIncomePercent;\n        // uint userIncomPercent;\n        //레퍼럴로 얻은 수익\n        uint referralIncome;\n        address agency;\n        uint agencyIncome;\n    }\n\n    function AIENS(uint _key) external view returns (aien memory);\n\n    function PFS(uint _key) external view returns (pf memory);\n\n    function getAien(uint _id) external view;\n\n    function getPF(uint _id) external view;\n\n    function getPfGrade(uint _id) external view returns (uint);\n\n    function setAien(uint _id) external;\n\n    function usePFimg(uint _aienId, uint _pfId) external;\n\n    function setAienAll(\n        uint _id,\n        uint _mixCount,\n        uint _p2Level,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _totalProb,\n        uint _isPFid,\n        uint _addProb\n    ) external;\n\n    function getContractAddr(\n        string memory _name\n    ) external view returns (address);\n\n    function burnValue(uint _burnAmount) external;\n\n    function setAienGradeInfo(uint _toGrade) external;\n\n    function subPfGrades(uint _pfId) external;\n\n    function setLevelUpStatus(uint _toGrade) external;\n\n    function _failedAienSet(\n        uint _id,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _addProb\n    ) external;\n\n    function _successAienSet(\n        uint _id,\n        uint _p2Level,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _addProb\n    ) external;\n\n    function _mergeCalcul(\n        uint _itemId\n    ) external view returns (uint, address, uint, address, uint, uint);\n\n    function _mergeCalcul2(\n        uint _itemId\n    ) external view returns (uint, address, uint, address, uint, uint);\n\n    function _influencerMerge(\n        address _to,\n        uint _itemId,\n        uint _referralIncome\n    ) external returns (uint, string memory);\n\n    function _levelUpCalcul(\n        uint _itemId,\n        uint _fee\n    ) external returns (address, address, uint, uint);\n\n    function _levelUpSucess(uint _id, uint _p2Level) external;\n\n    function _levelUpFailed(uint _id, uint _addProb) external;\n\n    function _mergeCount(\n        address _agency,\n        uint _agencyFee,\n        address _influencer,\n        uint _influencerFee\n    ) external;\n\n    function usePFPower(uint _id, uint _usePower) external;\n\n    function addProbFee() external view returns (uint);\n\n    function PfGrades() external view returns (pfGrade memory);\n\n    function getAienGradeInfo() external view returns (uint[] memory);\n\n    function basicMergeAmount() external view returns (uint);\n\n    function influencerMergeAmount() external view returns (uint);\n\n    function _getMedataMargin() external view returns (uint, uint, uint);\n\n    function getAienLevel(uint _aienId) external view returns (uint);\n\n    function setPerprojectWallet(address _addr) external;\n\n    function setAgencyAddr(address _influencer, address _agency) external;\n\n    function setAgencyIncomePercent(uint _agencyIncomePercent) external;\n\n    function adminSetMergeAmount(\n        uint _influencerMergeAmount,\n        uint _basicMergeAmount,\n        uint _agencyIncomePercent,\n        uint _ownerIncomePercent\n    ) external;\n\n    function getUserFromItem(uint _itemId) external view returns (User memory);\n\n    function adminSetMetaData(\n        uint _pfId,\n        uint8 _grade,\n        string memory _seedHash\n    ) external;\n\n    function _itemMergeFromDiamond(\n        address _to,\n        uint _pfId,\n        string memory _seedHash,\n        uint8 _grade\n    ) external;\n}\n"
    },
    "contracts/Channel_iN/libraries/LibP2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {LibAppStorage, AppStorage, P2_Layer,P2_Aien,P2_User} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\n\n// libs\nimport \"../../shared/libraries/LibEnumerableSet.sol\";\n\nlibrary LibP2 {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    struct AienLoadData {\n\t\t//aien정보\n\t\tuint _aienId;\n\t\tuint _aienLevel;\n\t\t// 출금 토탈\n\t\tuint _aien_base_received;\n\t\tuint _aien_plus_received;\n\t\t//출금 가능\n\t\tuint base_withdrawable;\n\t\tuint plus_withdrawable;\n\t\t// block당 리워드\n\t\tuint block_reward_base;\n\t\tuint block_reward_plus;\n\t}\n\n\tstruct LayerLoadData {\n\t\tbool isOpen;\n\t\tuint _layerNumber;\n\t\tuint _24h_reward_base;\n\t\tuint _24h_reward_plus;\n\t\tuint totalStakedAien;\n\t}\n\tstruct UserLoadData {\n\t\tuint _baseRewarded;\n\t\tuint _plusRewarded;\n\t\tbool _isBlockUser;\n\t}\n\n    modifier isOpenLayer(uint _layer) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.p2_layers[_layer].isOpen, \"P2: Layer is not open\");\n        _;\n    }\n\n    modifier isBlackUser() {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(!s.p2_users[msg.sender].isBlockUser, \"P2: BlackList User\");\n        _;\n    }\n\n    modifier isP2StopCheck() {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(!s.isP2Stop, \"P2: P2 is stopped\");\n        _;\n    }\n\n    modifier isMaxStakingLimit() {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.p2_users[msg.sender].tokenIds.length() < s.P2_MAX_STAKING_LIMIT, \"P2: Max Staking Limit\");\n        _;\n    }\n\n    \n    // function _P2_Start(uint _baseBalance, uint _plusBalance, uint _dailyRewardPercent,uint _maxStakingLimit) internal returns(bool){\n    //     AppStorage storage s = LibAppStorage.diamondStorage();\n    //     s.isP2Stop = true;\n    //     s.REWARD_PERCENT_DECIMAL = 1e5;\n    //     s.PRECISION_FACTOR = 1e12;\n    //     s.DAY_TO_SEC = 86400;\n    //     s.P2_baseBalance = _baseBalance;\n    //     s.P2_plusBalance = _plusBalance;\n    //     s.P2_dailyRewardPercent = _dailyRewardPercent;\n    //     s.P2_dailyRewardUpdateBlock = block.number - 86400;\n    //     s.P2_MAX_STAKING_LIMIT = _maxStakingLimit;\n\n    //     return true;\n    // }\n\n    // function _P2_Layer_Setting(\n    //     uint _layerNumber,\n\t// \tuint _fromP2PlusPercent,\n\t// \tuint _fromP2BasePercent,\n\t// \tuint _dailyReward_Percent,\n\t// \tuint _add_dailyReward_Percent,\n\t// \tbool _isOpen\n    //     ) internal returns(bool){\n    //     AppStorage storage s = LibAppStorage.diamondStorage();\n    //     s.p2_layers[_layerNumber].rewardPlusPercent = _fromP2PlusPercent;\n    //     s.p2_layers[_layerNumber].rewardBasePercent = _fromP2BasePercent;\n    //     s.p2_layers[_layerNumber].dailyReward_Percent = _dailyReward_Percent;\n    //     s.p2_layers[_layerNumber].add_dailyReward_Percent = _add_dailyReward_Percent;\n    //     s.p2_layers[_layerNumber].isOpen = _isOpen;\n        \n    //     return true;\n    // }\n\n    // function _P2_Layer_Balances_Setting(uint _layerNumber, uint _baseBalance,uint _plusBalance, uint _savedBaseBalance,uint _savedPlusBalance) internal returns(bool){\n    //     AppStorage storage s = LibAppStorage.diamondStorage();\n    //     s.p2_layers[_layerNumber].balances.baseBalance = _baseBalance;\n    //     s.p2_layers[_layerNumber].balances.plusBalance = _plusBalance;\n    //     s.p2_layers[_layerNumber].balances.savedBaseBalance = _savedBaseBalance;\n    //     s.p2_layers[_layerNumber].balances.savedPlusBalance = _savedPlusBalance;\n\n    //     return true;\n    // }\n\n    function _P2_Layer_Reset(uint _layerNumber) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        \n        s.p2_layers[_layerNumber].dailyRewardUpdateBlock = block.number;\n        s.p2_layers[_layerNumber].lastRewardBlock = block.number;\n\n        s.p2_layers[_layerNumber].balances.savedBaseBalance += s.p2_layers[_layerNumber].balances.baseBalance;\n        s.p2_layers[_layerNumber].balances.savedPlusBalance += s.p2_layers[_layerNumber].balances.plusBalance;\n\n        (uint dailyBASE, uint dailyPLUS) = __P2_Daily_Calculate(s.P2_baseBalance,s.P2_plusBalance, s.P2_dailyRewardPercent);\n        (uint add_dailyBASE, uint add_dailyPLUS) = __P2_Daily_Calculate(\n            s.p2_layers[_layerNumber].balances.savedBaseBalance, \n            s.p2_layers[_layerNumber].balances.savedPlusBalance, \n            s.p2_layers[_layerNumber].add_dailyReward_Percent\n        );\n        \n        s.p2_layers[_layerNumber].balances.savedBaseBalance -= add_dailyBASE;\n        s.p2_layers[_layerNumber].balances.savedPlusBalance -= add_dailyPLUS;\n\n        s.p2_layers[_layerNumber].balances.baseBalance = \n        ((dailyBASE / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[_layerNumber].rewardBasePercent) + \n        add_dailyBASE;\n\n        s.p2_layers[_layerNumber].balances.plusBalance = \n        ((dailyPLUS / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[_layerNumber].rewardPlusPercent) +\n        add_dailyPLUS;\n\n        __P2_Layer_Update(_layerNumber);\n    }\n\n\n    function _P2_Add_Base_Distribution(uint _base, uint _plus) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.P2_baseBalance += _base;\n        s.P2_plusBalance += _plus;\n\n        __P2_Update();\n    }\n\n    function _P2_Add_Plus_Distribution(uint _plus) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.P2_plusBalance += _plus;\n\n        __P2_Update();\n    }\n\n    function __P2_Update() internal isP2StopCheck() returns (uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        if(s.P2_dailyRewardUpdateBlock == block.number) return block.number;\n\n        if(block.number > s.P2_dailyRewardUpdateBlock + s.DAY_TO_SEC ) {\n\n            uint distri_base = 0;\n            uint distri_plus = 0;\n\n\n            while(block.number > s.P2_dailyRewardUpdateBlock + s.DAY_TO_SEC){\n                s.P2_dailyRewardUpdateBlock += s.DAY_TO_SEC;\n                (uint dailyBASE, uint dailyPLUS) = __P2_Daily_Calculate(s.P2_baseBalance,s.P2_plusBalance, s.P2_dailyRewardPercent);\n                \n                for(uint8 i = 1; i < 11; i++){\n                    (uint add_dailyBASE, uint add_dailyPLUS) = __P2_Daily_Calculate(\n                        s.p2_layers[i].balances.savedBaseBalance,\n                        s.p2_layers[i].balances.savedPlusBalance,\n                        s.p2_layers[i].add_dailyReward_Percent\n                    );\n                distri_base = (dailyBASE / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardBasePercent;\n                distri_plus = (dailyPLUS / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardPlusPercent;\n\n                if(!s.p2_layers[i].isOpen){\n                    s.p2_layers[i].balances.baseBalance = 0;\n                    s.p2_layers[i].balances.plusBalance = 0;\n                    s.p2_layers[i].balances.savedBaseBalance += ((dailyBASE / s.REWARD_PERCENT_DECIMAL) * \n                    s.p2_layers[i].rewardBasePercent);\n                    s.p2_layers[i].balances.savedPlusBalance += ((dailyPLUS / s.REWARD_PERCENT_DECIMAL) *\n                    s.p2_layers[i].rewardPlusPercent);\n\n                continue;\n\n                }\n\n                s.p2_layers[i].balances.savedBaseBalance -= add_dailyBASE;\n                s.p2_layers[i].balances.savedPlusBalance -= add_dailyPLUS;\n\n                s.p2_layers[i].balances.baseBalance = \n                ((dailyBASE / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardBasePercent) +\n                add_dailyBASE;\n\n                s.p2_layers[i].balances.plusBalance = \n                ((dailyPLUS / s.REWARD_PERCENT_DECIMAL) * s.p2_layers[i].rewardPlusPercent) +\n                add_dailyPLUS;\n\n            }\n            //분배 되어야할 dailyReward 차감\n            s.P2_baseBalance -= distri_base;\n            s.P2_plusBalance -= distri_plus;\n            }\n        }\n        return block.number;\n    }\n\n    function __P2_Layer_Update(uint _layerNumber) internal isOpenLayer(_layerNumber) returns (uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(s.p2_layers[_layerNumber].isOpen, \"P2: Layer is not open\");\n        P2_Layer storage layer = s.p2_layers[_layerNumber];\n        \n        uint accRewardBase = 0;\n        uint accRewardPlus = 0;\n\n        if(layer.lastRewardBlock == block.number) return block.number;\n        if(layer.totalStakedAien == 0) return block.number;\n\n        if(block.number > layer.dailyRewardUpdateBlock + s.DAY_TO_SEC){\n            while(block.number > layer.dailyRewardUpdateBlock + s.DAY_TO_SEC){\n                layer.dailyRewardUpdateBlock += s.DAY_TO_SEC;\n\n                // acc = 남은블록의 리워드 * 데일리 리워드 퍼센트                \n                accRewardBase = ((layer.dailyRewardUpdateBlock - layer.lastRewardBlock) *\n                (layer.balances.baseBalance / s.DAY_TO_SEC) *\n                ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n                \n                layer.rewardBase += accRewardBase / layer.totalStakedAien;\n                \n\n                // acc = 남은블록의 리워드 * 데일리 리워드 퍼센트\n                accRewardPlus = ((layer.dailyRewardUpdateBlock - layer.lastRewardBlock) *\n                (layer.balances.plusBalance / s.DAY_TO_SEC) *\n                ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n\n                layer.rewardPlus += accRewardPlus / layer.totalStakedAien;\n\n                ///////////// \n                layer.lastRewardBlock = layer.dailyRewardUpdateBlock;\n            }\n        }\n\n        accRewardBase = ((block.number - layer.lastRewardBlock) *\n        (layer.balances.baseBalance / s.DAY_TO_SEC) *\n        ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n        layer.rewardBase += accRewardBase / layer.totalStakedAien;\n\n\n        accRewardPlus = ((block.number - layer.lastRewardBlock) *\n        (layer.balances.plusBalance / s.DAY_TO_SEC) *\n        ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n        layer.rewardPlus += accRewardPlus / layer.totalStakedAien;\n        /////////////\n        layer.lastRewardBlock = block.number;\n\n        return block.number;\n    }\n\n    function __P2_Pending_Reward(uint _aienId, uint _layerNumber) internal view returns (uint, uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_Layer memory layer = s.p2_layers[_layerNumber];\n        P2_Aien memory aien = s.p2_aiens[_aienId];\n        if(layer.totalStakedAien == 0) return (0,0);\n\n        uint _dailyRewardUpdateBlock = layer.dailyRewardUpdateBlock;\n\t\tuint _lastRewardBlock = layer.lastRewardBlock;\n\t\tuint _rewardBase = layer.rewardBase;\n\t\tuint _rewardPlus = layer.rewardPlus;\n\t\tuint _REWARD_BASE_SUPPLY = layer.balances.baseBalance;\n\t\tuint _REWARD_PLUS_SUPPLY = layer.balances.plusBalance;\n\t\tuint accRewardBase = 0;\n\t\tuint accRewardPlus = 0;\n\t\tuint _nowBlock = block.number;\n\n        if(_nowBlock > layer.dailyRewardUpdateBlock + s.DAY_TO_SEC){\n            while(_nowBlock > _dailyRewardUpdateBlock + s.DAY_TO_SEC){\n                \n                _dailyRewardUpdateBlock += s.DAY_TO_SEC;\n\n                accRewardBase = ((_dailyRewardUpdateBlock - _lastRewardBlock) *\n                (_REWARD_BASE_SUPPLY / s.DAY_TO_SEC) *\n                ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n                \n\n                _rewardBase += accRewardBase / layer.totalStakedAien;\n                _REWARD_BASE_SUPPLY = accRewardBase / s.PRECISION_FACTOR;\n\n                accRewardPlus = ((_dailyRewardUpdateBlock - _lastRewardBlock) *\n                (_REWARD_PLUS_SUPPLY / s.DAY_TO_SEC) *\n                ((layer.dailyReward_Percent * s.PRECISION_FACTOR)/s.REWARD_PERCENT_DECIMAL));\n                \n\n                _rewardPlus += accRewardPlus / layer.totalStakedAien;\n                _REWARD_PLUS_SUPPLY = accRewardPlus / s.PRECISION_FACTOR;\n\n                _lastRewardBlock = _dailyRewardUpdateBlock;\n            }\n        }\n        // \n        accRewardBase = ((_nowBlock - _lastRewardBlock) *\n        (_REWARD_BASE_SUPPLY / s.DAY_TO_SEC) *\n        ((layer.dailyReward_Percent * s.PRECISION_FACTOR) / s.REWARD_PERCENT_DECIMAL));\n\n        _rewardBase += accRewardBase / layer.totalStakedAien;\n        // \n        accRewardPlus = ((_nowBlock - _lastRewardBlock) *\n        (_REWARD_PLUS_SUPPLY / s.DAY_TO_SEC) *\n        ((layer.dailyReward_Percent * s.PRECISION_FACTOR) / s.REWARD_PERCENT_DECIMAL));\n\n        _rewardPlus += accRewardPlus / layer.totalStakedAien;  \n        // \n\n        uint totalRewardBase = _rewardBase - aien.rewardBaseDebt;\n        uint totalRewardPlus = _rewardPlus - aien.rewardPlusDebt;\n\n        return (totalRewardBase / s.PRECISION_FACTOR, totalRewardPlus / s.PRECISION_FACTOR);\n    }\n\n    // \n    // \n    // \n\n    function __P2_Daily_Calculate(uint _baseBalance, uint _plusBalance, uint _dailyRewardPercent) internal pure returns(uint,uint) {\n        uint dailyBASE = (_baseBalance * _dailyRewardPercent) / 1e5;\n        uint dailyPLUS = (_plusBalance * _dailyRewardPercent) / 1e5;\n\n        return (dailyBASE, dailyPLUS);\n    }\n\n\n    function __P2_Reward_Transfer(address _to, uint _base, uint _plus) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\t\tIERC20(s.contracts[\"per\"]).transferFrom(s.contracts[\"p2balance\"],_to, _base);\n        IERC20(s.contracts[\"per\"]).transferFrom(s.contracts[\"p2balance\"],_to, _plus);\n    }\n\n    function __P2_Aien_Transfer(address _staker, uint _aienId) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        IERC721(s.contracts[\"aien\"]).safeTransferFrom(s.contracts[\"p2balance\"], _staker, _aienId);\n    }\n\n\n    \n\n\n    // admin Functions\n    function __P2_Layer_Start(uint _layerNumber) internal {\n        _P2_Layer_Reset(_layerNumber);\n    }\n\n    // user call functions\n    function diamond_P2_deposit(\n\t\taddress _sender,\n\t\tuint _aienId\n\t) internal isMaxStakingLimit isBlackUser isP2StopCheck returns(uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint _layer = IDB(s.contracts[\"db\"]).getAienLevel(_aienId);\n        // P2_Layer storage layer = s.p2_layers[_layer];\n\n\n        \n        // if(layer.totalStakedAien == 0){\n        //     __P2_Layer_Start(_layer);\n        // }\n\n        // __P2_Update();\n        // __P2_Layer_Update(_layer);\n\n        // P2_User storage user = s.p2_users[_sender];\n        // P2_Aien storage aien = s.p2_aiens[_aienId];\n\n        // user.tokenIds.add(_aienId);\n\n        // aien.staker = _sender;\n        // aien.level = _layer;\n\n        // layer.totalStakedAien += 1;\n\n        // aien.rewardBaseDebt = layer.rewardBase;\n        // aien.rewardPlusDebt = layer.rewardPlus;\n\n        return block.number;\n    }\n\n        \n    function diamond_P2_withdraw(\n        address _sender,\n\t\tuint _aienId) internal isBlackUser() isP2StopCheck() returns(uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_User storage user = s.p2_users[_sender];\n        P2_Aien storage aien = s.p2_aiens[_aienId];\n        P2_Layer storage layer = s.p2_layers[aien.level];\n\n        uint pendingBASE;\n        uint pendingPLUS;\n\n        __P2_Update();\n        __P2_Layer_Update(aien.level);\n\n        (pendingBASE, pendingPLUS) = __P2_Pending_Reward(_aienId, aien.level);\n\n\n        __P2_Reward_Transfer(aien.staker, pendingBASE, pendingPLUS);\n\n        user.baseRewarded += pendingBASE;\n        user.plusRewarded += pendingPLUS;\n        \n        aien.base_received += pendingBASE;\n        aien.plus_received += pendingPLUS;\n        \n        user.tokenIds.remove(_aienId);\n\n        layer.totalStakedAien -= 1;\n\n        if(layer.totalStakedAien == 0){\n        layer.dailyRewardUpdateBlock = 0;\n        layer.lastRewardBlock = 0;\n        layer.balances.add_dailyBASE = 0;\n        layer.balances.add_dailyPLUS = 0;\n\n        layer.rewardBase = 0;\n        layer.rewardPlus = 0;\n        }\n\n        aien.rewardBase += pendingBASE;\n        aien.rewardPlus += pendingPLUS;\n        aien.rewardBaseDebt = layer.rewardBase;\n        aien.rewardPlusDebt = layer.rewardPlus;\n\n        __P2_Aien_Transfer(aien.staker, _aienId);\n\n        aien.staker = address(0);\n\n        return block.number;\n    }\n\n    function diamond_P2_harvest(address _sender, uint _aienId) isP2StopCheck() internal returns (uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_User storage user = s.p2_users[_sender];\n        P2_Aien storage aien = s.p2_aiens[_aienId];\n        P2_Layer storage layer = s.p2_layers[aien.level];\n\n        uint pendingBASE;\n        uint pendingPLUS;\n\n        __P2_Update();\n        __P2_Layer_Update(aien.level);\n\n        (pendingBASE, pendingPLUS) = __P2_Pending_Reward(_aienId, aien.level);\n\n        __P2_Reward_Transfer(_sender, pendingBASE, pendingPLUS);\n\n        user.baseRewarded += pendingBASE;\n        user.plusRewarded += pendingPLUS;\n        \n        aien.rewardBaseDebt = layer.rewardBase;\n        aien.rewardPlusDebt = layer.rewardPlus;\n\n        aien.rewardBase += pendingBASE;\n        aien.rewardPlus += pendingPLUS;\n\n        aien.base_received += pendingBASE;\n        aien.plus_received += pendingPLUS;\n\n        return block.number;\n    }\n\n\n\n// view data\n    function diamond_P2_getUserInfo(address _user) internal view returns (UserLoadData memory, AienLoadData[] memory, LayerLoadData[] memory){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_User storage user = s.p2_users[_user];\n        UserLoadData memory _UserLoadData = UserLoadData(\n            user.baseRewarded,\n            user.plusRewarded,\n            user.isBlockUser\n        );\n\n        AienLoadData[] memory _AienLoadData = new AienLoadData[](user.tokenIds.length());\n\t\tLayerLoadData[] memory _LayerLoadData = new LayerLoadData[](11);\n\n        for (uint i = 0; i < user.tokenIds.length(); i++) {\n            \n            P2_Aien memory aien = s.p2_aiens[user.tokenIds.at(i)];\n\n\t\t\t(uint _base, uint _plus) = __P2_Pending_Reward(user.tokenIds.at(i), aien.level);\n\n\t\t\t_AienLoadData[i]._aienId = user.tokenIds.at(i);\n\t\t\t_AienLoadData[i]._aienLevel = aien.level;\n\t\t\t_AienLoadData[i]._aien_base_received = aien.base_received;\n\t\t\t_AienLoadData[i]._aien_plus_received = aien.plus_received;\n\t\t\t_AienLoadData[i].block_reward_base =\n\t\t\t\t((s.p2_layers[aien.level].balances.baseBalance *\n\t\t\t\t\ts.p2_layers[aien.level].dailyReward_Percent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL /\n\t\t\t\t\ts.p2_layers[aien.level].totalStakedAien) /\n\t\t\t\ts.DAY_TO_SEC;\n\n\t\t\t_AienLoadData[i].block_reward_plus =\n\t\t\t\t((s.p2_layers[aien.level].balances.plusBalance *\n\t\t\t\t\ts.p2_layers[aien.level].dailyReward_Percent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL /\n\t\t\t\t\ts.p2_layers[aien.level].totalStakedAien) /\n\t\t\t\ts.DAY_TO_SEC;\n\t\t\t_AienLoadData[i].base_withdrawable = _base;\n\t\t\t_AienLoadData[i].plus_withdrawable = _plus;\n\t\t}\n\n        for (uint i = 1; i < 11; i++) {\n\t\t\tP2_Layer memory layer = s.p2_layers[i];\n\n\t\t\t// if(layer.isOpen == false) break;\n\t\t\t// (uint dailyBASE, uint dailyPLUS) = __P2_Daily_Calculate(s.P2_baseBalance, s.P2_plusBalance, s.P2_dailyRewardPercent);\n\n\t\t\t(uint add_dailyBASE, uint add_dailyPLUS) = __P2_Daily_Calculate(\n\t\t\t\tlayer.balances.savedBaseBalance,\n\t\t\t\tlayer.balances.savedPlusBalance,\n\t\t\t\tlayer.add_dailyReward_Percent\n\t\t\t);\n\t\t\tuint _totalStakedAien;\n\t\t\tlayer.totalStakedAien == 0 ? _totalStakedAien = 1 : _totalStakedAien = layer.totalStakedAien;\n\t\t\t_LayerLoadData[i]._layerNumber = i;\n\t\t\t_LayerLoadData[i].isOpen = layer.isOpen;\n\t\t\t_LayerLoadData[i]._24h_reward_base =\n\t\t\t\t(((((s.P2_baseBalance * s.P2_dailyRewardPercent) / s.REWARD_PERCENT_DECIMAL) * layer.rewardBasePercent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL) + add_dailyBASE) /\n\t\t\t\t_totalStakedAien;\n\n\t\t\t_LayerLoadData[i]._24h_reward_plus =\n\t\t\t\t(((((s.P2_plusBalance * s.P2_dailyRewardPercent) / s.REWARD_PERCENT_DECIMAL) * layer.rewardPlusPercent) /\n\t\t\t\t\ts.REWARD_PERCENT_DECIMAL) + add_dailyPLUS) /\n\t\t\t\t_totalStakedAien;\n\n\t\t\t_LayerLoadData[i].totalStakedAien = layer.totalStakedAien;\n\t\t}\n\n\t\treturn (_UserLoadData, _AienLoadData, _LayerLoadData);\n    }\n\n    function diamond_p2_getLayerData(uint _layerNumber) internal view returns(uint,uint,uint){\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        P2_Layer memory layer = s.p2_layers[_layerNumber];\n        \n        uint base = (layer.balances.savedBaseBalance * layer.dailyReward_Percent) / \n        s.REWARD_PERCENT_DECIMAL / \n        (layer.totalStakedAien + 1);\n\n        uint plus = (layer.balances.savedPlusBalance * layer.dailyReward_Percent) /\n        s.REWARD_PERCENT_DECIMAL /\n        (layer.totalStakedAien + 1);\n\n        return (base / s.DAY_TO_SEC, plus / s.DAY_TO_SEC, layer.totalStakedAien);\n    }\n    \n\n\n    function onERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 tokenId,\n\t\tbytes memory data\n\t) internal pure returns (bytes4) {\n\t\treturn bytes4(keccak256('onERC721Received(address,address,uint256,bytes)'));\n\t}\n\n\n\n\n}\n\n"
    },
    "contracts/shared/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/shared/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n//import \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\n/* interface IERC721 is IERC165 { */\ninterface IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n\n    function burn(uint256 _tokenId) external;\n\n    function safeMintByMinter(address _to) external;\n\n    function nextTokenId() external view returns (uint256);\n}\n"
    },
    "contracts/shared/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {LibDiamond} from \"./LibDiamond.sol\";\nimport {EnumerableSet} from \"../../shared/libraries/LibEnumerableSet.sol\";\nimport {LibMeta} from \"./LibMeta.sol\";\n\nusing EnumerableSet for EnumerableSet.UintSet;\n// i-Tez Structs\n//- P0 struct\nstruct P0_State {\n    uint24 maxProb;\n    // 퍼프렌즈를 이용한 PF POWER 변환시 개당 수수료\n    uint addProbFee;\n    // 퍼프렌즈를 이용한 PF POWER 변환시 획득 경험치\n    uint16 addProbExp;\n    // bool\n    bool isVRF;\n}\nstruct P0_PerFriendsProb {\n    string pfGrade;\n    uint24 gradeProb;\n}\n\nstruct P0_GradeInfo {\n    // 다음 level이 열렸는지 확인\n    bool isOpen;\n    // level별 mix fee\n    uint mixFee;\n    // 레벨업 성공시 level별 초기 base 확률\n    uint24 initBaseProb;\n    // level별 추가 확률 밸런스 조정값\n    uint16 mixExp;\n    // level별 합성 실패시 추가 확률 min,max\n    uint24 failedAddProbMin;\n    // 1000 = 0.1%, 10000 = 0.01%\n    uint24 failedAddProbMax;\n}\n\nstruct P0_MergePfGrade {\n    uint8 grade;\n    string gradeName;\n    uint mergeFee;\n    uint mergeUseItemAmount;\n    uint latestId;\n    uint setMatadataId;\n    bool isOpen;\n}\nstruct P0_MergeState {\n    uint agencyIncomePercent;\n    uint influencerIncomePercent;\n}\n// //- Distribute struct\nstruct Distribute_State {\n    uint beforeP2Usdt;\n    uint beforeP2Per;\n    uint beforeTeamUsdt;\n    // distribute ratios\n    uint24 p1Ratio;\n    uint24 p2PerRatio;\n    uint24 p2UsdtRatio;\n    uint24 burnRatio;\n    uint24 teamUsdtRatio;\n}\n// DB > Filtered User Struct\nstruct User {\n    // DB > idx\n    uint userId;\n    // token itme ID\n    uint itemId;\n    address incomeAddr;\n    uint feeBalance;\n    bool isAble;\n    uint mintCount;\n    uint useLevelupCount;\n    uint useMergeCount;\n    //레퍼럴로 얻은 수익\n    uint referralIncome;\n    address agency;\n    uint agencyIncome;\n}\n\n// struct P3_AienCollection {\n//     address nftAddress;\n//     string name;\n//     string symbol;\n//     uint highestPrice;\n//     uint floorPrice;\n//     uint totalTradeVolume;\n//     uint totalTradeCount;\n// }\n\n// struct P3_Aien {\n//     uint tokenId;\n//     uint lastTradePrice;\n//     // maybe add tx history\n// }\n\n// struct P3_AienOrder {\n//     uint orderId;\n//     address seller;\n//     address buyer;\n//     uint tokenId;\n//     uint8 level;\n//     uint32 baseProb;\n//     uint32 addProb;\n//     uint price;\n//     uint tradeTime;\n//     uint8 orderType;\n// }\n\n// struct P3_PfCollection {\n//     address nftAddress;\n//     string name;\n//     string symbol;\n//     uint highestPrice;\n//     uint floorPrice;\n//     uint totalTradeVolume;\n//     uint totalTradeCount;\n// }\n\n// struct P3_PfOrder {\n//     uint orderId;\n//     address seller;\n//     address buyer;\n//     uint tokenId;\n//     uint8 grade;\n//     uint price;\n//     uint tradeTime;\n//     uint8 orderType;\n// }\n\n//\n//\n//\n//\n// P2 start\nstruct P2_State {\n    // P2 global state\n    bool isP2Stop;\n    // \n    uint P2_baseBalance;\n    uint P2_plusBalance;\n    // \n    uint P2_dailyRewardPercent;\n    // \n    uint P2_dailyRewardUpdateBlock;\n    uint P2_lastRewardBlock;\n    // \n    uint MAX_STAKING_LIMIT;\n}\n\nstruct P2_User {\n    // 블랙유저 찾아야함\n    bool isBlockUser;\n\tuint plusRewarded;\n\tuint baseRewarded;\n\tEnumerableSet.UintSet tokenIds;\n}\n\nstruct P2_Aien {\n    address staker;\n\tuint level;\n\t// requires value\n\tuint rewardPlus;\n\tuint rewardBase;\n\tuint rewardBaseDebt;\n\tuint rewardPlusDebt;\n\t////////////////////\n\tuint plus_received;\n\tuint base_received;\n}\n\nstruct P2_Balances {\n// 로직상 계산에 필요한 밸런스 변수 (실제와 다를 수 있음)\n\tuint plusBalance;\n\tuint baseBalance;\n\t// 레이어가 오픈 되지 않은 상태에서\n\t// 레이어가 오픈되면 해당 레이어에 저장된 리워드를 데일리 리워드로 추가 분배하기 위한 변수\n\tuint savedPlusBalance;\n\tuint savedBaseBalance;\n\t// 현재 savedUsdt, savedPer를 통해 나온 데일리 리워드\n\tuint add_dailyBASE;\n\tuint add_dailyPLUS;\n\t// 보안상 문제가 생겨\n\t// 예상보다 많은 withdraw를 요청하게 되는 경우\n\t// 지금까지 쌓인 레이어별 토탈 밸런스와\n\t// 지금까지 쌓인 레이어별 출금 밸런스를 비교하여\n\t// 출금 가능한지 체크하는 변수\n\tuint a;\n\tuint b;\n\tuint c;\n\tuint d;\n}\n\nstruct P2_Layer {\n    P2_Balances balances;\n\t// P2에서 해당 레이어에 토큰 배정 받을때 리워드 퍼센트\n\tuint rewardBasePercent;\n\tuint rewardPlusPercent;\n\t// 유저에게 하루에 분배하는 리워드 퍼센트\n\tuint dailyReward_Percent;\n\t// 계산에 필요\n\tuint rewardPlus;\n\tuint rewardBase;\n\t// 미오픈시 저장한 리워드를 데일리 리워드로 추가 분배하기 위한 퍼센트변수\n\tuint add_dailyReward_Percent;\n\tuint lastRewardBlock;\n\tuint dailyRewardUpdateBlock;\n\tuint totalStakedAien;\n\tbool isOpen;\n}\n\n//   struct P2_Layer {\n//       P2_Balances balances;\n//   \t// P2에서 해당 레이어에 토큰 배정 받을때 리워드 퍼센트\n//   \tuint rewardBasePercent;\n//   \tuint rewardPlusPercent;\n//   \t// 계산에 필요\n//   \tuint rewardBase;\n//   \tuint rewardPlus;\n//       // \n//       // \n//       //////////////////////////////////////////////////////////\n//   \t// 유저에게 하루에 분배하는 리워드 퍼센트///////////////////////////               \n//   \tuint dailyReward_Percent;/////////////////////////////////\n//   \t// 미오픈시 저장한 리워드를 데일리 리워드로 추가 분배하기 위한 퍼센트변수//\n//   \tuint add_dailyReward_Percent;/////////////////////////////\n//       //////////////////////////////////////////////////////////\n//   \t// \n//       // \n//       uint lastRewardBlock;\n//   \tuint dailyRewardUpdateBlock;\n//   \tuint totalStakedAien;\n//   \tbool isOpen;\n//   }\n\n// struct P2_AienLoadData {\n//     //aien정보\n// \tuint _aienId;\n// \tuint _aienLevel;\n// \t// 출금 토탈\n// \tuint _aien_plus_received;\n// \tuint _aien_base_received;\n// \t//출금 가능\n// \tuint base_withdrawable;\n// \tuint plus_withdrawable;\n// \t// block당 리워드\n// \tuint block_reward_plus;\n// \tuint block_reward_base;\n// }\n\n// struct P2_LayerLoadData {\n//     bool isOpen;\n// \tuint _layerNumber;\n// \tuint _24h_reward_plus;\n// \tuint _24h_reward_base;\n// \tuint totalStakedAien;\n// }\n\n// struct P2_UserLoadData {\n//     uint _baseRewarded;\n// \tuint _plusRewarded;\n// \tbool _isBlockUser;\n// }\n\n// // P2 end\n\n// P0 End\nstruct AppStorage {\n    // address constants\n    mapping(string => address) contracts;\n    // i-Tez/////////////////////////////\n    // P0 ///////////////////////////////\n    P0_State p0_states;\n    P0_GradeInfo[11] p0_gradeInfos;\n    mapping(uint => P0_PerFriendsProb) p0_perFriendsProbs;\n    /////////////////////////////////////\n    // Distribute ///////////////////////\n    Distribute_State distribute_states;\n    uint aienMintFee;\n    // Distribute\n    uint ksSwapLimit;\n    bool isAutoDistribute;\n    // P0 - Item Merge Grade Infos\n    mapping(uint8 => P0_MergePfGrade) p0_mergePfGrades;\n    mapping(uint => string) pfMetaURI;\n    P0_MergeState p0_mergeState;\n    //////////////////////////\n    // P3/////////////////////\n    //\n    // // userAddr => orderIds;\n    // mapping(address => uint[]) p3_userOrders;\n    // //\n    // //\n    // // tokenId => orderIds;\n    // mapping(uint => uint[]) p3_aienTokenOrders;\n    // // orderId => orderInfo\n    // // mapping(uint => P3_Aien_Order) p3_aienOrders;\n    // //\n    // // tokenId => orderIds;\n    // mapping(uint => uint[]) p3_pfTokenOrders;\n    // // orderId => orderInfo\n    // mapping(uint => P3_PfOrder) p3_pfOrders;\n    //\n    //\n    //\n    //\n    // //////////////////////////\n    // P2////////////////////////   \n    bool isP2Stop;\n    uint P2_baseBalance;\n    uint P2_plusBalance;\n    uint P2_dailyRewardPercent;\n    uint P2_dailyRewardUpdateBlock;\n    uint P2_lastRewardBlock;\n    uint P2_MAX_STAKING_LIMIT;\n    uint DAY_TO_SEC;\n    uint REWARD_PERCENT_DECIMAL;\n    uint PRECISION_FACTOR;\n    // \n    uint[5] __gap;\n    mapping(address => P2_User) p2_users;\n    mapping(uint => P2_Aien) p2_aiens;\n    mapping(string => P2_Balances) p2_balances;\n    mapping(uint => P2_Layer) p2_layers;\n    // mapping(uint => P2_AienLoadData) p2_aienLoadDatas;\n    // mapping(uint => P2_LayerLoadData) p2_layerLoadDatas;\n    // mapping(address => P2_UserLoadData) p2_userLoadDatas;\n    \n}\n\nlibrary LibAppStorage {\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\n        assembly {\n            ds.slot := 0\n        }\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x >= 0 ? x : -x);\n    }\n}\n\n/**\n@dev global modifier\n */\ncontract Modifiers {\n    modifier onlyDev() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n}\n"
    },
    "contracts/shared/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/shared/libraries/LibEnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/shared/libraries/LibMeta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nlibrary LibMeta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"\n            )\n        );\n\n    function domainSeparator(\n        string memory name,\n        string memory version\n    ) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}