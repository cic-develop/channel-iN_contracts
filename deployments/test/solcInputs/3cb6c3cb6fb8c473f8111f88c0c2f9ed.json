{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Channel_iN/facets/AienMintFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {LibAienMint} from \"../libraries/LibAienMint.sol\";\n\n/**\n@dev Aien Mint Facet Contract\n */\n\ncontract AienMintFacet {\n    // aien mint functions\n    function aiMint() external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._aiMint(msgsender);\n    }\n\n    function pfMint(uint _pfId) external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._pfMint(msgsender, _pfId);\n    }\n\n    function defaultMint() external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._defaultMint(msgsender);\n    }\n\n    // image chage functions\n    function defaultSetImage(uint _aienId) external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._defaultSetImage(msgsender, _aienId);\n    }\n\n    function aiSetImage(uint _aienId) external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._aiSetImage(msgsender, _aienId);\n    }\n\n    function pfSetImage(uint _aienId, uint _pfId) external {\n        address msgsender = LibMeta.msgSender();\n        LibAienMint._pfSetImage(msgsender, _aienId, _pfId);\n    }\n}\n"
    },
    "contracts/Channel_iN/facets/P0Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {LibP0} from \"../libraries/LibP0.sol\";\n\n/**\n@dev i-TEZ : P0 (Mix) Facet Contract\n */\ncontract P0Facet is Modifiers {\n    function itemMerge(uint _itemId, uint _itemAmount) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        LibP0._itemMerge(msgsender, _itemId, _itemAmount);\n    }\n\n    function baseMixCall(uint _id, uint _useItemId) external returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        return LibP0._baseMixCall(msgsender, _id, _useItemId);\n    }\n\n    function premiumMixCall(uint _id, uint _useItemId) external returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        LibP0._premiumMixCall(msgsender, _id, _useItemId);\n    }\n\n    function addProbCall(\n        uint _aienId,\n        uint[] memory _pf_Ids\n    ) external returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        LibP0._addProbCall(msgsender, _aienId, _pf_Ids);\n    }\n}\n"
    },
    "contracts/Channel_iN/interfaces/IDB.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// legacy db contract interface\ninterface IDB {\n    struct pf {\n        uint id;\n        uint class;\n        bool isAien;\n        uint usedAienId;\n    }\n    struct aien {\n        uint id;\n        // 강화 횟수\n        uint mixCount;\n        //\n        uint p2Level;\n        // 토탈 경험치\n        uint totalExp;\n        // 미션 및, 인플루언서 활동 관련 경험치\n        uint influExp;\n        // 기본 확률\n        uint baseProb;\n        // 토탈 확률\n        uint totalProb;\n        // is PF\n        uint isPFid;\n        // 추가확률\n        uint addProb;\n    }\n\n    function AIENS(uint _key) external view returns (aien memory);\n\n    function PFS(uint _key) external view returns (pf memory);\n\n    function getAien(uint _id) external view;\n\n    function getPF(uint _id) external view;\n\n    function getPfGrade(uint _id) external view returns (uint);\n\n    function setAien(uint _id) external;\n\n    function usePFimg(uint _aienId, uint _pfId) external;\n\n    function setAienAll(\n        uint _id,\n        uint _mixCount,\n        uint _p2Level,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _totalProb,\n        uint _isPFid,\n        uint _addProb\n    ) external;\n\n    function getContractAddr(\n        string memory _name\n    ) external view returns (address);\n\n    function burnValue(uint _burnAmount) external;\n\n    function setAienGradeInfo(uint _toGrade) external;\n\n    function subPfGrades(uint _pfId) external;\n\n    function setLevelUpStatus(uint _toGrade) external;\n\n    function _failedAienSet(\n        uint _id,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _addProb\n    ) external;\n\n    function _successAienSet(\n        uint _id,\n        uint _p2Level,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _addProb\n    ) external;\n\n    function _mergeCalcul(\n        uint _itemId\n    ) external view returns (uint, address, uint, address, uint, uint);\n\n    function _mergeCalcul2(\n        uint _itemId\n    ) external view returns (uint, address, uint, address, uint, uint);\n\n    function _influencerMerge(\n        address _to,\n        uint _itemId,\n        uint _referralIncome\n    ) external returns (uint, string memory);\n\n    function _levelUpCalcul(\n        uint _itemId,\n        uint _fee\n    ) external returns (address, address, uint, uint);\n\n    function _levelUpSucess(uint _id, uint _p2Level) external;\n\n    function _levelUpFailed(uint _id, uint _addProb) external;\n\n    function _mergeCount(\n        address _agency,\n        uint _agencyFee,\n        address _influencer,\n        uint _influencerFee\n    ) external;\n\n    function usePFPower(uint _id, uint _usePower) external;\n}\n"
    },
    "contracts/Channel_iN/interfaces/IP1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ninterface IP1 {\n    struct PendingInfo {\n        address user;\n        // 1: 출금요청,\n        // 2: 출금취소,\n        // 3: 완료,\n        // 4: 취소완료: 완료시 재예치 버튼 활성화\n        uint8 pendingType;\n        uint startTime;\n        uint endTime;\n        uint amount;\n        // pending Id\n        uint pendingId;\n    }\n\n    function update() external returns (uint);\n\n    function diamond_P1_deposit(\n        address _sender,\n        uint _amount\n    ) external returns (uint);\n\n    function diamond_P1_reDposit(address _sender) external returns (uint);\n\n    function diamond_P1_harvest(address _sender) external returns (uint);\n\n    function diamond_P1_pendingReward(\n        address _sender,\n        uint _withdrawBlock\n    ) external view returns (uint);\n\n    function diamond_P1_addPower(\n        address _sender,\n        uint _aienId,\n        uint _usePower\n    ) external returns (uint);\n\n    function diamond_P1_widthdraw(\n        address _sender,\n        uint _amount\n    ) external returns (uint);\n\n    function diamond_P1_widthdrawConfirm(\n        address _sender,\n        uint _pendingId\n    ) external returns (uint);\n\n    function diamond_P1_widthdrawCancel(\n        address _sender,\n        uint _pendingId\n    ) external returns (uint);\n\n    function diamond_P1_widthdrawCancelConfirm(\n        address _sender,\n        uint _pendingId\n    ) external returns (uint);\n\n    function diamond_P1_getPoolData() external view returns (uint, uint, uint);\n\n    function diamond_P1_getUserData(\n        address _sender\n    ) external view returns (uint, uint, uint, uint, uint);\n\n    function diamond_P1_getUnstakeData(\n        address _sender\n    ) external view returns (PendingInfo[] memory);\n\n\n    function diamond_P1_addDistributionAmountAll(uint _amount) external;\n}\n"
    },
    "contracts/Channel_iN/interfaces/IP2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ninterface IP2 {\n    struct User {\n        bool isBlockUser;\n        uint perRewarded;\n        uint usdtRewarded;\n        EnumerableSet.UintSet tokenIds;\n    }\n\n    struct Aien {\n        address staker;\n        uint level;\n        // requires value\n        uint rewardPer;\n        uint rewardUsdt;\n        uint rewardUsdtDebt;\n        uint rewardPerDebt;\n        ////////////////////\n        uint per_received;\n        uint usdt_received;\n    }\n\n    struct Balances {\n        // 로직상 계산에 필요한 밸런스 변수 (실제와 다를 수 있음)\n        uint perBalance;\n        uint usdtBalance;\n        // 레이어가 오픈 되지 않은 상태에서\n        // 레이어가 오픈되면 해당 레이어에 저장된 리워드를 데일리 리워드로 추가 분배하기 위한 변수\n        uint savedPerBalance;\n        uint savedUsdtBalance;\n        // 현재 savedUsdt, savedPer를 통해 나온 데일리 리워드\n        uint add_dailyUSDT;\n        uint add_dailyPER;\n        // 보안상 문제가 생겨\n        // 예상보다 많은 withdraw를 요청하게 되는 경우\n        // 지금까지 쌓인 레이어별 토탈 밸런스와\n        // 지금까지 쌓인 레이어별 출금 밸런스를 비교하여\n        // 출금 가능한지 체크하는 변수\n        uint total_checkWithdrawPER;\n        uint withdrawal_checkWithdrawPER;\n        uint total_checkWithdrawUSDT;\n        uint withdrawal_checkWithdrawUSDT;\n    }\n\n    struct Layer {\n        Balances balances;\n        // P2에서 해당 레이어에 토큰 배정 받을때 리워드 퍼센트\n        uint rewardUsdtPercent;\n        uint rewardPerPercent;\n        // 유저에게 하루에 분배하는 리워드 퍼센트\n        uint dailyReward_Percent;\n        // 계산에 필요\n        uint rewardPer;\n        uint rewardUsdt;\n        // 미오픈시 저장한 리워드를 데일리 리워드로 추가 분배하기 위한 퍼센트변수\n        uint add_dailyReward_Percent;\n        uint lastRewardBlock;\n        uint dailyRewardUpdateBlock;\n        uint totalStakedAien;\n        bool isOpen;\n    }\n\n    struct AienLoadData {\n        //aien정보\n        uint _aienId;\n        uint _aienLevel;\n        // 출금 토탈\n        uint _aien_per_received;\n        uint _aien_usdt_received;\n        //출금 가능\n        uint usdt_withdrawable;\n        uint per_withdrawable;\n        // block당 리워드\n        uint block_reward_per;\n        uint block_reward_usdt;\n    }\n\n    struct LayerLoadData {\n        bool isOpen;\n        uint _layerNumber;\n        uint _24h_reward_per;\n        uint _24h_reward_usdt;\n        uint totalStakedAien;\n    }\n    struct UserLoadData {\n        uint _usdtRewarded;\n        uint _perRewarded;\n        bool _isBlockUser;\n    }\n\n    function aiens(uint _id) external view returns (Aien memory);\n\n    function diamond_P2_deposit(address _sender, uint _aienId) external;\n\n    function diamond_P2_withdraw(address _sender, uint _aienId) external;\n\n    function diamond_P2_harvest(address _sender, uint _aienId) external;\n\n    function diamond_P2_getUserInfo(\n        address _sender\n    )\n        external\n        view\n        returns (\n            UserLoadData memory,\n            AienLoadData[] memory,\n            LayerLoadData[] memory\n        );\n\n    function diamond_P2_getLayerData(\n        uint _number\n    ) external view returns (uint, uint, uint);\n\n    function addPerUsdtDistribution(uint _usdt, uint _per) external;\n}\n"
    },
    "contracts/Channel_iN/libraries/LibAienMint.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {LibDistribute} from \"../../shared/libraries/LibDistribute.sol\";\n\nlibrary LibAienMint {\n    event DefaultMint(address indexed _to, uint indexed _tokenId);\n    event AiMint(address indexed _to, uint indexed _tokenId);\n    event PfMint(\n        address indexed _to,\n        uint indexed _tokenId,\n        uint indexed _pfId\n    );\n\n    event DefaultSetImage(address indexed _to, uint indexed _tokenId);\n    event AiSetImage(address indexed _to, uint indexed _tokenId);\n    event PfSetImage(\n        address indexed _to,\n        uint indexed _tokenId,\n        uint indexed _pfId\n    );\n    event PfDeleteImage(uint indexed _tokenId, uint indexed _pfId);\n\n    modifier onlyFirstMint() {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(\n            IERC721(s.contracts[\"aien\"]).balanceOf(LibMeta.msgSender()) == 0,\n            \"already minted\"\n        );\n        _;\n    }\n\n    function _aiMint(address _sender) internal onlyFirstMint returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint id = IERC721(s.contracts[\"aien\"]).nextTokenId();\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"aien\"],\n            s.aienMintFee\n        );\n        IERC721(s.contracts[\"aien\"]).safeMintByMinter(_sender);\n        IDB(s.contracts[\"db\"]).setAien(id);\n\n        emit AiMint(_sender, id);\n        return id;\n    }\n\n    function _defaultMint(\n        address _sender\n    ) internal onlyFirstMint returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint id = IERC721(s.contracts[\"aien\"]).nextTokenId();\n\n        IERC721(s.contracts[\"aien\"]).safeMintByMinter(_sender);\n        IDB(s.contracts[\"db\"]).setAien(id);\n\n        emit DefaultMint(_sender, id);\n        return id;\n    }\n\n    function _pfMint(\n        address _sender,\n        uint _pfId\n    ) internal onlyFirstMint returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        require(\n            IERC721(s.contracts[\"perfriends\"]).ownerOf(_pfId) == _sender,\n            \"not owner\"\n        );\n        // PF의 등급이 상위 3등급인지 체크 (unique, legendary, myth)\n        require(\n            IDB(s.contracts[\"db\"]).getPfGrade(_pfId) > 4,\n            \"at least PF grade 5\"\n        );\n\n        uint id = IERC721(s.contracts[\"aien\"]).nextTokenId();\n        IDB(s.contracts[\"db\"]).setAien(id);\n        IDB(s.contracts[\"db\"]).usePFimg(id, _pfId);\n        IERC721(s.contracts[\"aien\"]).safeMintByMinter(_sender);\n\n        emit PfMint(_sender, id, _pfId);\n\n        return id;\n    }\n\n    function _defaultSetImage(address _sender, uint _aienId) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_aienId) == _sender,\n            \"not owner\"\n        );\n\n        emit DefaultSetImage(_sender, _aienId);\n    }\n\n    function _aiSetImage(address _sender, uint _aienId) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_aienId) == _sender,\n            \"not owner\"\n        );\n\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"team\"],\n            s.aienMintFee\n        );\n\n        emit AiSetImage(_sender, _aienId);\n    }\n\n    function _pfSetImage(\n        address _sender,\n        uint _aienId,\n        uint _pfId\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_aienId) == _sender,\n            \"not owner\"\n        );\n        require(\n            IERC721(s.contracts[\"perfriends\"]).ownerOf(_pfId) == _sender,\n            \"not owner\"\n        );\n        // PF의 등급이 상위 3등급인지 체크 (unique, legendary, myth)\n        require(\n            IDB(s.contracts[\"db\"]).getPfGrade(_pfId) > 4,\n            \"at least PF grade 5\"\n        );\n\n        IDB(s.contracts[\"db\"]).usePFimg(_aienId, _pfId);\n\n        emit PfSetImage(_sender, _aienId, _pfId);\n    }\n}\n"
    },
    "contracts/Channel_iN/libraries/LibP0.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../shared/interfaces/IERC1155.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {LibDistribute} from \"../../shared/libraries/LibDistribute.sol\";\n\nlibrary LibP0 {\n    // events\n    event MixCall(\n        uint indexed _tokenId,\n        uint indexed _mixType,\n        bool indexed isLevelUp,\n        uint price\n    );\n    event MergeToMint(\n        address indexed _to,\n        uint indexed _PerFriends_id,\n        uint indexed _Use_item_id,\n        uint _usePerAmount,\n        bytes _pfURI\n    );\n\n    function _baseMixCall(\n        address _sender,\n        uint _id,\n        uint _useItemId\n    ) internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_id) == _sender,\n            \"not owner\"\n        );\n        IDB.aien memory _AIEN = IDB(s.contracts[\"db\"]).AIENS(_id);\n        // P0_GradeInfo memory _gradeInfo = s.p0_gradeInfos[_AIEN.p2Level];\n        // P0_GradeInfo memory _gradeInfoNext = s.p0_gradeInfos[_AIEN.p2Level + 1];\n\n        require(s.p0_gradeInfos[_AIEN.p2Level].isOpen == true, \"not open\");\n\n        (\n            address _influencer,\n            address _agency,\n            uint _influencerFee,\n            uint _agencyFee\n        ) = IDB(s.contracts[\"db\"])._levelUpCalcul(\n                _useItemId,\n                s.p0_gradeInfos[_AIEN.p2Level].mixFee\n            );\n\n        IERC1155(s.contracts[\"item\"]).burn(_sender, _useItemId, 1);\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        if (_AIEN.p2Level == 0) {\n            IDB(s.contracts[\"db\"])._levelUpSucess(_id, _AIEN.p2Level);\n            emit MixCall(_id, 0, true, s.p0_gradeInfos[_AIEN.p2Level].mixFee);\n\n            return true;\n        }\n\n        uint _random = __random(_sender);\n\n        // 성공시\n        if (_random <= _AIEN.baseProb) {\n            // 성공률 초기화\n            // 레벨 상승\n            IDB(s.contracts[\"db\"])._levelUpSucess(_id, _AIEN.p2Level);\n        } else {\n            // base성공률에 랜덤 성공률 추가\n\n            uint _randomAdd = __randomAddProb(\n                _sender,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMax,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMin\n            );\n            // 경험치 상승\n            // _AIEN[_id].baseProb += _randomAdd;\n\n            IDB(s.contracts[\"db\"])._levelUpFailed(_id, _randomAdd);\n        }\n\n        emit MixCall(\n            _id,\n            0,\n            _random <= _AIEN.baseProb,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        return true;\n    }\n\n    function _premiumMixCall(\n        address _sender,\n        uint _aienId,\n        uint _useItemId\n    ) internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        IDB.aien memory _AIEN = IDB(s.contracts[\"db\"]).AIENS(_aienId);\n\n        require(_AIEN.p2Level != 0, \"not premium level\");\n        require(s.p0_gradeInfos[_AIEN.p2Level].isOpen == true, \"not open\");\n\n        (\n            address _influencer,\n            address _agency,\n            uint _influencerFee,\n            uint _agencyFee\n        ) = IDB(s.contracts[\"db\"])._levelUpCalcul(\n                _useItemId,\n                s.p0_gradeInfos[_AIEN.p2Level].mixFee\n            );\n\n        IERC1155(s.contracts[\"item\"]).burn(_sender, _useItemId, 1);\n\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        uint _random = __random(_sender);\n        uint totalProb = 0;\n        if (_AIEN.baseProb + _AIEN.addProb > _random) {\n            totalProb = _AIEN.baseProb + _AIEN.addProb - s.p0_states.maxProb;\n        }\n\n        if (_AIEN.baseProb + _AIEN.addProb >= _random) {\n            // 성공률 초기화\n            // 레벨 상승\n            IDB(s.contracts[\"db\"])._successAienSet(\n                _aienId,\n                _AIEN.p2Level + 1,\n                _AIEN.totalExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                _AIEN.influExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                s.p0_gradeInfos[_AIEN.p2Level].initBaseProb,\n                totalProb\n            );\n        } else {\n            uint _randomAdd = __randomAddProb(\n                _sender,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMax,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMin\n            );\n\n            IDB(s.contracts[\"db\"])._failedAienSet(\n                _aienId,\n                _AIEN.totalExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                _AIEN.influExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                _AIEN.baseProb + _randomAdd,\n                totalProb\n            );\n        }\n\n        emit MixCall(\n            _aienId,\n            1,\n            _AIEN.baseProb + _AIEN.addProb >= _random,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        return true;\n    }\n\n    function _itemMerge(\n        address _sender,\n        uint _itemId,\n        uint _itemAmount\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint mergeFee;\n        address _influencer;\n        uint _influencerFee;\n        address _agency;\n        uint _agencyFee;\n        uint _influencerItemAmount;\n\n        if (_itemId <= 50) {\n            (\n                mergeFee,\n                _influencer,\n                _influencerFee,\n                _agency,\n                _agencyFee,\n                _influencerItemAmount\n            ) = IDB(s.contracts[\"db\"])._mergeCalcul(_itemId);\n        } else {\n            (\n                mergeFee,\n                _influencer,\n                _influencerFee,\n                _agency,\n                _agencyFee,\n                _influencerItemAmount\n            ) = IDB(s.contracts[\"db\"])._mergeCalcul2(_itemId);\n        }\n\n        require(_itemAmount == _influencerItemAmount);\n\n        // merge 할때 카운트 적용 함수\n        IDB(s.contracts[\"db\"])._mergeCount(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee\n        );\n        //\n        IERC1155(s.contracts[\"item\"]).burn(_sender, _itemId, _itemAmount);\n\n        // IERC20(PER).transferFrom(msg.sender, address(this), mergeFee);\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            mergeFee\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee,\n            mergeFee\n        );\n\n        (uint mintPfId, string memory _pfURI) = IDB(s.contracts[\"db\"])\n            ._influencerMerge(_sender, _itemId, 0);\n        emit MergeToMint(_sender, mintPfId, _itemId, mergeFee, bytes(_pfURI));\n    }\n\n    function _addProbCall(\n        address _sender,\n        uint _aienId,\n        uint[] memory _pf_Ids\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_aienId) == _sender,\n            \"not owner\"\n        );\n\n        require(__checkDuplicates(_pf_Ids) == false, \"duplicate pf id\");\n        require(\n            __checkERC721sOwner(_sender, _pf_Ids) == true,\n            \"not owner of perfriends\"\n        );\n        uint _gradeProb = __checkERC721sGrade(_pf_Ids);\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            s.p0_states.addProbFee * _pf_Ids.length\n        );\n\n        for (uint i = 0; i < _pf_Ids.length; i++) {\n            IERC721(s.contracts[\"perfriends\"]).burn(_pf_Ids[i]);\n            IDB(s.contracts[\"db\"]).subPfGrades(_pf_Ids[i]);\n        }\n\n        IDB.aien memory _AIEN = IDB(s.contracts[\"db\"]).AIENS(_aienId);\n        IDB(s.contracts[\"db\"]).setAienAll(\n            _aienId,\n            _AIEN.mixCount,\n            _AIEN.p2Level,\n            _AIEN.totalExp + (s.p0_states.addProbExp * _pf_Ids.length),\n            _AIEN.influExp,\n            _AIEN.baseProb,\n            0,\n            _AIEN.isPFid,\n            _AIEN.addProb + _gradeProb\n        );\n\n        emit MixCall(\n            _aienId,\n            2,\n            false,\n            _pf_Ids.length * s.p0_states.addProbFee\n        );\n    }\n\n    // internal functions\n    function __random(address _sender) internal returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // if (s.orakl  ? oraklVRF() : nativeRF())\n        bytes32 hash = keccak256(\n            abi.encodePacked(block.timestamp, _sender, block.coinbase)\n        );\n        return (uint(hash) % (s.p0_states.maxProb - 0 + 1)) + 0;\n    }\n\n    function __randomAddProb(\n        address _sender,\n        uint _max,\n        uint _min\n    ) internal returns (uint) {\n        // if (s.orakl  ? oraklVRF() : nativeRF())\n        bytes32 hash = keccak256(\n            abi.encodePacked(block.timestamp, _sender, block.coinbase)\n        );\n        return (uint(hash) % (_max - _min + 1)) + _min;\n    }\n\n    function __checkDuplicates(\n        uint[] memory array\n    ) internal pure returns (bool) {\n        for (uint i = 0; i < array.length - 1; i++) {\n            for (uint j = i + 1; j < array.length; j++) {\n                if (array[i] == array[j]) return true;\n            }\n        }\n        return false;\n    }\n\n    // 다중 ERC721 owner확인\n    function __checkERC721sOwner(\n        address _owner,\n        uint[] memory _ids\n    ) internal view returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        for (uint i = 0; i < _ids.length; i++) {\n            if (IERC721(s.contracts[\"perfriends\"]).ownerOf(_ids[i]) != _owner)\n                return false;\n        }\n        return true;\n    }\n\n    // 다중 ERC721의 등급별 mixPFInfos 합을 구한다.\n    function __checkERC721sGrade(\n        uint[] memory _ids\n    ) internal view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint _gradeProb = 0;\n        for (uint i = 0; i < _ids.length; i++) {\n            _gradeProb += s\n                .p0_perFriendsProbs[IDB(s.contracts[\"db\"]).PFS(_ids[i]).class]\n                .gradeProb;\n        }\n        return _gradeProb;\n    }\n}\n"
    },
    "contracts/shared/facets/DistributeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage, Modifiers} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {LibDistribute} from \"../libraries/LibDistribute.sol\";\n\ncontract DistributeFacet is Modifiers {\n    // 1차로 Distribute facet에 balance를 모으고\n    // 패싯이 변경되었을때 transfer하여 balance migrate하기 위한 함수\n    function Distribute_Transfer_Balance(\n        address _facet,\n        address _tokenAddr,\n        uint _amount\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        IERC20(_tokenAddr).transfer(msgsender, _amount);\n    }\n\n    function Distribute_p0LvUpDistribute(\n        address _agency,\n        uint _agencyAmount,\n        address _influencer,\n        uint _influencerAmount,\n        uint _totalAmount\n    ) external {\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyAmount,\n            _influencer,\n            _influencerAmount,\n            _totalAmount\n        );\n    }\n\n    function Distribute_swapToDistribute() external {\n        LibDistribute.swapToDistribute();\n    }\n}\n"
    },
    "contracts/shared/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/shared/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC1155 {\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function burn(address account, uint256 id, uint256 value) external;\n\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/shared/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n//import \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\n/* interface IERC721 is IERC165 { */\ninterface IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n\n    function burn(uint256 _tokenId) external;\n\n    function safeMintByMinter(address _to) external;\n\n    function nextTokenId() external view returns (uint256);\n}\n"
    },
    "contracts/shared/interfaces/IKlaySwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// 0xc6a2ad8cc6e4a7e08fc37cc5954be07d499e7654 KSP\n// 0x7A74B3be679E194E1D6A0C29A343ef8D2a5AC876 Util\ninterface IKlaySwap {\n    function estimateSwap(\n        address tokenIn,\n        address tokenOut,\n        uint amountIn,\n        address[] memory path\n    ) external view returns (uint amountOut);\n\n    function exchangeKctPos(\n        address tokenA,\n        uint amountA,\n        address tokenB,\n        uint amountB,\n        address[] memory path\n    ) external;\n}\n\n\n\n\n"
    },
    "contracts/shared/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {LibDiamond} from \"./LibDiamond.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {LibMeta} from \"./LibMeta.sol\";\n\n// i-Tez Structs\n//- P0 struct\nstruct P0_State {\n    uint24 maxProb;\n    // 퍼프렌즈를 이용한 PF POWER 변환시 개당 수수료\n    uint addProbFee;\n    // 퍼프렌즈를 이용한 PF POWER 변환시 획득 경험치\n    uint16 addProbExp;\n    // bool\n    bool isVRF;\n}\nstruct P0_PerFriendsProb {\n    string pfGrade;\n    uint24 gradeProb;\n}\n\nstruct P0_GradeInfo {\n    // 다음 level이 열렸는지 확인\n    bool isOpen;\n    // level별 mix fee\n    uint mixFee;\n    // 레벨업 성공시 level별 초기 base 확률\n    uint24 initBaseProb;\n    // level별 추가 확률 밸런스 조정값\n    uint16 mixExp;\n    // level별 합성 실패시 추가 확률 min,max\n    uint24 failedAddProbMin;\n    // 1000 = 0.1%, 10000 = 0.01%\n    uint24 failedAddProbMax;\n}\n\n// //- Distribute struct\nstruct Distribute_State {\n    uint beforeP2Usdt;\n    uint beforeP2Per;\n    uint beforeTeamUsdt;\n    // distribute ratios\n    uint24 p1Ratio;\n    uint24 p2PerRatio;\n    uint24 p2UsdtRatio;\n    uint24 burnRatio;\n    uint24 teamUsdtRatio;\n}\n\n// P0 End\nstruct AppStorage {\n    // address constants\n    mapping(string => address) contracts;\n    // i-Tez/////////////////////////////\n    // P0 ///////////////////////////////\n    P0_State p0_states;\n    P0_GradeInfo[11] p0_gradeInfos;\n    mapping(uint => P0_PerFriendsProb) p0_perFriendsProbs;\n    /////////////////////////////////////\n    // Distribute ///////////////////////\n    Distribute_State distribute_states;\n    uint aienMintFee;\n    // Distribute\n    uint ksSwapLimit;\n    bool isAutoDistribute;\n    //\n}\n\nlibrary LibAppStorage {\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\n        assembly {\n            ds.slot := 0\n        }\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x >= 0 ? x : -x);\n    }\n}\n\n/**\n@dev global modifier\n */\ncontract Modifiers {\n    AppStorage internal s;\n\n    modifier onlyDev() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n}\n"
    },
    "contracts/shared/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/shared/libraries/LibDistribute.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibDiamond} from \"./LibDiamond.sol\";\nimport {LibMeta} from \"./LibMeta.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\nimport {IKlaySwap} from \"../interfaces/IKlaySwap.sol\";\nimport {IP2} from \"../../Channel_iN/interfaces/IP2.sol\";\nimport {IP1} from \"../../Channel_iN/interfaces/IP1.sol\";\n\nlibrary LibDistribute {\n    //\n    //\n    // ─── P0 LV UP DISTRIBUTION ─────────────────────────────────────────────────────\n    function p0LvUpDistribute(\n        address _agency,\n        uint _agencyAmount,\n        address _influencer,\n        uint _influencerAmount,\n        uint _totalAmount\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        (\n            uint p1Amount,\n            uint p2Amount,\n            uint burnAmount,\n            uint teamAmountForUsdt,\n            uint p2AmountForUsdt\n        ) = distributeCalc(_totalAmount);\n        address per = s.contracts[\"per\"];\n\n        IERC20(per).transfer(_agency, _agencyAmount);\n        IERC20(per).transfer(_influencer, _influencerAmount);\n        IERC20(per).transfer(s.contracts[\"burn\"], burnAmount);\n        IERC20(per).transfer(s.contracts[\"p2\"], p2Amount);\n        IERC20(per).transfer(s.contracts[\"p1\"], p1Amount);\n\n        IP1(s.contracts[\"p1\"]).diamond_P1_addDistributionAmountAll(p1Amount);\n\n        // IERC20(PER).transfer(P1, )\n        // 추가 되어야할 것들\n        // 1.P1 10% PER\n        // 2.P2 20% PER\n        // 3.Burn 1% PER\n        s.distribute_states.beforeP2Per += p2Amount;\n        s.distribute_states.beforeP2Usdt += p2AmountForUsdt;\n        s.distribute_states.beforeTeamUsdt += teamAmountForUsdt;\n    }\n\n    function distributeCalc(\n        uint _amount\n    ) internal view returns (uint, uint, uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint _p1Amount = (_amount * s.distribute_states.p1Ratio) / 100;\n        uint _p2Amount = (_amount * s.distribute_states.p2PerRatio) / 100;\n        uint _burnAmount = (_amount * s.distribute_states.burnRatio) / 100;\n        uint _teamAmountForUsdt = (_amount *\n            s.distribute_states.teamUsdtRatio) / 100;\n        uint _p2AmountForUsdt = (_amount * s.distribute_states.p2UsdtRatio) /\n            100;\n        return (\n            _p1Amount,\n            _p2Amount,\n            _burnAmount,\n            _teamAmountForUsdt,\n            _p2AmountForUsdt\n        );\n    }\n\n    function swapToDistribute() internal {\n        (bool run, uint thisBalance, uint estimateUsdt) = isSwap();\n        require(run == true, \"swapToDistribute: swap is not needed\");\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        address[] memory path;\n\n        IERC20(s.contracts[\"per\"]).approve(\n            s.contracts[\"klayswap\"],\n            thisBalance\n        );\n\n        IKlaySwap(s.contracts[\"klayswap\"]).exchangeKctPos(\n            s.contracts[\"per\"],\n            thisBalance,\n            s.contracts[\"usdt\"],\n            estimateUsdt,\n            path\n        );\n\n        _swaplToCalculate();\n    }\n\n    function _swaplToCalculate() internal returns (uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint usdtBalance = IERC20(s.contracts[\"usdt\"]).balanceOf(address(this));\n        uint calculatePercent = s.distribute_states.p2UsdtRatio +\n            s.distribute_states.teamUsdtRatio;\n\n        uint _p2UsdtAmount = (usdtBalance * s.distribute_states.p2UsdtRatio) /\n            calculatePercent;\n        uint _teamUsdtAmount = (usdtBalance *\n            s.distribute_states.teamUsdtRatio) / calculatePercent;\n\n        IERC20(s.contracts[\"usdt\"]).transfer(s.contracts[\"p2\"], _p2UsdtAmount);\n\n        IERC20(s.contracts[\"usdt\"]).transfer(\n            s.contracts[\"team\"],\n            _teamUsdtAmount\n        );\n\n        IP2(s.contracts[\"p2\"]).addPerUsdtDistribution(\n            _p2UsdtAmount,\n            s.distribute_states.beforeP2Per\n        );\n\n        s.distribute_states.beforeP2Per = 0;\n        s.distribute_states.beforeP2Usdt = 0;\n        s.distribute_states.beforeTeamUsdt = 0;\n    }\n\n    function getDistributePrice() internal view returns (uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.distribute_states.beforeP2Usdt,\n            s.distribute_states.beforeP2Per,\n            s.distribute_states.beforeTeamUsdt\n        );\n    }\n\n    // function p0_transferForDistribute() internal returns (uint, uint, uint) {\n    //     AppStorage storage s = LibAppStorage.diamondStorage();\n    //     uint beforeP2Usdt = s.distribute_states.beforeP2Usdt;\n    //     uint beforeP2Per = s.distribute_states.beforeP2Per;\n    //     uint beforeTeamUsdt = s.distribute_states.beforeTeamUsdt;\n    //     address per = s.contracts[\"per\"];\n    //     // require(\n    //     //     LibMeta.msgSender() == LibDiamond.enforceIsContractOwner(),\n    //     //     \"you are not dev\"\n    //     // );\n    //     IERC20(per).transfer(\n    //         LibMeta.msgSender(),\n    //         beforeP2Usdt + beforeTeamUsdt\n    //     );\n    //     uint _beforeP2Usdt = beforeP2Usdt;\n    //     uint _beforeP2Per = beforeP2Per;\n    //     uint _beforeTeamUsdt = beforeTeamUsdt;\n\n    //     beforeP2Usdt = 0;\n    //     beforeP2Per = 0;\n    //     beforeTeamUsdt = 0;\n\n    //     return (_beforeP2Usdt, _beforeP2Per, _beforeTeamUsdt);\n    // }\n\n    function isSwap() internal view returns (bool, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address[] memory path;\n        uint _balance = IERC20(s.contracts[\"per\"]).balanceOf(address(this));\n\n        uint estimateUsdt = IKlaySwap(s.contracts[\"klayswaputil\"]).estimateSwap(\n            s.contracts[\"per\"],\n            s.contracts[\"usdt\"],\n            _balance,\n            path\n        );\n\n        if (estimateUsdt > s.ksSwapLimit && s.isAutoDistribute == true) {\n            return (true, _balance, estimateUsdt);\n        } else {\n            return (false, 0, 0);\n        }\n    }\n}\n"
    },
    "contracts/shared/libraries/LibMeta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nlibrary LibMeta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"\n            )\n        );\n\n    function domainSeparator(\n        string memory name,\n        string memory version\n    ) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}