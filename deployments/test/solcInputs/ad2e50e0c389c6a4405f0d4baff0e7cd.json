{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/channel_iN/ChanneliN.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../shared/libraries/LibDiamond.sol\";\nimport {IDiamondCut} from \"../shared/interfaces/IDiamondCut.sol\";\n\ncontract CHANNELIN {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = address(bytes20(ds.facets[msg.sig]));\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/channel_iN/facets/AdminFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\n\ncontract AdminFacet is Modifiers {\n    /**\n     *@dev P0 Admin functions\n     */\n    function admin_p0_setStates(\n        uint24 _maxProb,\n        uint _addProbFee,\n        uint16 _addProbExp,\n        bool _isVRF\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_states.maxProb = _maxProb;\n        s.p0_states.addProbFee = _addProbFee;\n        s.p0_states.addProbExp = _addProbExp;\n        s.p0_states.isVRF = _isVRF;\n    }\n\n    function admin_p0_setGradeInfos(\n        uint8 _gradeIndex,\n        bool _isOpen,\n        uint _mixFee,\n        uint24 _initBaseProb,\n        uint16 _mixExp,\n        uint24 _failedAddProbMin,\n        uint24 _failedAddProbMax\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_gradeInfos[_gradeIndex].isOpen = _isOpen;\n        s.p0_gradeInfos[_gradeIndex].mixFee = _mixFee;\n        s.p0_gradeInfos[_gradeIndex].initBaseProb = _initBaseProb;\n        s.p0_gradeInfos[_gradeIndex].mixExp = _mixExp;\n        s.p0_gradeInfos[_gradeIndex].failedAddProbMin = _failedAddProbMin;\n        s.p0_gradeInfos[_gradeIndex].failedAddProbMax = _failedAddProbMax;\n    }\n\n    function admin_p0_setPerFriendsProb(\n        uint _grade,\n        string memory _pfGrade,\n        uint24 _gradeProb\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.p0_perFriendsProbs[_grade].pfGrade = _pfGrade;\n        s.p0_perFriendsProbs[_grade].gradeProb = uint24(_gradeProb);\n    }\n\n    function admin_p0_getStates()\n        external\n        view\n        returns (uint24, uint, uint16, bool)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_states.maxProb,\n            s.p0_states.addProbFee,\n            s.p0_states.addProbExp,\n            s.p0_states.isVRF\n        );\n    }\n\n    function admin_p0_getGradeInfos(\n        uint8 _gradeIndex\n    ) external view returns (bool, uint, uint24, uint16, uint24, uint24) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_gradeInfos[_gradeIndex].isOpen,\n            s.p0_gradeInfos[_gradeIndex].mixFee,\n            s.p0_gradeInfos[_gradeIndex].initBaseProb,\n            s.p0_gradeInfos[_gradeIndex].mixExp,\n            s.p0_gradeInfos[_gradeIndex].failedAddProbMin,\n            s.p0_gradeInfos[_gradeIndex].failedAddProbMax\n        );\n    }\n\n    function admin_p0_getPerFriendsProb(\n        uint _grade\n    ) external view returns (string memory, uint24) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.p0_perFriendsProbs[_grade].pfGrade,\n            s.p0_perFriendsProbs[_grade].gradeProb\n        );\n    }\n\n    /**\n     *@dev P1 Admin functions\n     */\n\n    /**\n     *@dev DistriBute Admin functions\n     */\n\n    function admin_distribute_setStates(\n        uint24 _p1Ratio,\n        uint24 _p2PerRatio,\n        uint24 _p2UsdtRatio,\n        uint24 _burnRatio,\n        uint24 _teamUsdtRatio\n    ) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.distribute_states.p1Ratio = _p1Ratio;\n        s.distribute_states.p2PerRatio = _p2PerRatio;\n        s.distribute_states.p2UsdtRatio = _p2UsdtRatio;\n        s.distribute_states.burnRatio = _burnRatio;\n        s.distribute_states.teamUsdtRatio = _teamUsdtRatio;\n    }\n\n    function admin_distribute_getStates()\n        external\n        view\n        returns (uint24, uint24, uint24, uint24, uint24)\n    {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.distribute_states.p1Ratio,\n            s.distribute_states.p2PerRatio,\n            s.distribute_states.p2UsdtRatio,\n            s.distribute_states.burnRatio,\n            s.distribute_states.teamUsdtRatio\n        );\n    }\n\n\n    function testAdmins() external view returns (address) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return msg.sender;\n    }\n}\n"
    },
    "contracts/channel_iN/facets/MarketFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\n\ncontract MarketFacet is Modifiers {}\n"
    },
    "contracts/channel_iN/facets/P0Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {LibP0} from \"../libraries/LibP0.sol\";\n\n/**\n@dev i-TEZ : P0 (Mix) Facet Contract\n */\ncontract P0Facet is Modifiers {\n    function itemMerge(uint _itemId, uint _itemAmount) external {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        LibP0._itemMerge(msgsender, _itemId, _itemAmount);\n    }\n\n    function baseMixCall(uint _id, uint _useItemId) external returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        return LibP0._baseMixCall(msgsender, _id, _useItemId);\n    }\n\n    // function premiumMixCall(uint _id, uint _useItemId) external returns (bool) {\n    //     AppStorage storage s = LibAppStorage.diamondStorage();\n    //     address msgsender = LibMeta.msgSender();\n    //     LibP0._premiumMixCall(msgsender, _id, _useItemId);\n    // }\n\n    function addProbCall(\n        uint _aienId,\n        uint[] memory _pf_Ids\n    ) external returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        address msgsender = LibMeta.msgSender();\n        LibP0._addProbCall(msgsender, _aienId, _pf_Ids);\n    }\n}\n"
    },
    "contracts/channel_iN/facets/P1Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n"
    },
    "contracts/channel_iN/facets/P2Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n"
    },
    "contracts/channel_iN/facets/RubyonFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport \"../../shared/interfaces/Iitem.sol\";\n\ncontract RubyonFacet is Modifiers {\n    //\n    //\n    //\n    function rubyonMint(\n        address _addr,\n        uint _id,\n        uint _amount,\n        bytes memory _data\n    ) external returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        Iitem(s.contracts[\"item\"]).mint(_addr, _id, _amount, _data);\n\n        return true;\n    }\n}\n"
    },
    "contracts/channel_iN/interfaces/IDB.sol": {
      "content": "// legacy db contract interface\ninterface IDB {\n    struct pf {\n        uint id;\n        uint class;\n        bool isAien;\n        uint usedAienId;\n    }\n    struct aien {\n        uint id;\n        // 강화 횟수\n        uint mixCount;\n        //\n        uint p2Level;\n        // 토탈 경험치\n        uint totalExp;\n        // 미션 및, 인플루언서 활동 관련 경험치\n        uint influExp;\n        // 기본 확률\n        uint baseProb;\n        // 토탈 확률\n        uint totalProb;\n        // is PF\n        uint isPFid;\n        // 추가확률\n        uint addProb;\n    }\n\n    function AIENS(uint _key) external view returns (aien memory);\n\n    function PFS(uint _key) external view returns (pf memory);\n\n    function getAien(uint _id) external view;\n\n    function getPF(uint _id) external view;\n\n    function getPfGrade(uint _id) external view returns (uint);\n\n    function setAien(uint _id) external;\n\n    function usePFimg(uint _aienId, uint _pfId) external;\n\n    function setAienAll(\n        uint _id,\n        uint _mixCount,\n        uint _p2Level,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _totalProb,\n        uint _isPFid,\n        uint _addProb\n    ) external;\n\n    function getContractAddr(\n        string memory _name\n    ) external view returns (address);\n\n    function burnValue(uint _burnAmount) external;\n\n    function setAienGradeInfo(uint _toGrade) external;\n\n    function subPfGrades(uint _pfId) external;\n\n    function setLevelUpStatus(uint _toGrade) external;\n\n    function _failedAienSet(\n        uint _id,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _addProb\n    ) external;\n\n    function _successAienSet(\n        uint _id,\n        uint _p2Level,\n        uint _totalExp,\n        uint _influExp,\n        uint _baseProb,\n        uint _addProb\n    ) external;\n\n    function _mergeCalcul(\n        uint _itemId\n    ) external view returns (uint, address, uint, address, uint, uint);\n\n    function _mergeCalcul2(\n        uint _itemId\n    ) external view returns (uint, address, uint, address, uint, uint);\n\n    function _influencerMerge(\n        address _to,\n        uint _itemId,\n        uint _referralIncome\n    ) external returns (uint, string memory);\n\n    function _levelUpCalcul(\n        uint _itemId,\n        uint _fee\n    ) external returns (address, address, uint, uint);\n\n    function _levelUpSucess(uint _id, uint _p2Level) external;\n\n    function _levelUpFailed(uint _id, uint _addProb) external;\n\n    function _mergeCount(\n        address _agency,\n        uint _agencyFee,\n        address _influencer,\n        uint _influencerFee\n    ) external;\n}\n"
    },
    "contracts/channel_iN/libraries/LibP0.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\nimport {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\nimport {IDB} from \"../interfaces/IDB.sol\";\nimport {IERC721} from \"../../shared/interfaces/IERC721.sol\";\nimport {IERC1155} from \"../../shared/interfaces/IERC1155.sol\";\nimport {IERC20} from \"../../shared/interfaces/IERC20.sol\";\nimport {LibDistribute} from \"../../shared/libraries/LibDistribute.sol\";\n\nlibrary LibP0 {\n    // events\n    event MixCall(\n        uint indexed _tokenId,\n        uint indexed _mixType,\n        bool indexed isLevelUp,\n        uint price\n    );\n    event MergeToMint(\n        address indexed _to,\n        uint indexed _PerFriends_id,\n        uint indexed _Use_item_id,\n        uint _usePerAmount,\n        bytes _pfURI\n    );\n\n    function _baseMixCall(\n        address _sender,\n        uint _id,\n        uint _useItemId\n    ) internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        require(\n            IERC721(s.contracts[\"aien\"]).ownerOf(_id) == _sender,\n            \"not owner\"\n        );\n        IDB.aien memory _AIEN = IDB(s.contracts[\"db\"]).AIENS(_id);\n        // P0_GradeInfo memory _gradeInfo = s.p0_gradeInfos[_AIEN.p2Level];\n        // P0_GradeInfo memory _gradeInfoNext = s.p0_gradeInfos[_AIEN.p2Level + 1];\n\n        require(s.p0_gradeInfos[_AIEN.p2Level].isOpen == true, \"not open\");\n\n        (\n            address _influencer,\n            address _agency,\n            uint _influencerFee,\n            uint _agencyFee\n        ) = IDB(s.contracts[\"db\"])._levelUpCalcul(\n                _useItemId,\n                s.p0_gradeInfos[_AIEN.p2Level].mixFee\n            );\n\n        IERC1155(s.contracts[\"item\"]).burn(_sender, _useItemId, 1);\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        if (_AIEN.p2Level == 0) {\n            IDB(s.contracts[\"db\"])._levelUpSucess(_id, _AIEN.p2Level);\n            emit MixCall(_id, 0, true, s.p0_gradeInfos[_AIEN.p2Level].mixFee);\n\n            return true;\n        }\n\n        uint _random = __random(_sender);\n\n        // 성공시\n        if (_random <= _AIEN.baseProb) {\n            // 성공률 초기화\n            // 레벨 상승\n            IDB(s.contracts[\"db\"])._levelUpSucess(_id, _AIEN.p2Level);\n        } else {\n            // base성공률에 랜덤 성공률 추가\n\n            uint _randomAdd = __randomAddProb(\n                _sender,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMax,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMin\n            );\n            // 경험치 상승\n            // _AIEN[_id].baseProb += _randomAdd;\n\n            IDB(s.contracts[\"db\"])._levelUpFailed(_id, _randomAdd);\n        }\n\n        emit MixCall(\n            _id,\n            0,\n            _random <= _AIEN.baseProb,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        return true;\n    }\n\n    function _premiumMixCall(\n        address _sender,\n        uint _aienId,\n        uint _useItemId\n    ) internal returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        IDB.aien memory _AIEN = IDB(s.contracts[\"db\"]).AIENS(_aienId);\n\n        require(_AIEN.p2Level != 0, \"not premium level\");\n        require(s.p0_gradeInfos[_AIEN.p2Level].isOpen == true, \"not open\");\n\n        (\n            address _influencer,\n            address _agency,\n            uint _influencerFee,\n            uint _agencyFee\n        ) = IDB(s.contracts[\"db\"])._levelUpCalcul(\n                _useItemId,\n                s.p0_gradeInfos[_AIEN.p2Level].mixFee\n            );\n\n        IERC1155(s.contracts[\"item\"]).burn(_sender, _useItemId, 1);\n\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        uint _random = __random(_sender);\n        uint totalProb = 0;\n        if (_AIEN.baseProb + _AIEN.addProb > _random) {\n            totalProb = _AIEN.baseProb + _AIEN.addProb - s.p0_states.maxProb;\n        }\n\n        if (_AIEN.baseProb + _AIEN.addProb >= _random) {\n            // 성공률 초기화\n            // 레벨 상승\n            IDB(s.contracts[\"db\"])._successAienSet(\n                _aienId,\n                _AIEN.p2Level + 1,\n                _AIEN.totalExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                _AIEN.influExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                s.p0_gradeInfos[_AIEN.p2Level].initBaseProb,\n                totalProb\n            );\n        } else {\n            uint _randomAdd = __randomAddProb(\n                _sender,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMax,\n                s.p0_gradeInfos[_AIEN.p2Level].failedAddProbMin\n            );\n\n            IDB(s.contracts[\"db\"])._failedAienSet(\n                _aienId,\n                _AIEN.totalExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                _AIEN.influExp + s.p0_gradeInfos[_AIEN.p2Level].mixExp,\n                _AIEN.baseProb + _randomAdd,\n                totalProb\n            );\n        }\n\n        emit MixCall(\n            _aienId,\n            1,\n            _AIEN.baseProb + _AIEN.addProb >= _random,\n            s.p0_gradeInfos[_AIEN.p2Level].mixFee\n        );\n\n        return true;\n    }\n\n    function _itemMerge(\n        address _sender,\n        uint _itemId,\n        uint _itemAmount\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint mergeFee;\n        address _influencer;\n        uint _influencerFee;\n        address _agency;\n        uint _agencyFee;\n        uint _influencerItemAmount;\n\n        if (_itemId <= 50) {\n            (\n                mergeFee,\n                _influencer,\n                _influencerFee,\n                _agency,\n                _agencyFee,\n                _influencerItemAmount\n            ) = IDB(s.contracts[\"db\"])._mergeCalcul(_itemId);\n        } else {\n            (\n                mergeFee,\n                _influencer,\n                _influencerFee,\n                _agency,\n                _agencyFee,\n                _influencerItemAmount\n            ) = IDB(s.contracts[\"db\"])._mergeCalcul2(_itemId);\n        }\n\n        require(_itemAmount == _influencerItemAmount);\n\n        // merge 할때 카운트 적용 함수\n        IDB(s.contracts[\"db\"])._mergeCount(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee\n        );\n        //\n        IERC1155(s.contracts[\"item\"]).burn(_sender, _itemId, _itemAmount);\n\n        // IERC20(PER).transferFrom(msg.sender, address(this), mergeFee);\n        IERC20(s.contracts[\"per\"]).transferFrom(\n            _sender,\n            s.contracts[\"distribute\"],\n            mergeFee\n        );\n\n        LibDistribute.p0LvUpDistribute(\n            _agency,\n            _agencyFee,\n            _influencer,\n            _influencerFee,\n            mergeFee\n        );\n\n        (uint mintPfId, string memory _pfURI) = IDB(s.contracts[\"db\"])\n            ._influencerMerge(_sender, _itemId, 0);\n        emit MergeToMint(_sender, mintPfId, _itemId, mergeFee, bytes(_pfURI));\n    }\n\n    function _addProbCall(\n        address _sender,\n        uint _aienId,\n        uint[] memory _pf_Ids\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n    }\n\n    // internal functions\n    function __random(address _sender) internal returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        // if (s.orakl  ? oraklVRF() : nativeRF())\n        bytes32 hash = keccak256(\n            abi.encodePacked(block.timestamp, _sender, block.coinbase)\n        );\n        return (uint(hash) % (s.p0_states.maxProb - 0 + 1)) + 0;\n    }\n\n    function __randomAddProb(\n        address _sender,\n        uint _max,\n        uint _min\n    ) internal returns (uint) {\n        // if (s.orakl  ? oraklVRF() : nativeRF())\n        bytes32 hash = keccak256(\n            abi.encodePacked(block.timestamp, _sender, block.coinbase)\n        );\n        return (uint(hash) % (_max - _min + 1)) + _min;\n    }\n\n    function __checkDuplicates(\n        uint[] memory array\n    ) internal pure returns (bool) {\n        for (uint i = 0; i < array.length - 1; i++) {\n            for (uint j = i + 1; j < array.length; j++) {\n                if (array[i] == array[j]) return true;\n            }\n        }\n        return false;\n    }\n\n    // 다중 ERC721 owner확인\n    function __checkERC721sOwner(\n        address _owner,\n        uint[] memory _ids\n    ) internal view returns (bool) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        for (uint i = 0; i < _ids.length; i++) {\n            if (IERC721(s.contracts[\"perfriends\"]).ownerOf(_ids[i]) != _owner)\n                return false;\n        }\n        return true;\n    }\n\n    // 다중 ERC721의 등급별 mixPFInfos 합을 구한다.\n    function __checkERC721sGrade(\n        uint[] memory _ids\n    ) internal view returns (uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint _gradeProb = 0;\n        for (uint i = 0; i < _ids.length; i++) {\n            _gradeProb += s\n                .p0_perFriendsProbs[IDB(s.contracts[\"db\"]).PFS(_ids[i]).class]\n                .gradeProb;\n        }\n        return _gradeProb;\n    }\n}\n"
    },
    "contracts/channel_iN/libraries/LibP1.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\n// pragma solidity ^0.8.22;\n\n// import {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\n// import {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\n// import {IDB} from \"../interfaces/IDB.sol\";\n// import {IERC721} from \"../../shared/interfaces/IERC721.sol\";\n\n// library LibP1 {\n//     // events\n//     event MixCall(\n//         uint indexed _tokenId,\n//         uint indexed _mixType,\n//         bool indexed isLevelUp,\n//         uint price\n//     );\n//     event MergeToMint(\n//         address indexed _to,\n//         uint indexed _PerFriends_id,\n//         uint indexed _Use_item_id,\n//         uint _usePerAmount,\n//         bytes _pfURI\n//     );\n\n//     function _baseMixCall(address _sender, uint _id, uint _useItemId) internal {\n//         AppStorage storage s = LibAppStorage.diamondStorage();\n//         require(\n//             IERC721(s.contracts[\"aien\"].ownerOf(_id)) == _sender,\n//             \"not owner\"\n//         );\n//     }\n\n//     function _premiumMixCall() internal {}\n\n//     function _itemMerge(\n//         address _sender,\n//         uint _itemId,\n//         uint _itemAmount\n//     ) internal {}\n\n//     function _addProbCall(uint _aienId, uint[] memory _pf_Ids) internal {}\n\n//     // internal functions\n//     function __random(address _sender) internal returns (uint) {\n//         // if (s.orakl  ? oraklVRF() : nativeRF())\n//         bytes32 hash = keccak256(\n//             abi.encodePacked(block.timestamp, _sender, block.coinbase)\n//         );\n//         return (uint(hash) % (maxProb - 0 + 1)) + 0;\n//     }\n\n//     function __randomAddProb(\n//         address _sender,\n//         uint _max,\n//         uint _min\n//     ) internal returns (uint) {\n//         // if (s.orakl  ? oraklVRF() : nativeRF())\n//         bytes32 hash = keccak256(\n//             abi.encodePacked(block.timestamp, _sender, block.coinbase)\n//         );\n//         return (uint(hash) % (_max - _min + 1)) + _min;\n//     }\n\n//     function __checkDuplicates(\n//         uint[] memory array\n//     ) internal pure returns (bool) {\n//         for (uint i = 0; i < array.length - 1; i++) {\n//             for (uint j = i + 1; j < array.length; j++) {\n//                 if (array[i] == array[j]) return true;\n//             }\n//         }\n//         return false;\n//     }\n\n//     // 다중 ERC721 owner확인\n//     function __checkERC721sOwner(\n//         address _owner,\n//         address _contract,\n//         uint[] memory _ids\n//     ) internal view returns (bool) {\n//         for (uint i = 0; i < _ids.length; i++) {\n//             if (IERC721(_contract).ownerOf(_ids[i]) != _owner) return false;\n//         }\n//         return true;\n//     }\n\n//     // 다중 ERC721의 등급별 mixPFInfos 합을 구한다.\n//     function __checkERC721sGrade(\n//         uint[] memory _ids\n//     ) internal view returns (uint) {\n//         uint _gradeProb = 0;\n//         for (uint i = 0; i < _ids.length; i++) {\n//             _gradeProb += mixPFInfos[IDB(DB).PFS(_ids[i]).class].gradeProb;\n//         }\n//         return _gradeProb;\n//     }\n// }\n"
    },
    "contracts/channel_iN/libraries/LibP2.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\n// pragma solidity ^0.8.22;\n\n// import {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\n// import {LibMeta} from \"../../shared/libraries/LibMeta.sol\";\n// import {IDB} from \"../interfaces/IDB.sol\";\n// import {IERC721} from \"../../shared/interfaces/IERC721.sol\";\n\n// library LibP2 {\n//     // events\n//     event MixCall(\n//         uint indexed _tokenId,\n//         uint indexed _mixType,\n//         bool indexed isLevelUp,\n//         uint price\n//     );\n//     event MergeToMint(\n//         address indexed _to,\n//         uint indexed _PerFriends_id,\n//         uint indexed _Use_item_id,\n//         uint _usePerAmount,\n//         bytes _pfURI\n//     );\n\n//     function _baseMixCall(address _sender, uint _id, uint _useItemId) internal {\n//         AppStorage storage s = LibAppStorage.diamondStorage();\n//         require(\n//             IERC721(s.contracts[\"aien\"].ownerOf(_id)) == _sender,\n//             \"not owner\"\n//         );\n//     }\n\n//     function _premiumMixCall() internal {}\n\n//     function _itemMerge(\n//         address _sender,\n//         uint _itemId,\n//         uint _itemAmount\n//     ) internal {}\n\n//     function _addProbCall(uint _aienId, uint[] memory _pf_Ids) internal {}\n\n//     // internal functions\n//     function __random(address _sender) internal returns (uint) {\n//         // if (s.orakl  ? oraklVRF() : nativeRF())\n//         bytes32 hash = keccak256(\n//             abi.encodePacked(block.timestamp, _sender, block.coinbase)\n//         );\n//         return (uint(hash) % (maxProb - 0 + 1)) + 0;\n//     }\n\n//     function __randomAddProb(\n//         address _sender,\n//         uint _max,\n//         uint _min\n//     ) internal returns (uint) {\n//         // if (s.orakl  ? oraklVRF() : nativeRF())\n//         bytes32 hash = keccak256(\n//             abi.encodePacked(block.timestamp, _sender, block.coinbase)\n//         );\n//         return (uint(hash) % (_max - _min + 1)) + _min;\n//     }\n\n//     function __checkDuplicates(\n//         uint[] memory array\n//     ) internal pure returns (bool) {\n//         for (uint i = 0; i < array.length - 1; i++) {\n//             for (uint j = i + 1; j < array.length; j++) {\n//                 if (array[i] == array[j]) return true;\n//             }\n//         }\n//         return false;\n//     }\n\n//     // 다중 ERC721 owner확인\n//     function __checkERC721sOwner(\n//         address _owner,\n//         address _contract,\n//         uint[] memory _ids\n//     ) internal view returns (bool) {\n//         for (uint i = 0; i < _ids.length; i++) {\n//             if (IERC721(_contract).ownerOf(_ids[i]) != _owner) return false;\n//         }\n//         return true;\n//     }\n\n//     // 다중 ERC721의 등급별 mixPFInfos 합을 구한다.\n//     function __checkERC721sGrade(\n//         uint[] memory _ids\n//     ) internal view returns (uint) {\n//         uint _gradeProb = 0;\n//         for (uint i = 0; i < _ids.length; i++) {\n//             _gradeProb += mixPFInfos[IDB(DB).PFS(_ids[i]).class].gradeProb;\n//         }\n//         return _gradeProb;\n//     }\n// }\n"
    },
    "contracts/shared/facets/ConstantFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {AppStorage, Modifiers, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\n\ncontract ConstantFacet is Modifiers {\n    function getContract(string memory _name) external view returns (address) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return s.contracts[_name];\n    }\n\n    function setContract(string memory _name, address _addr) external onlyDev {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        s.contracts[_name] = _addr;\n    }\n}\n"
    },
    "contracts/shared/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamond.initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "contracts/shared/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { LibDiamond } from  \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external override view returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facets_ = new Facet[](ds.selectorCount);\n        uint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(ds.facets[selector]));\n                if (_facet == facet) {\n                    _facetFunctionSelectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = new address[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {                    \n                    continue;\n                }\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts/shared/facets/DistributeFacet.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.22;\n\n// import {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\n// import {IERC20} from \"../../shared/interfaces/IERC20.sol\";\n\n// contract DistributeFacet {\n//     //\n//     //\n\n//     function p0LvUpDistribute(\n//         address _agency,\n//         uint _agencyAmount,\n//         address _influencer,\n//         uint _influencerAmount,\n//         uint _totalAmount\n//     ) external {\n//         AppStorage storage s = LibAppStorage.diamondStorage();\n//         (\n//             uint p1Amount,\n//             uint p2Amount,\n//             uint burnAmount,\n//             uint teamAmountForUsdt,\n//             uint p2AmountForUsdt\n//         ) = distributeCalc(_totalAmount);\n//         address memory per = s.contracts[\"per\"];\n\n//         IERC20(per).transfer(_agency, _agencyAmount);\n//         IERC20(per).transfer(_influencer, _influencerAmount);\n//         IERC20(per).transfer(s.contracts[\"burn\"], burnAmount);\n//         IERC20(per).transfer(s.contracts[\"p2\"], p2Amount);\n//         IERC20(per).transfer(s.contracts[\"p1\"], p1Amount);\n\n//         // IERC20(PER).transfer(P1, )\n//         // 추가 되어야할 것들\n//         // 1.P1 10% PER\n//         // 2.P2 20% PER\n//         // 3.Burn 1% PER\n//         beforeP2Per += p2Amount;\n//         beforeP2Usdt += p2AmountForUsdt;\n//         beforeTeamUsdt += teamAmountForUsdt;\n//     }\n\n//     function distributeCalc(\n//         uint _amount\n//     ) public view returns (uint, uint, uint, uint, uint) {\n//         uint _p1Amount = (_amount * 10) / 100;\n//         uint _p2Amount = (_amount * 20) / 100;\n//         uint _burnAmount = (_amount * 1) / 100;\n//         uint _teamAmountForUsdt = (_amount * 9) / 100;\n//         uint _p2AmountForUsdt = (_amount * 50) / 100;\n//         return (\n//             _p1Amount,\n//             _p2Amount,\n//             _burnAmount,\n//             _teamAmountForUsdt,\n//             _p2AmountForUsdt\n//         );\n//     }\n\n//     // function exchangeWithDistribute() public onlyOwner {\n//     //     IEstimate(KLAYSWAP_Util).estimateSwap(PER, );\n//     // \t//\n//     // \t//\n//     // \t//\n//     // \t//\n//     // }\n\n//     function getDistributePrice() external view returns (uint, uint, uint) {\n//         return (beforeP2Usdt, beforeP2Per, beforeTeamUsdt);\n//     }\n\n//     function exit() external onlyOwner returns (uint, uint, uint) {\n//         IERC20(PER).transfer(msg.sender, beforeP2Usdt + beforeTeamUsdt);\n//         uint _beforeP2Usdt = beforeP2Usdt;\n//         uint _beforeP2Per = beforeP2Per;\n//         uint _beforeTeamUsdt = beforeTeamUsdt;\n\n//         beforeP2Usdt = 0;\n//         beforeP2Per = 0;\n//         beforeTeamUsdt = 0;\n\n//         return (_beforeP2Usdt, _beforeP2Per, _beforeTeamUsdt);\n//     }\n// }\n"
    },
    "contracts/shared/facets/Orakl_DataFeedFacet.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.22;\n\n// import {IAggregator} from \"@bisonai/orakl-contracts/src/v0.1/interfaces/IAggregator.sol\";\n// import {AppStorage, LibAppStorage} from \"../../shared/libraries/LibAppStorage.sol\";\n\n// contract PriceFeedFacet {\n//     function getLatestData(address _proxy) public returns (int256) {\n//         AppStorage storage s = LibAppStorage.diamondStorage();\n\n//         IAggregator dataFeed = IAggregator(_proxy);\n//         (\n//             uint80 roundId_,\n//             int256 answer_ /* uint startedAt */ /* uint updatedAt */ /* uint80 answeredInRound */,\n//             ,\n//             ,\n\n//         ) = dataFeed.latestRoundData();\n\n//         s.orakl.answer = answer_;\n//         s.orakl.roundId = roundId_;\n\n//         return answer_;\n//     }\n\n//     function decimals(address _proxy) public view returns (uint8) {\n//         IAggregator dataFeed = IAggregator(_proxy);\n//         return dataFeed.decimals();\n//     }\n// }\n"
    },
    "contracts/shared/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n}\n"
    },
    "contracts/shared/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/shared/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/shared/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC1155 {\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function isApprovedForAll(\n        address account,\n        address operator\n    ) external view returns (bool);\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function burn(address account, uint256 id, uint256 value) external;\n\n    function balanceOf(\n        address account,\n        uint256 id\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/shared/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/shared/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n//import \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\n/* interface IERC721 is IERC165 { */\ninterface IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "contracts/shared/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/shared/interfaces/Iitem.sol": {
      "content": "// SPDX-License-Identifier: None\npragma solidity ^0.8.22;\n\ninterface Iitem {\n    function mint(\n        address _addr,\n        uint _id,\n        uint _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "contracts/shared/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {LibDiamond} from \"./LibDiamond.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {LibMeta} from \"./LibMeta.sol\";\n\n// i-Tez Structs\n//- P0 struct\nstruct P0_State {\n    uint24 maxProb;\n    // 퍼프렌즈를 이용한 PF POWER 변환시 개당 수수료\n    uint addProbFee;\n    // 퍼프렌즈를 이용한 PF POWER 변환시 획득 경험치\n    uint16 addProbExp;\n    // bool\n    bool isVRF;\n}\nstruct P0_PerFriendsProb {\n    string pfGrade;\n    uint24 gradeProb;\n}\n\nstruct P0_GradeInfo {\n    // 다음 level이 열렸는지 확인\n    bool isOpen;\n    // level별 mix fee\n    uint mixFee;\n    // 레벨업 성공시 level별 초기 base 확률\n    uint24 initBaseProb;\n    // level별 추가 확률 밸런스 조정값\n    uint16 mixExp;\n    // level별 합성 실패시 추가 확률 min,max\n    uint24 failedAddProbMin;\n    // 1000 = 0.1%, 10000 = 0.01%\n    uint24 failedAddProbMax;\n}\n\n// //- Distribute struct\nstruct Distribute_State {\n    uint beforeP2Usdt;\n    uint beforeP2Per;\n    uint beforeTeamUsdt;\n    // distribute ratios\n    uint24 p1Ratio;\n    uint24 p2PerRatio;\n    uint24 p2UsdtRatio;\n    uint24 burnRatio;\n    uint24 teamUsdtRatio;\n}\n\n// P0 End\nstruct AppStorage {\n    // address constants\n    mapping(string => address) contracts;\n    // i-Tez/////////////////////////////\n    // P0 ///////////////////////////////\n    P0_State p0_states;\n    P0_GradeInfo[11] p0_gradeInfos;\n    mapping(uint => P0_PerFriendsProb) p0_perFriendsProbs;\n    /////////////////////////////////////\n    // Distribute ///////////////////////\n    Distribute_State distribute_states;\n}\n\nlibrary LibAppStorage {\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\n        assembly {\n            ds.slot := 0\n        }\n    }\n\n    function abs(int256 x) internal pure returns (uint256) {\n        return uint256(x >= 0 ? x : -x);\n    }\n}\n\n/**\n@dev global modifier\n */\ncontract Modifiers {\n    AppStorage internal s;\n\n    modifier onlyDev() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n}\n"
    },
    "contracts/shared/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/shared/libraries/LibDistribute.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport {AppStorage, LibAppStorage} from \"./LibAppStorage.sol\";\nimport {LibDiamond} from \"./LibDiamond.sol\";\nimport {LibMeta} from \"./LibMeta.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\nlibrary LibDistribute {\n    //\n    //\n    // ─── P0 LV UP DISTRIBUTION ─────────────────────────────────────────────────────\n    function p0LvUpDistribute(\n        address _agency,\n        uint _agencyAmount,\n        address _influencer,\n        uint _influencerAmount,\n        uint _totalAmount\n    ) internal {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        (\n            uint p1Amount,\n            uint p2Amount,\n            uint burnAmount,\n            uint teamAmountForUsdt,\n            uint p2AmountForUsdt\n        ) = distributeCalc(_totalAmount);\n        address per = s.contracts[\"per\"];\n\n        // IERC20(per).transfer(_agency, _agencyAmount);\n        // IERC20(per).transfer(_influencer, _influencerAmount);\n        IERC20(per).transfer(_agency, _agencyAmount);\n        IERC20(per).transfer(_influencer, _influencerAmount);\n        IERC20(per).transfer(s.contracts[\"burn\"], burnAmount);\n        IERC20(per).transfer(s.contracts[\"p2\"], p2Amount);\n        IERC20(per).transfer(s.contracts[\"p1\"], p1Amount);\n\n        // IERC20(PER).transfer(P1, )\n        // 추가 되어야할 것들\n        // 1.P1 10% PER\n        // 2.P2 20% PER\n        // 3.Burn 1% PER\n        s.distribute_states.beforeP2Per += p2Amount;\n        s.distribute_states.beforeP2Usdt += p2AmountForUsdt;\n        s.distribute_states.beforeTeamUsdt += teamAmountForUsdt;\n    }\n\n    function distributeCalc(\n        uint _amount\n    ) internal view returns (uint, uint, uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n\n        uint _p1Amount = (_amount * s.distribute_states.p1Ratio) / 100;\n        uint _p2Amount = (_amount * s.distribute_states.p2PerRatio) / 100;\n        uint _burnAmount = (_amount * s.distribute_states.burnRatio) / 100;\n        uint _teamAmountForUsdt = (_amount *\n            s.distribute_states.teamUsdtRatio) / 100;\n        uint _p2AmountForUsdt = (_amount * s.distribute_states.p2UsdtRatio) /\n            100;\n        return (\n            _p1Amount,\n            _p2Amount,\n            _burnAmount,\n            _teamAmountForUsdt,\n            _p2AmountForUsdt\n        );\n    }\n\n    // function exchangeWithDistribute() public onlyOwner {\n    //     IEstimate(KLAYSWAP_Util).estimateSwap(PER, );\n    // \t//\n    // \t//\n    // \t//\n    // \t//\n    // }\n\n    function getDistributePrice() internal view returns (uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        return (\n            s.distribute_states.beforeP2Usdt,\n            s.distribute_states.beforeP2Per,\n            s.distribute_states.beforeTeamUsdt\n        );\n    }\n\n    function p0_transferForDistribute() internal returns (uint, uint, uint) {\n        AppStorage storage s = LibAppStorage.diamondStorage();\n        uint beforeP2Usdt = s.distribute_states.beforeP2Usdt;\n        uint beforeP2Per = s.distribute_states.beforeP2Per;\n        uint beforeTeamUsdt = s.distribute_states.beforeTeamUsdt;\n        address per = s.contracts[\"per\"];\n        // require(\n        //     LibMeta.msgSender() == LibDiamond.enforceIsContractOwner(),\n        //     \"you are not dev\"\n        // );\n        IERC20(per).transfer(\n            LibMeta.msgSender(),\n            beforeP2Usdt + beforeTeamUsdt\n        );\n        uint _beforeP2Usdt = beforeP2Usdt;\n        uint _beforeP2Per = beforeP2Per;\n        uint _beforeTeamUsdt = beforeTeamUsdt;\n\n        beforeP2Usdt = 0;\n        beforeP2Per = 0;\n        beforeTeamUsdt = 0;\n\n        return (_beforeP2Usdt, _beforeP2Per, _beforeTeamUsdt);\n    }\n}\n"
    },
    "contracts/shared/libraries/LibMeta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nlibrary LibMeta {\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"\n            )\n        );\n\n    function domainSeparator(\n        string memory name,\n        string memory version\n    ) internal view returns (bytes32 domainSeparator_) {\n        domainSeparator_ = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                getChainID(),\n                address(this)\n            )\n        );\n    }\n\n    function getChainID() internal view returns (uint256 id) {\n        assembly {\n            id := chainid()\n        }\n    }\n\n    function msgSender() internal view returns (address sender_) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender_ := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n        } else {\n            sender_ = msg.sender;\n        }\n    }\n}\n"
    },
    "contracts/shared/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {    \n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init() external {\n        // adding ERC165 data\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // add your own state variables \n        // EIP-2535 specifies that the `diamondCut` function takes two optional \n        // arguments: address _init and bytes calldata _calldata\n        // These arguments are used to execute an arbitrary function using delegatecall\n        // in order to set state variables in the diamond during deployment or an upgrade\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \n    }\n\n\n}\n"
    },
    "contracts/tokens/aien/Aien.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.9;\n\n// import \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\";\n\n// contract AienTest is ERC721Upgradeable, PausableUpgradeable, OwnableUpgradeable, ERC721BurnableUpgradeable, UUPSUpgradeable {\n//     using CountersUpgradeable for CountersUpgradeable.Counter;\n\n//     CountersUpgradeable.Counter private _tokenIdCounter;\n    \n//     string public strUri;\n//     address public minter;\n\n    \n//     modifier onlyMinter() {\n//         require(msg.sender == minter, \"not minter\");\n//         _;\n//     }\n\n//     /// @custom:oz-upgrades-unsafe-allow constructor\n//     constructor() {\n//         _disableInitializers();\n//     }\n\n//     function initialize() public initializer {\n//         __ERC721_init(\"Aien\", \"Aien\");\n//         __Pausable_init();\n//         __Ownable_init();\n//         __ERC721Burnable_init();\n//         __UUPSUpgradeable_init();\n\n\n//         _tokenIdCounter._value = 1;\n//     }\n\n//     function _baseURI() internal view override returns (string memory) {\n//         return  strUri;\n//     }\n\n//     function pause() public onlyOwner {\n//         _pause();\n//     }\n\n//     function unpause() public onlyOwner {\n//         _unpause();\n//     }\n\n//     // NFT 민팅 하기 (Owner로 민트)\n//     function safeMint(address to) public onlyOwner {\n//         uint256 tokenId = _tokenIdCounter.current();\n//         _tokenIdCounter.increment();\n//         _safeMint(to, tokenId);\n//     }\n\n//     // NFT 민팅 하기 (Minter로 민트)\n//     function safeMintByMinter(address to) public onlyMinter {\n//         uint256 tokenId = _tokenIdCounter.current();\n//         _tokenIdCounter.increment();\n//         _safeMint(to, tokenId);\n//     }\n\n//     function nextTokenId() public view returns (uint256) {\n//         return _tokenIdCounter.current();\n//     }\n\n//     function _beforeTokenTransfer(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         uint256 batchSize\n//     ) internal  whenNotPaused override {\n//         super._beforeTokenTransfer(from, to, tokenId, batchSize);\n//     }\n\n//     function _authorizeUpgrade(address newImplementation) internal onlyOwner override {\n//     }\n\n//     // The following functions are overrides required by Solidity.\n//     function _burn(uint256 tokenId) internal override(ERC721Upgradeable) {\n//         super._burn(tokenId);\n//     }\n\n//     function setURI(string memory _uri) public onlyOwner {\n//         strUri = _uri;\n//     }\n\n//     function setMinter(address _minter) public onlyOwner {\n//         minter = _minter;\n//     }\n\n//     function tokenURI(uint256 tokenId)\n//         public\n//         view\n//         override(ERC721Upgradeable)\n//         returns (string memory)\n//     {\n//         return super.tokenURI(tokenId);\n//     }\n\n//     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable) returns (bool) {\n//         return super.supportsInterface(interfaceId);\n//     }\n// }\n"
    },
    "contracts/tokens/channel_in_item/channel_in_item_V1.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity ^0.8.9;\n\n// import '@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol';\n// import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\n// import '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\n// import '@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155BurnableUpgradeable.sol';\n// import '@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol';\n// import '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';\n\n// interface IDB {\n// \tfunction influencerMint(uint _amount, uint _itemId, bytes calldata _data) external;\n// }\n\n// contract channel_in_item_V1 is\n// \tInitializable,\n// \tERC1155Upgradeable,\n// \tOwnableUpgradeable,\n// \tPausableUpgradeable,\n// \tERC1155BurnableUpgradeable,\n// \tERC1155SupplyUpgradeable\n// {\n// \tmapping(address => bool) public blackList;\n\n// \t/// @custom:oz-upgrades-unsafe-allow constructor\n// \tconstructor() {\n// \t\t_disableInitializers();\n// \t}\n\n// \tfunction initialize() public initializer {\n// \t\t__ERC1155_init('');\n// \t\t__Ownable_init();\n// \t\t__Pausable_init();\n// \t\t__ERC1155Burnable_init();\n// \t\t__ERC1155Supply_init();\n// \t}\n\n// \tfunction setURI(string memory newuri) public onlyOwner {\n// \t\t_setURI(newuri);\n// \t}\n\n// \tfunction pause() public onlyOwner {\n// \t\t_pause();\n// \t}\n\n// \tfunction unpause() public onlyOwner {\n// \t\t_unpause();\n// \t}\n\n// \tfunction mint(address account, uint256 id, uint256 amount, bytes memory data) public onlyOwner {\n// \t\t_mint(account, id, amount, data);\n\n// \t\t// unkwon contract\n// \t\t// IDB(address(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512)).influencerMint(amount, id, data);\n\n// \t\tif (id > 50) {\n// \t\t\t// // mainnet contract\n// \t\t\tIDB(address(0x0967358cB6a94aCF45A99Fb4ED199C081bbe2121)).influencerMint(amount, id, data);\n\n// \t\t\t// test contract\n// \t\t\t// IDB(address(0x4f47CF617Cdd6eA9d1b235Af05650cd0e83B8C62)).influencerMint(amount, id, data);\n// \t\t}\n// \t}\n\n// \tfunction mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public onlyOwner {\n// \t\t_mintBatch(to, ids, amounts, data);\n// \t}\n\n// \tfunction _beforeTokenTransfer(\n// \t\taddress operator,\n// \t\taddress from,\n// \t\taddress to,\n// \t\tuint256[] memory ids,\n// \t\tuint256[] memory amounts,\n// \t\tbytes memory data\n// \t) internal override(ERC1155Upgradeable, ERC1155SupplyUpgradeable) whenNotPaused {\n// \t\trequire(!blackList[from] && !blackList[operator] && !blackList[to], 'blackList User');\n// \t\tsuper._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n// \t}\n\n// \tfunction _setBlackList(address _user, bool _bool) public onlyOwner {\n// \t\tblackList[_user] = _bool;\n// \t}\n// }\n"
    },
    "contracts/tokens/pen/pen.sol": {
      "content": "// pragma solidity ^0.5.0;\n\n\n// // address : 0xa37ac8c6b92ffe18b6826395af7c44c89e334de3\n// // network : cypress\n\n// /*\n//  * @dev Provides information about the current execution context, including the\n//  * sender of the transaction and its data. While these are generally available\n//  * via msg.sender and msg.data, they should not be accessed in such a direct\n//  * manner, since when dealing with GSN meta-transactions the account sending and\n//  * paying for execution may not be the actual sender (as far as an application\n//  * is concerned).\n//  *\n//  * This contract is only required for intermediate, library-like contracts.\n//  */\n// contract Context {\n//     // Empty internal constructor, to prevent people from mistakenly deploying\n//     // an instance of this contract, which should be used via inheritance.\n//     constructor() internal {}\n\n//     // solhint-disable-previous-line no-empty-blocks\n\n//     function _msgSender() internal view returns (address payable) {\n//         return msg.sender;\n//     }\n\n//     function _msgData() internal view returns (bytes memory) {\n//         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n//         return msg.data;\n//     }\n// }\n\n// /**\n//  * @dev Contract module which provides a basic access control mechanism, where\n//  * there is an account (an owner) that can be granted exclusive access to\n//  * specific functions.\n//  *\n//  * This module is used through inheritance. It will make available the modifier\n//  * `onlyOwner`, which can be applied to your functions to restrict their use to\n//  * the owner.\n//  */\n// contract Ownable is Context {\n//     address private _owner;\n\n//     event OwnershipTransferred(\n//         address indexed previousOwner,\n//         address indexed newOwner\n//     );\n\n//     /**\n//      * @dev Initializes the contract setting the deployer as the initial owner.\n//      */\n//     constructor() internal {\n//         address msgSender = _msgSender();\n//         _owner = msgSender;\n//         emit OwnershipTransferred(address(0), msgSender);\n//     }\n\n//     /**\n//      * @dev Returns the address of the current owner.\n//      */\n//     function owner() public view returns (address) {\n//         return _owner;\n//     }\n\n//     /**\n//      * @dev Throws if called by any account other than the owner.\n//      */\n//     modifier onlyOwner() {\n//         require(isOwner(), \"Ownable: caller is not the owner\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Returns true if the caller is the current owner.\n//      */\n//     function isOwner() public view returns (bool) {\n//         return _msgSender() == _owner;\n//     }\n\n//     /**\n//      * @dev Leaves the contract without owner. It will not be possible to call\n//      * `onlyOwner` functions anymore. Can only be called by the current owner.\n//      *\n//      * NOTE: Renouncing ownership will leave the contract without an owner,\n//      * thereby removing any functionality that is only available to the owner.\n//      */\n//     function renounceOwnership() public onlyOwner {\n//         emit OwnershipTransferred(_owner, address(0));\n//         _owner = address(0);\n//     }\n\n//     /**\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\n//      * Can only be called by the current owner.\n//      */\n//     function transferOwnership(address newOwner) public onlyOwner {\n//         _transferOwnership(newOwner);\n//     }\n\n//     /**\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\n//      */\n//     function _transferOwnership(address newOwner) internal {\n//         require(\n//             newOwner != address(0),\n//             \"Ownable: new owner is the zero address\"\n//         );\n//         emit OwnershipTransferred(_owner, newOwner);\n//         _owner = newOwner;\n//     }\n// }\n\n// /**\n//  *\n//  * @dev Wrappers over Solidity's arithmetic operations with added overflow\n//  * checks.\n//  *\n//  * Arithmetic operations in Solidity wrap on overflow. This can easily result\n//  * in bugs, because programmers usually assume that an overflow raises an\n//  * error, which is the standard behavior in high level programming languages.\n//  * `SafeMath` restores this intuition by reverting the transaction when an\n//  * operation overflows.\n//  *\n//  * Using this library instead of the unchecked operations eliminates an entire\n//  * class of bugs, so it's recommended to use it always.\n//  *\n//  */\n// library SafeMath {\n//     /**\n//      * @dev Returns the addition of two unsigned integers, reverting on\n//      * overflow.\n//      *\n//      * Counterpart to Solidity's `+` operator.\n//      *\n//      * Requirements:\n//      * - Addition cannot overflow.\n//      */\n//     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n//         uint256 c = a + b;\n//         require(c >= a, \"SafeMath: addition overflow\");\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the subtraction of two unsigned integers, reverting on\n//      * overflow (when the result is negative).\n//      *\n//      * Counterpart to Solidity's `-` operator.\n//      *\n//      * Requirements:\n//      * - Subtraction cannot overflow.\n//      */\n//     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b <= a, \"SafeMath: subtraction overflow\");\n//         uint256 c = a - b;\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the multiplication of two unsigned integers, reverting on\n//      * overflow.\n//      *\n//      * Counterpart to Solidity's `*` operator.\n//      *\n//      * Requirements:\n//      * - Multiplication cannot overflow.\n//      */\n//     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n//         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n//         // benefit is lost if 'b' is also tested.\n//         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n//         if (a == 0) {\n//             return 0;\n//         }\n\n//         uint256 c = a * b;\n//         require(c / a == b, \"SafeMath: multiplication overflow\");\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the integer division of two unsigned integers. Reverts on\n//      * division by zero. The result is rounded towards zero.\n//      *\n//      * Counterpart to Solidity's `/` operator. Note: this function uses a\n//      * `revert` opcode (which leaves remaining gas untouched) while Solidity\n//      * uses an invalid opcode to revert (consuming all remaining gas).\n//      *\n//      * Requirements:\n//      * - The divisor cannot be zero.\n//      */\n//     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n//         // Solidity only automatically asserts when dividing by 0\n//         require(b > 0, \"SafeMath: division by zero\");\n//         uint256 c = a / b;\n//         // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n//      * Reverts when dividing by zero.\n//      *\n//      * Counterpart to Solidity's `%` operator. This function uses a `revert`\n//      * opcode (which leaves remaining gas untouched) while Solidity uses an\n//      * invalid opcode to revert (consuming all remaining gas).\n//      *\n//      * Requirements:\n//      * - The divisor cannot be zero.\n//      */\n//     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b != 0, \"SafeMath: modulo by zero\");\n//         return a % b;\n//     }\n// }\n\n// /**\n//  * @dev Interface of the KIP-13 standard, as defined in the\n//  * [KIP-13](http://kips.klaytn.com/KIPs/kip-13-interface_query_standard).\n//  *\n//  * Implementers can declare support of contract interfaces, which can then be\n//  * queried by others.\n//  *\n//  * For an implementation, see `KIP13`.\n//  */\n// interface IKIP13 {\n//     /**\n//      * @dev Returns true if this contract implements the interface defined by\n//      * `interfaceId`. See the corresponding\n//      * [KIP-13 section](http://kips.klaytn.com/KIPs/kip-13-interface_query_standard#how-interface-identifiers-are-defined)\n//      * to learn more about how these ids are created.\n//      *\n//      * This function call must use less than 30 000 gas.\n//      */\n//     function supportsInterface(bytes4 interfaceId) external view returns (bool);\n// }\n\n// /**\n//  * @title Roles\n//  * @dev Library for managing addresses assigned to a Role.\n//  */\n// library Roles {\n//     struct Role {\n//         mapping(address => bool) bearer;\n//     }\n\n//     /**\n//      * @dev Give an account access to this role.\n//      */\n//     function add(Role storage role, address account) internal {\n//         require(!has(role, account), \"Roles: account already has role\");\n//         role.bearer[account] = true;\n//     }\n\n//     /**\n//      * @dev Remove an account's access to this role.\n//      */\n//     function remove(Role storage role, address account) internal {\n//         require(has(role, account), \"Roles: account does not have role\");\n//         role.bearer[account] = false;\n//     }\n\n//     /**\n//      * @dev Check if an account has this role.\n//      * @return bool\n//      */\n//     function has(Role storage role, address account)\n//         internal\n//         view\n//         returns (bool)\n//     {\n//         require(account != address(0), \"Roles: account is the zero address\");\n//         return role.bearer[account];\n//     }\n// }\n\n// contract PauserRole {\n//     using Roles for Roles.Role;\n\n//     event PauserAdded(address indexed account);\n//     event PauserRemoved(address indexed account);\n\n//     Roles.Role private _pausers;\n\n//     constructor() internal {\n//         _addPauser(msg.sender);\n//     }\n\n//     modifier onlyPauser() {\n//         require(\n//             isPauser(msg.sender),\n//             \"PauserRole: caller does not have the Pauser role\"\n//         );\n//         _;\n//     }\n\n//     function isPauser(address account) public view returns (bool) {\n//         return _pausers.has(account);\n//     }\n\n//     function addPauser(address account) public onlyPauser {\n//         _addPauser(account);\n//     }\n\n//     function renouncePauser() public {\n//         _removePauser(msg.sender);\n//     }\n\n//     function _addPauser(address account) internal {\n//         _pausers.add(account);\n//         emit PauserAdded(account);\n//     }\n\n//     function _removePauser(address account) internal {\n//         _pausers.remove(account);\n//         emit PauserRemoved(account);\n//     }\n// }\n\n// /**\n//  * @dev Implementation of the `IKIP13` interface.\n//  *\n//  * Contracts may inherit from this and call `_registerInterface` to declare\n//  * their support of an interface.\n//  */\n// contract KIP13 is IKIP13 {\n//     /*\n//      * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP13 = 0x01ffc9a7;\n\n//     /**\n//      * @dev Mapping of interface ids to whether or not it's supported.\n//      */\n//     mapping(bytes4 => bool) private _supportedInterfaces;\n\n//     constructor() internal {\n//         // Derived contracts need only register support for their own interfaces,\n//         // we register support for KIP13 itself here\n//         _registerInterface(_INTERFACE_ID_KIP13);\n//     }\n\n//     /**\n//      * @dev See `IKIP13.supportsInterface`.\n//      *\n//      * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n//      */\n//     function supportsInterface(bytes4 interfaceId)\n//         external\n//         view\n//         returns (bool)\n//     {\n//         return _supportedInterfaces[interfaceId];\n//     }\n\n//     /**\n//      * @dev Registers the contract as an implementer of the interface defined by\n//      * `interfaceId`. Support of the actual KIP13 interface is automatic and\n//      * registering its interface id is not required.\n//      *\n//      * See `IKIP13.supportsInterface`.\n//      *\n//      * Requirements:\n//      *\n//      * - `interfaceId` cannot be the KIP13 invalid interface (`0xffffffff`).\n//      */\n//     function _registerInterface(bytes4 interfaceId) internal {\n//         require(interfaceId != 0xffffffff, \"KIP13: invalid interface id\");\n//         _supportedInterfaces[interfaceId] = true;\n//     }\n// }\n\n// /**\n//  * @dev Required interface of an KIP17 compliant contract.\n//  */\n// contract IKIP17 is IKIP13 {\n//     event Transfer(\n//         address indexed from,\n//         address indexed to,\n//         uint256 indexed tokenId\n//     );\n//     event Approval(\n//         address indexed owner,\n//         address indexed approved,\n//         uint256 indexed tokenId\n//     );\n//     event ApprovalForAll(\n//         address indexed owner,\n//         address indexed operator,\n//         bool approved\n//     );\n\n//     /**\n//      * @dev Returns the number of NFTs in `owner`'s account.\n//      */\n//     function balanceOf(address owner) public view returns (uint256 balance);\n\n//     /**\n//      * @dev Returns the owner of the NFT specified by `tokenId`.\n//      */\n//     function ownerOf(uint256 tokenId) public view returns (address owner);\n\n//     /**\n//      * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n//      * another (`to`).\n//      *\n//      * Requirements:\n//      * - `from`, `to` cannot be zero.\n//      * - `tokenId` must be owned by `from`.\n//      * - If the caller is not `from`, it must be have been allowed to move this\n//      * NFT by either `approve` or `setApproveForAll`.\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public;\n\n//     /**\n//      * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n//      * another (`to`).\n//      *\n//      * Requirements:\n//      * - If the caller is not `from`, it must be approved to move this NFT by\n//      * either `approve` or `setApproveForAll`.\n//      */\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public;\n\n//     function approve(address to, uint256 tokenId) public;\n\n//     function getApproved(uint256 tokenId)\n//         public\n//         view\n//         returns (address operator);\n\n//     function setApprovalForAll(address operator, bool _approved) public;\n\n//     function isApprovedForAll(address owner, address operator)\n//         public\n//         view\n//         returns (bool);\n\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public;\n// }\n\n// /**\n//  * @title ERC721 token receiver interface\n//  * @dev Interface for any contract that wants to support safeTransfers\n//  * from ERC721 asset contracts.\n//  */\n// contract IERC721Receiver {\n//     /**\n//      * @notice Handle the receipt of an NFT\n//      * @dev The ERC721 smart contract calls this function on the recipient\n//      * after a `safeTransfer`. This function MUST return the function selector,\n//      * otherwise the caller will revert the transaction. The selector to be\n//      * returned can be obtained as `this.onERC721Received.selector`. This\n//      * function MAY throw to revert and reject the transfer.\n//      * Note: the ERC721 contract address is always the message sender.\n//      * @param operator The address which called `safeTransferFrom` function\n//      * @param from The address which previously owned the token\n//      * @param tokenId The NFT identifier which is being transferred\n//      * @param data Additional data with no specified format\n//      * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n//      */\n//     function onERC721Received(\n//         address operator,\n//         address from,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public returns (bytes4);\n// }\n\n// /**\n//  * @title KIP17 token receiver interface\n//  * @dev Interface for any contract that wants to support safeTransfers\n//  * from KIP17 asset contracts.\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Receiver {\n//     /**\n//      * @notice Handle the receipt of an NFT\n//      * @dev The KIP17 smart contract calls this function on the recipient\n//      * after a `safeTransfer`. This function MUST return the function selector,\n//      * otherwise the caller will revert the transaction. The selector to be\n//      * returned can be obtained as `this.onKIP17Received.selector`. This\n//      * function MAY throw to revert and reject the transfer.\n//      * Note: the KIP17 contract address is always the message sender.\n//      * @param operator The address which called `safeTransferFrom` function\n//      * @param from The address which previously owned the token\n//      * @param tokenId The NFT identifier which is being transferred\n//      * @param data Additional data with no specified format\n//      * @return bytes4 `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`\n//      */\n//     function onKIP17Received(\n//         address operator,\n//         address from,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public returns (bytes4);\n// }\n\n// /**\n//  * @dev Collection of functions related to the address type,\n//  */\n// library Address {\n//     /**\n//      * @dev Returns true if `account` is a contract.\n//      *\n//      * This test is non-exhaustive, and there may be false-negatives: during the\n//      * execution of a contract's constructor, its address will be reported as\n//      * not containing a contract.\n//      *\n//      * > It is unsafe to assume that an address for which this function returns\n//      * false is an externally-owned account (EOA) and not a contract.\n//      */\n//     function isContract(address account) internal view returns (bool) {\n//         // This method relies in extcodesize, which returns 0 for contracts in\n//         // construction, since the code is only stored at the end of the\n//         // constructor execution.\n\n//         uint256 size;\n//         // solhint-disable-next-line no-inline-assembly\n//         assembly {\n//             size := extcodesize(account)\n//         }\n//         return size > 0;\n//     }\n// }\n\n// /**\n//  * @title Counters\n//  * @author Matt Condon (@shrugs)\n//  * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n//  * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n//  *\n//  * Include with `using Counters for Counters.Counter;`\n//  * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n//  * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n//  * directly accessed.\n//  */\n// library Counters {\n//     using SafeMath for uint256;\n\n//     struct Counter {\n//         // This variable should never be directly accessed by users of the library: interactions must be restricted to\n//         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n//         // this feature: see https://github.com/ethereum/solidity/issues/4637\n//         uint256 _value; // default: 0\n//     }\n\n//     function current(Counter storage counter) internal view returns (uint256) {\n//         return counter._value;\n//     }\n\n//     function increment(Counter storage counter) internal {\n//         counter._value += 1;\n//     }\n\n//     function decrement(Counter storage counter) internal {\n//         counter._value = counter._value.sub(1);\n//     }\n// }\n\n// /**\n//  * @title KIP17 Non-Fungible Token Standard basic implementation\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17 is KIP13, IKIP17 {\n//     using SafeMath for uint256;\n//     using Address for address;\n//     using Counters for Counters.Counter;\n\n//     // Equals to `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`\n//     // which can be also obtained as `IKIP17Receiver(0).onKIP17Received.selector`\n//     bytes4 private constant _KIP17_RECEIVED = 0x6745782b;\n\n//     // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n//     // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n//     bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n//     // Mapping from token ID to owner\n//     mapping(uint256 => address) private _tokenOwner;\n\n//     // Mapping from token ID to approved address\n//     mapping(uint256 => address) private _tokenApprovals;\n\n//     // Mapping from owner to number of owned token\n//     mapping(address => Counters.Counter) private _ownedTokensCount;\n\n//     // Mapping from owner to operator approvals\n//     mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n//     /*\n//      *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n//      *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n//      *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n//      *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n//      *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n//      *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c\n//      *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n//      *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n//      *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n//      *\n//      *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n//      *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17 = 0x80ac58cd;\n\n//     constructor() public {\n//         // register the supported interfaces to conform to KIP17 via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17);\n//     }\n\n//     /**\n//      * @dev Gets the balance of the specified address.\n//      * @param owner address to query the balance of\n//      * @return uint256 representing the amount owned by the passed address\n//      */\n//     function balanceOf(address owner) public view returns (uint256) {\n//         require(\n//             owner != address(0),\n//             \"KIP17: balance query for the zero address\"\n//         );\n\n//         return _ownedTokensCount[owner].current();\n//     }\n\n//     /**\n//      * @dev Gets the owner of the specified token ID.\n//      * @param tokenId uint256 ID of the token to query the owner of\n//      * @return address currently marked as the owner of the given token ID\n//      */\n//     function ownerOf(uint256 tokenId) public view returns (address) {\n//         address owner = _tokenOwner[tokenId];\n//         require(\n//             owner != address(0),\n//             \"KIP17: owner query for nonexistent token\"\n//         );\n\n//         return owner;\n//     }\n\n//     /**\n//      * @dev Approves another address to transfer the given token ID\n//      * The zero address indicates there is no approved address.\n//      * There can only be one approved address per token at a given time.\n//      * Can only be called by the token owner or an approved operator.\n//      * @param to address to be approved for the given token ID\n//      * @param tokenId uint256 ID of the token to be approved\n//      */\n//     function approve(address to, uint256 tokenId) public {\n//         address owner = ownerOf(tokenId);\n//         require(to != owner, \"KIP17: approval to current owner\");\n\n//         require(\n//             msg.sender == owner || isApprovedForAll(owner, msg.sender),\n//             \"KIP17: approve caller is not owner nor approved for all\"\n//         );\n\n//         _tokenApprovals[tokenId] = to;\n//         emit Approval(owner, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Gets the approved address for a token ID, or zero if no address set\n//      * Reverts if the token ID does not exist.\n//      * @param tokenId uint256 ID of the token to query the approval of\n//      * @return address currently approved for the given token ID\n//      */\n//     function getApproved(uint256 tokenId) public view returns (address) {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17: approved query for nonexistent token\"\n//         );\n\n//         return _tokenApprovals[tokenId];\n//     }\n\n//     /**\n//      * @dev Sets or unsets the approval of a given operator\n//      * An operator is allowed to transfer all tokens of the sender on their behalf.\n//      * @param to operator address to set the approval\n//      * @param approved representing the status of the approval to be set\n//      */\n//     function setApprovalForAll(address to, bool approved) public {\n//         require(to != msg.sender, \"KIP17: approve to caller\");\n\n//         _operatorApprovals[msg.sender][to] = approved;\n//         emit ApprovalForAll(msg.sender, to, approved);\n//     }\n\n//     /**\n//      * @dev Tells whether an operator is approved by a given owner.\n//      * @param owner owner address which you want to query the approval of\n//      * @param operator operator address which you want to query the approval of\n//      * @return bool whether the given operator is approved by the given owner\n//      */\n//     function isApprovedForAll(address owner, address operator)\n//         public\n//         view\n//         returns (bool)\n//     {\n//         return _operatorApprovals[owner][operator];\n//     }\n\n//     /**\n//      * @dev Transfers the ownership of a given token ID to another address.\n//      * Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\n//      * Requires the msg.sender to be the owner, approved, or operator.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public {\n//         //solhint-disable-next-line max-line-length\n//         require(\n//             _isApprovedOrOwner(msg.sender, tokenId),\n//             \"KIP17: transfer caller is not owner nor approved\"\n//         );\n\n//         _transferFrom(from, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Safely transfers the ownership of a given token ID to another address\n//      * If the target address is a contract, it must implement `onKIP17Received`,\n//      * which is called upon a safe transfer, and return the magic value\n//      * `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`; otherwise,\n//      * the transfer is reverted.\n//      * Requires the msg.sender to be the owner, approved, or operator\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public {\n//         safeTransferFrom(from, to, tokenId, \"\");\n//     }\n\n//     /**\n//      * @dev Safely transfers the ownership of a given token ID to another address\n//      * If the target address is a contract, it must implement `onKIP17Received`,\n//      * which is called upon a safe transfer, and return the magic value\n//      * `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`; otherwise,\n//      * the transfer is reverted.\n//      * Requires the msg.sender to be the owner, approved, or operator\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @param _data bytes data to send along with a safe transfer check\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory _data\n//     ) public {\n//         transferFrom(from, to, tokenId);\n//         require(\n//             _checkOnKIP17Received(from, to, tokenId, _data),\n//             \"KIP17: transfer to non KIP17Receiver implementer\"\n//         );\n//     }\n\n//     /**\n//      * @dev Returns whether the specified token exists.\n//      * @param tokenId uint256 ID of the token to query the existence of\n//      * @return bool whether the token exists\n//      */\n//     function _exists(uint256 tokenId) internal view returns (bool) {\n//         address owner = _tokenOwner[tokenId];\n//         return owner != address(0);\n//     }\n\n//     /**\n//      * @dev Returns whether the given spender can transfer a given token ID.\n//      * @param spender address of the spender to query\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @return bool whether the msg.sender is approved for the given token ID,\n//      * is an operator of the owner, or is the owner of the token\n//      */\n//     function _isApprovedOrOwner(address spender, uint256 tokenId)\n//         internal\n//         view\n//         returns (bool)\n//     {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17: operator query for nonexistent token\"\n//         );\n//         address owner = ownerOf(tokenId);\n//         return (spender == owner ||\n//             getApproved(tokenId) == spender ||\n//             isApprovedForAll(owner, spender));\n//     }\n\n//     /**\n//      * @dev Internal function to mint a new token.\n//      * Reverts if the given token ID already exists.\n//      * @param to The address that will own the minted token\n//      * @param tokenId uint256 ID of the token to be minted\n//      */\n//     function _mint(address to, uint256 tokenId) internal {\n//         require(to != address(0), \"KIP17: mint to the zero address\");\n//         require(!_exists(tokenId), \"KIP17: token already minted\");\n\n//         _tokenOwner[tokenId] = to;\n//         _ownedTokensCount[to].increment();\n\n//         emit Transfer(address(0), to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         require(\n//             ownerOf(tokenId) == owner,\n//             \"KIP17: burn of token that is not own\"\n//         );\n\n//         _clearApproval(tokenId);\n\n//         _ownedTokensCount[owner].decrement();\n//         _tokenOwner[tokenId] = address(0);\n\n//         emit Transfer(owner, address(0), tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(uint256 tokenId) internal {\n//         _burn(ownerOf(tokenId), tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to transfer ownership of a given token ID to another address.\n//      * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) internal {\n//         require(\n//             ownerOf(tokenId) == from,\n//             \"KIP17: transfer of token that is not own\"\n//         );\n//         require(to != address(0), \"KIP17: transfer to the zero address\");\n\n//         _clearApproval(tokenId);\n\n//         _ownedTokensCount[from].decrement();\n//         _ownedTokensCount[to].increment();\n\n//         _tokenOwner[tokenId] = to;\n\n//         emit Transfer(from, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to invoke `onKIP17Received` on a target address.\n//      * The call is not executed if the target address is not a contract.\n//      *\n//      * This function is deprecated.\n//      * @param from address representing the previous owner of the given token ID\n//      * @param to target address that will receive the tokens\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @param _data bytes optional data to send along with the call\n//      * @return bool whether the call correctly returned the expected magic value\n//      */\n//     function _checkOnKIP17Received(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory _data\n//     ) internal returns (bool) {\n//         if (!to.isContract()) {\n//             return true;\n//         }\n\n//         // Logic for compatibility with ERC721.\n//         bytes4 retval = IERC721Receiver(to).onERC721Received(\n//             msg.sender,\n//             from,\n//             tokenId,\n//             _data\n//         );\n//         if (retval == _ERC721_RECEIVED) {\n//             return true;\n//         }\n\n//         retval = IKIP17Receiver(to).onKIP17Received(\n//             msg.sender,\n//             from,\n//             tokenId,\n//             _data\n//         );\n//         return (retval == _KIP17_RECEIVED);\n//     }\n\n//     /**\n//      * @dev Private function to clear current approval of a given token ID.\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _clearApproval(uint256 tokenId) private {\n//         if (_tokenApprovals[tokenId] != address(0)) {\n//             _tokenApprovals[tokenId] = address(0);\n//         }\n//     }\n// }\n\n// contract MinterRole {\n//     using Roles for Roles.Role;\n\n//     event MinterAdded(address indexed account);\n//     event MinterRemoved(address indexed account);\n\n//     Roles.Role private _minters;\n\n//     constructor() internal {\n//         _addMinter(msg.sender);\n//     }\n\n//     modifier onlyMinter() {\n//         require(\n//             isMinter(msg.sender),\n//             \"MinterRole: caller does not have the Minter role\"\n//         );\n//         _;\n//     }\n\n//     function isMinter(address account) public view returns (bool) {\n//         return _minters.has(account);\n//     }\n\n//     function addMinter(address account) public onlyMinter {\n//         _addMinter(account);\n//     }\n\n//     function renounceMinter() public {\n//         _removeMinter(msg.sender);\n//     }\n\n//     function _addMinter(address account) internal {\n//         _minters.add(account);\n//         emit MinterAdded(account);\n//     }\n\n//     function _removeMinter(address account) internal {\n//         _minters.remove(account);\n//         emit MinterRemoved(account);\n//     }\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token Standard, optional metadata extension\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Metadata is IKIP17 {\n//     function name() external view returns (string memory);\n\n//     function symbol() external view returns (string memory);\n\n//     function tokenURI(uint256 tokenId) external view returns (string memory);\n// }\n\n// contract KIP17Metadata is KIP13, KIP17, IKIP17Metadata {\n//     // Token name\n//     string private _name;\n\n//     // Token symbol\n//     string private _symbol;\n\n//     // Optional mapping for token URIs\n//     mapping(uint256 => string) private _tokenURIs;\n\n//     /*\n//      *     bytes4(keccak256('name()')) == 0x06fdde03\n//      *     bytes4(keccak256('symbol()')) == 0x95d89b41\n//      *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n//      *\n//      *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_METADATA = 0x5b5e139f;\n\n//     /**\n//      * @dev Constructor function\n//      */\n//     constructor(string memory name, string memory symbol) public {\n//         _name = name;\n//         _symbol = symbol;\n\n//         // register the supported interfaces to conform to KIP17 via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_METADATA);\n//     }\n\n//     /**\n//      * @dev Gets the token name.\n//      * @return string representing the token name\n//      */\n//     function name() external view returns (string memory) {\n//         return _name;\n//     }\n\n//     /**\n//      * @dev Gets the token symbol.\n//      * @return string representing the token symbol\n//      */\n//     function symbol() external view returns (string memory) {\n//         return _symbol;\n//     }\n\n//     /**\n//      * @dev Returns an URI for a given token ID.\n//      * Throws if the token ID does not exist. May return an empty string.\n//      * @param tokenId uint256 ID of the token to query\n//      */\n//     function tokenURI(uint256 tokenId) external view returns (string memory) {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17Metadata: URI query for nonexistent token\"\n//         );\n//         return _tokenURIs[tokenId];\n//     }\n\n//     /**\n//      * @dev Internal function to set the token URI for a given token.\n//      * Reverts if the token ID does not exist.\n//      * @param tokenId uint256 ID of the token to set its URI\n//      * @param uri string URI to assign\n//      */\n//     function _setTokenURI(uint256 tokenId, string memory uri) internal {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17Metadata: URI set of nonexistent token\"\n//         );\n//         _tokenURIs[tokenId] = uri;\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned by the msg.sender\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         super._burn(owner, tokenId);\n\n//         // Clear metadata (if any)\n//         if (bytes(_tokenURIs[tokenId]).length != 0) {\n//             delete _tokenURIs[tokenId];\n//         }\n//     }\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token Standard, optional enumeration extension\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Enumerable is IKIP17 {\n//     function totalSupply() public view returns (uint256);\n\n//     function tokenOfOwnerByIndex(address owner, uint256 index)\n//         public\n//         view\n//         returns (uint256 tokenId);\n\n//     function tokenByIndex(uint256 index) public view returns (uint256);\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token with optional enumeration extension logic\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Enumerable is KIP13, KIP17, IKIP17Enumerable {\n//     // Mapping from owner to list of owned token IDs\n//     mapping(address => uint256[]) private _ownedTokens;\n\n//     // Mapping from token ID to index of the owner tokens list\n//     mapping(uint256 => uint256) private _ownedTokensIndex;\n\n//     // Array with all token ids, used for enumeration\n//     uint256[] private _allTokens;\n\n//     // Mapping from token id to position in the allTokens array\n//     mapping(uint256 => uint256) private _allTokensIndex;\n\n//     /*\n//      *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n//      *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n//      *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n//      *\n//      *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_ENUMERABLE = 0x780e9d63;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Enumerable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_ENUMERABLE);\n//     }\n\n//     /**\n//      * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n//      * @param owner address owning the tokens list to be accessed\n//      * @param index uint256 representing the index to be accessed of the requested tokens list\n//      * @return uint256 token ID at the given index of the tokens list owned by the requested address\n//      */\n//     function tokenOfOwnerByIndex(address owner, uint256 index)\n//         public\n//         view\n//         returns (uint256)\n//     {\n//         require(\n//             index < balanceOf(owner),\n//             \"KIP17Enumerable: owner index out of bounds\"\n//         );\n//         return _ownedTokens[owner][index];\n//     }\n\n//     /**\n//      * @dev Gets the total amount of tokens stored by the contract.\n//      * @return uint256 representing the total amount of tokens\n//      */\n//     function totalSupply() public view returns (uint256) {\n//         return _allTokens.length;\n//     }\n\n//     /**\n//      * @dev Gets the token ID at a given index of all the tokens in this contract\n//      * Reverts if the index is greater or equal to the total number of tokens.\n//      * @param index uint256 representing the index to be accessed of the tokens list\n//      * @return uint256 token ID at the given index of the tokens list\n//      */\n//     function tokenByIndex(uint256 index) public view returns (uint256) {\n//         require(\n//             index < totalSupply(),\n//             \"KIP17Enumerable: global index out of bounds\"\n//         );\n//         return _allTokens[index];\n//     }\n\n//     /**\n//      * @dev Internal function to transfer ownership of a given token ID to another address.\n//      * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) internal {\n//         super._transferFrom(from, to, tokenId);\n\n//         _removeTokenFromOwnerEnumeration(from, tokenId);\n\n//         _addTokenToOwnerEnumeration(to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to mint a new token.\n//      * Reverts if the given token ID already exists.\n//      * @param to address the beneficiary that will own the minted token\n//      * @param tokenId uint256 ID of the token to be minted\n//      */\n//     function _mint(address to, uint256 tokenId) internal {\n//         super._mint(to, tokenId);\n\n//         _addTokenToOwnerEnumeration(to, tokenId);\n\n//         _addTokenToAllTokensEnumeration(tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         super._burn(owner, tokenId);\n\n//         _removeTokenFromOwnerEnumeration(owner, tokenId);\n//         // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n//         _ownedTokensIndex[tokenId] = 0;\n\n//         _removeTokenFromAllTokensEnumeration(tokenId);\n//     }\n\n//     /**\n//      * @dev Gets the list of token IDs of the requested owner.\n//      * @param owner address owning the tokens\n//      * @return uint256[] List of token IDs owned by the requested address\n//      */\n//     function _tokensOfOwner(address owner)\n//         internal\n//         view\n//         returns (uint256[] storage)\n//     {\n//         return _ownedTokens[owner];\n//     }\n\n//     /**\n//      * @dev Private function to add a token to this extension's ownership-tracking data structures.\n//      * @param to address representing the new owner of the given token ID\n//      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n//      */\n//     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n//         _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n//         _ownedTokens[to].push(tokenId);\n//     }\n\n//     /**\n//      * @dev Private function to add a token to this extension's token tracking data structures.\n//      * @param tokenId uint256 ID of the token to be added to the tokens list\n//      */\n//     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n//         _allTokensIndex[tokenId] = _allTokens.length;\n//         _allTokens.push(tokenId);\n//     }\n\n//     /**\n//      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n//      * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n//      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n//      * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n//      * @param from address representing the previous owner of the given token ID\n//      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n//      */\n//     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n//         private\n//     {\n//         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n//         // then delete the last slot (swap and pop).\n\n//         uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n//         uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n//         // When the token to delete is the last token, the swap operation is unnecessary\n//         if (tokenIndex != lastTokenIndex) {\n//             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n//             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n//             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n//         }\n\n//         // This also deletes the contents at the last position of the array\n//         _ownedTokens[from].length--;\n\n//         // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n//         // lastTokenId, or just over the end of the array if the token was the last one).\n//     }\n\n//     /**\n//      * @dev Private function to remove a token from this extension's token tracking data structures.\n//      * This has O(1) time complexity, but alters the order of the _allTokens array.\n//      * @param tokenId uint256 ID of the token to be removed from the tokens list\n//      */\n//     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n//         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n//         // then delete the last slot (swap and pop).\n\n//         uint256 lastTokenIndex = _allTokens.length.sub(1);\n//         uint256 tokenIndex = _allTokensIndex[tokenId];\n\n//         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n//         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n//         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n//         uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n//         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n//         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n//         // This also deletes the contents at the last position of the array\n//         _allTokens.length--;\n//         _allTokensIndex[tokenId] = 0;\n//     }\n// }\n\n// /**\n//  * @title Full KIP-17 Token\n//  * This implementation includes all the required and some optional functionality of the KIP-17 standard\n//  * Moreover, it includes approve all functionality using operator terminology\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Full is KIP17, KIP17Enumerable, KIP17Metadata {\n//     constructor(string memory name, string memory symbol)\n//         public\n//         KIP17Metadata(name, symbol)\n//     {\n//         // solhint-disable-previous-line no-empty-blocks\n//     }\n// }\n\n// /**\n//  * @title KIP17MetadataMintable\n//  * @dev KIP17 minting logic with metadata.\n//  */\n// contract KIP17MetadataMintable is KIP13, KIP17, KIP17Metadata, MinterRole {\n//     /*\n//      *     bytes4(keccak256('mintWithTokenURI(address,uint256,string)')) == 0x50bb4e7f\n//      *     bytes4(keccak256('isMinter(address)')) == 0xaa271e1a\n//      *     bytes4(keccak256('addMinter(address)')) == 0x983b2d56\n//      *     bytes4(keccak256('renounceMinter()')) == 0x98650275\n//      *\n//      *     => 0x50bb4e7f ^ 0xaa271e1a ^ 0x983b2d56 ^ 0x98650275 == 0xfac27f46\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_METADATA_MINTABLE = 0xfac27f46;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Mintable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_METADATA_MINTABLE);\n//     }\n\n//     /**\n//      * @dev Function to mint tokens.\n//      * @param to The address that will receive the minted tokens.\n//      * @param tokenId The token id to mint.\n//      * @param tokenURI The token URI of the minted token.\n//      * @return A boolean that indicates if the operation was successful.\n//      */\n//     function mintWithTokenURI(\n//         address to,\n//         uint256 tokenId,\n//         string memory tokenURI\n//     ) public onlyMinter returns (bool) {\n//         _mint(to, tokenId);\n//         _setTokenURI(tokenId, tokenURI);\n//         return true;\n//     }\n// }\n\n// /**\n//  * @title KIP17Mintable\n//  * @dev KIP17 minting logic.\n//  */\n// contract KIP17Mintable is KIP17, MinterRole {\n//     /*\n//      *     bytes4(keccak256('isMinter(address)')) == 0xaa271e1a\n//      *     bytes4(keccak256('addMinter(address)')) == 0x983b2d56\n//      *     bytes4(keccak256('renounceMinter()')) == 0x98650275\n//      *     bytes4(keccak256('mint(address,uint256)')) == 0x40c10f19\n//      *\n//      *     => 0xaa271e1a ^ 0x983b2d56 ^ 0x98650275 ^ 0x40c10f19 == 0xeab83e20\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_MINTABLE = 0xeab83e20;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Mintable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_MINTABLE);\n//     }\n\n//     /**\n//      * @dev Function to mint tokens.\n//      * @param to The address that will receive the minted tokens.\n//      * @param tokenId The token id to mint.\n//      * @return A boolean that indicates if the operation was successful.\n//      */\n//     function mint(address to, uint256 tokenId)\n//         public\n//         onlyMinter\n//         returns (bool)\n//     {\n//         _mint(to, tokenId);\n//         return true;\n//     }\n// }\n\n// /**\n//  * @title KIP17 Burnable Token\n//  * @dev KIP17 Token that can be irreversibly burned (destroyed).\n//  * See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Burnable is KIP13, KIP17 {\n//     /*\n//      *     bytes4(keccak256('burn(uint256)')) == 0x42966c68\n//      *\n//      *     => 0x42966c68 == 0x42966c68\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_BURNABLE = 0x42966c68;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Burnable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_BURNABLE);\n//     }\n\n//     /**\n//      * @dev Burns a specific KIP17 token.\n//      * @param tokenId uint256 id of the KIP17 token to be burned.\n//      */\n//     function burn(uint256 tokenId) public {\n//         //solhint-disable-next-line max-line-length\n//         require(\n//             _isApprovedOrOwner(msg.sender, tokenId),\n//             \"KIP17Burnable: caller is not owner nor approved\"\n//         );\n//         _burn(tokenId);\n//     }\n// }\n\n// /**\n//  * @dev Contract module which allows children to implement an emergency stop\n//  * mechanism that can be triggered by an authorized account.\n//  *\n//  * This module is used through inheritance. It will make available the\n//  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n//  * the functions of your contract. Note that they will not be pausable by\n//  * simply including this module, only once the modifiers are put in place.\n//  */\n// contract Pausable is PauserRole {\n//     /**\n//      * @dev Emitted when the pause is triggered by a pauser (`account`).\n//      */\n//     event Paused(address account);\n\n//     /**\n//      * @dev Emitted when the pause is lifted by a pauser (`account`).\n//      */\n//     event Unpaused(address account);\n\n//     bool private _paused;\n\n//     /**\n//      * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n//      * to the deployer.\n//      */\n//     constructor() internal {\n//         _paused = false;\n//     }\n\n//     /**\n//      * @dev Returns true if the contract is paused, and false otherwise.\n//      */\n//     function paused() public view returns (bool) {\n//         return _paused;\n//     }\n\n//     /**\n//      * @dev Modifier to make a function callable only when the contract is not paused.\n//      */\n//     modifier whenNotPaused() {\n//         require(!_paused, \"Pausable: paused\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Modifier to make a function callable only when the contract is paused.\n//      */\n//     modifier whenPaused() {\n//         require(_paused, \"Pausable: not paused\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Called by a pauser to pause, triggers stopped state.\n//      */\n//     function pause() public onlyPauser whenNotPaused {\n//         _paused = true;\n//         emit Paused(msg.sender);\n//     }\n\n//     /**\n//      * @dev Called by a pauser to unpause, returns to normal state.\n//      */\n//     function unpause() public onlyPauser whenPaused {\n//         _paused = false;\n//         emit Unpaused(msg.sender);\n//     }\n// }\n\n// /**\n//  * @title KIP17 Non-Fungible Pausable token\n//  * @dev KIP17 modified with pausable transfers.\n//  */\n// contract KIP17Pausable is KIP13, KIP17, Pausable {\n//     /*\n//      *     bytes4(keccak256('paused()')) == 0x5c975abb\n//      *     bytes4(keccak256('pause()')) == 0x8456cb59\n//      *     bytes4(keccak256('unpause()')) == 0x3f4ba83a\n//      *     bytes4(keccak256('isPauser(address)')) == 0x46fbf68e\n//      *     bytes4(keccak256('addPauser(address)')) == 0x82dc1ec4\n//      *     bytes4(keccak256('renouncePauser()')) == 0x6ef8d66d\n//      *\n//      *     => 0x5c975abb ^ 0x8456cb59 ^ 0x3f4ba83a ^ 0x46fbf68e ^ 0x82dc1ec4 ^ 0x6ef8d66d == 0x4d5507ff\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_PAUSABLE = 0x4d5507ff;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Pausable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_PAUSABLE);\n//     }\n\n//     function approve(address to, uint256 tokenId) public whenNotPaused {\n//         super.approve(to, tokenId);\n//     }\n\n//     function setApprovalForAll(address to, bool approved) public whenNotPaused {\n//         super.setApprovalForAll(to, approved);\n//     }\n\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public whenNotPaused {\n//         super.transferFrom(from, to, tokenId);\n//     }\n// }\n\n// contract KIP17Token is\n//     KIP17Full,\n//     KIP17Mintable,\n//     KIP17MetadataMintable,\n//     KIP17Burnable,\n//     KIP17Pausable,\n//     Ownable\n// {\n//     constructor(string memory name, string memory symbol)\n//         public\n//         KIP17Full(name, symbol)\n//     {}\n// }\n"
    },
    "contracts/tokens/per/per.sol": {
      "content": "// /**\n//     dev_team.gutalik\n// */\n// pragma solidity ^0.4.24;\n// /**\n//     * @title SafeMath\n// * @dev Math operations with safety checks that revert on error\n// */\n// library SafeMath {\n//     /**\n//         * @dev Multiplies two numbers, reverts on overflow.\n//         */\n//     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n//         if (a == 0) {\n//             return 0;\n//         }\n//         uint256 c = a * b;\n//         require(c / a == b);\n//         return c;\n//     }\n//     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b > 0);\n//         uint256 c = a / b;\n//         return c;\n//     }\n//     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b <= a);\n//         uint256 c = a - b;\n//         return c;\n//     }\n//     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n//         uint256 c = a + b;\n//         require(c >= a);\n//         return c;\n//     }\n//     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b != 0);\n//         return a % b;\n//     }\n// }\n// contract owned {\n//     address public owner;\n//     constructor() public {\n//         owner = msg.sender;\n//     }\n//     modifier onlyOwner {\n//         require(msg.sender == owner);\n//         _;\n//     }\n//     function transferOwnership(address newOwner) onlyOwner public {\n//         owner = newOwner;\n//     }\n// }\n// interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n// contract TokenERC20 is owned{\n//     using SafeMath for uint256;\n//     // Public variables of the token\n//     string public name;\n//     string public symbol;\n//     uint8 public decimals = 18;\n//     // 18 decimals is the strongly suggested default, avoid changing it\n//     uint256 public totalSupply;\n//     bool public released = true;\n//     // This creates an array with all balances\n//     mapping (address => uint256) public balanceOf;\n//     mapping (address => mapping (address => uint256)) public allowance;\n//     // This generates a public event on the blockchain that will notify clients\n//     event Transfer(address indexed from, address indexed to, uint256 value);\n//     // This generates a public event on the blockchain that will notify clients\n//     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n//     // This notifies clients about the amount burnt\n//     event Burn(address indexed from, uint256 value);\n//     constructor(\n//         uint256 initialSupply,\n//         string tokenName,\n//         string tokenSymbol\n//     ) public {\n//         totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount\n//         balanceOf[msg.sender] = totalSupply; // Give the creator all initial tokens\n//         name = tokenName; // Set the name for display purposes\n//         symbol = tokenSymbol; // Set the symbol for display purposes\n//     }\n//     function release() public onlyOwner{\n//         require (owner == msg.sender);\n//         released = !released;\n//     }\n//     modifier onlyReleased() {\n//         require(released);\n//         _;\n//     }\n//     function _transfer(address _from, address _to, uint _value) internal onlyReleased {\n//         // Prevent transfer to 0x0 address. Use burn() instead\n//         require(_to != 0x0);\n//         // Check if the sender has enough\n//         require(balanceOf[_from] >= _value);\n//         // Check for overflows\n//         require(balanceOf[_to] + _value > balanceOf[_to]);\n//         // Save this for an assertion in the future\n//         uint previousBalances = balanceOf[_from].add(balanceOf[_to]);\n//         // Subtract from the sender\n//         balanceOf[_from] = balanceOf[_from].sub(_value);\n//         // Add the same to the recipient\n//         balanceOf[_to] = balanceOf[_to].add(_value);\n//         emit Transfer(_from, _to, _value);\n//         // Asserts are used to use static analysis to find bugs in your code. They should never fail\n//         assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n//     }\n//     /**\n//         * Transfer tokens\n//     *\n//         * Send `_value` tokens to `_to` from your account\n//     *\n//         * @param _to The address of the recipient\n//     * @param _value the amount to send\n//     */\n//     function transfer(address _to, uint256 _value) public onlyReleased returns (bool success) {\n//         _transfer(msg.sender, _to, _value);\n//         return true;\n//     }\n//     /**\n//         * Transfer tokens from other address\n//     *\n//         * Send `_value` tokens to `_to` in behalf of `_from`\n//     *\n//         * @param _from The address of the sender\n//     * @param _to The address of the recipient\n//     * @param _value the amount to send\n//     */\n//     function transferFrom(address _from, address _to, uint256 _value) public onlyReleased returns (bool success) {\n//         require(_value <= allowance[_from][msg.sender]); // Check allowance\n//         allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);\n//         _transfer(_from, _to, _value);\n//         return true;\n//     }\n//     /**\n//         * Set allowance for other address\n//     *\n//         * Allows `_spender` to spend no more than `_value` tokens in your behalf\n//     *\n//         * @param _spender The address authorized to spend\n//     * @param _value the max amount they can spend\n//     */\n//     function approve(address _spender, uint256 _value) public onlyReleased\n//     returns (bool success) {\n//         require(_spender != address(0));\n//         allowance[msg.sender][_spender] = _value;\n//         emit Approval(msg.sender, _spender, _value);\n//         return true;\n//     }\n//     function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n//     public onlyReleased\n//     returns (bool success) {\n//         tokenRecipient spender = tokenRecipient(_spender);\n//         if (approve(_spender, _value)) {\n//             spender.receiveApproval(msg.sender, _value, this, _extraData);\n//             return true;\n//         }\n//     }\n//     /**\n//         * Destroy tokens\n//     *\n//         * Remove `_value` tokens from the system irreversibly\n//     *\n//         * @param _value the amount of money to burn\n//     */\n//     function burn(uint256 _value) public onlyReleased returns (bool success) {\n//         require(balanceOf[msg.sender] >= _value); // Check if the sender has enough\n//         balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); // Subtract from the sender\n//         totalSupply = totalSupply.sub(_value); // Updates totalSupply\n//         emit Burn(msg.sender, _value);\n//         return true;\n//     }\n//     /**\n//         * Destroy tokens from other account\n//     *\n//         * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n//         *\n//         * @param _from the address of the sender\n//     * @param _value the amount of money to burn\n//     */\n//     function burnFrom(address _from, uint256 _value) public onlyReleased returns (bool success) {\n//         require(balanceOf[_from] >= _value); // Check if the targeted balance is enough\n//         require(_value <= allowance[_from][msg.sender]); // Check allowance\n//         balanceOf[_from] = balanceOf[_from].sub(_value); // Subtract from the targeted balance\n//         allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); // Subtract from the sender's allowance\n//         totalSupply = totalSupply.sub(_value); // Update totalSupply\n//         emit Burn(_from, _value);\n//         return true;\n//     }\n// }\n// contract PER is owned, TokenERC20 {\n//     mapping (address => bool) public frozenAccount;\n//     /* This generates a public event on the blockchain that will notify clients */\n//     event FrozenFunds(address target, bool frozen);\n//     /* Initializes contract with initial supply tokens to the creator of the contract */\n//     constructor(\n//         uint256 initialSupply,\n//         string tokenName,\n//         string tokenSymbol\n//     ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {\n//     }\n//     /* Internal transfer, only can be called by this contract */\n//     function _transfer(address _from, address _to, uint _value) internal onlyReleased {\n//         require (_to != 0x0); // Prevent transfer to 0x0 address. Use burn() instead\n//         require (balanceOf[_from] >= _value); // Check if the sender has enough\n//         require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n//         require(!frozenAccount[_from]); // Check if sender is frozen\n//         require(!frozenAccount[_to]); // Check if recipient is frozen\n//         balanceOf[_from] = balanceOf[_from].sub(_value); // Subtract from the sender\n//         balanceOf[_to] = balanceOf[_to].add(_value); // Add the same to the recipient\n//         emit Transfer(_from, _to, _value);\n//     }\n//     /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n//     /// @param target Address to be frozen\n//     /// @param freeze either to freeze it or not\n//     function freezeAccount(address target, bool freeze) onlyOwner public {\n//         frozenAccount[target] = freeze;\n//         emit FrozenFunds(target, freeze);\n//     }\n// }"
    },
    "contracts/tokens/perfriends_item/pf_item.sol": {
      "content": "// pragma solidity ^0.8.0;\n\n// // contract perfriendsItem {\n\n// // }\n"
    },
    "contracts/tokens/perfriends/perfriends.sol": {
      "content": "// pragma solidity ^0.5.0;\n\n\n\n// // address : 0x0ed55aee0399064cfe51dd3cc10d99734bb796c7\n// // network : cypress\n\n// /*\n//  * @dev Provides information about the current execution context, including the\n//  * sender of the transaction and its data. While these are generally available\n//  * via msg.sender and msg.data, they should not be accessed in such a direct\n//  * manner, since when dealing with GSN meta-transactions the account sending and\n//  * paying for execution may not be the actual sender (as far as an application\n//  * is concerned).\n//  *\n//  * This contract is only required for intermediate, library-like contracts.\n//  */\n// contract Context {\n//     // Empty internal constructor, to prevent people from mistakenly deploying\n//     // an instance of this contract, which should be used via inheritance.\n//     constructor() internal {}\n\n//     // solhint-disable-previous-line no-empty-blocks\n\n//     function _msgSender() internal view returns (address payable) {\n//         return msg.sender;\n//     }\n\n//     function _msgData() internal view returns (bytes memory) {\n//         this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n//         return msg.data;\n//     }\n// }\n\n// /**\n//  * @dev Contract module which provides a basic access control mechanism, where\n//  * there is an account (an owner) that can be granted exclusive access to\n//  * specific functions.\n//  *\n//  * This module is used through inheritance. It will make available the modifier\n//  * `onlyOwner`, which can be applied to your functions to restrict their use to\n//  * the owner.\n//  */\n// contract Ownable is Context {\n//     address private _owner;\n\n//     event OwnershipTransferred(\n//         address indexed previousOwner,\n//         address indexed newOwner\n//     );\n\n//     /**\n//      * @dev Initializes the contract setting the deployer as the initial owner.\n//      */\n//     constructor() internal {\n//         address msgSender = _msgSender();\n//         _owner = msgSender;\n//         emit OwnershipTransferred(address(0), msgSender);\n//     }\n\n//     /**\n//      * @dev Returns the address of the current owner.\n//      */\n//     function owner() public view returns (address) {\n//         return _owner;\n//     }\n\n//     /**\n//      * @dev Throws if called by any account other than the owner.\n//      */\n//     modifier onlyOwner() {\n//         require(isOwner(), \"Ownable: caller is not the owner\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Returns true if the caller is the current owner.\n//      */\n//     function isOwner() public view returns (bool) {\n//         return _msgSender() == _owner;\n//     }\n\n//     /**\n//      * @dev Leaves the contract without owner. It will not be possible to call\n//      * `onlyOwner` functions anymore. Can only be called by the current owner.\n//      *\n//      * NOTE: Renouncing ownership will leave the contract without an owner,\n//      * thereby removing any functionality that is only available to the owner.\n//      */\n//     function renounceOwnership() public onlyOwner {\n//         emit OwnershipTransferred(_owner, address(0));\n//         _owner = address(0);\n//     }\n\n//     /**\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\n//      * Can only be called by the current owner.\n//      */\n//     function transferOwnership(address newOwner) public onlyOwner {\n//         _transferOwnership(newOwner);\n//     }\n\n//     /**\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\n//      */\n//     function _transferOwnership(address newOwner) internal {\n//         require(\n//             newOwner != address(0),\n//             \"Ownable: new owner is the zero address\"\n//         );\n//         emit OwnershipTransferred(_owner, newOwner);\n//         _owner = newOwner;\n//     }\n// }\n\n// /**\n//  *\n//  * @dev Wrappers over Solidity's arithmetic operations with added overflow\n//  * checks.\n//  *\n//  * Arithmetic operations in Solidity wrap on overflow. This can easily result\n//  * in bugs, because programmers usually assume that an overflow raises an\n//  * error, which is the standard behavior in high level programming languages.\n//  * `SafeMath` restores this intuition by reverting the transaction when an\n//  * operation overflows.\n//  *\n//  * Using this library instead of the unchecked operations eliminates an entire\n//  * class of bugs, so it's recommended to use it always.\n//  *\n//  */\n// library SafeMath {\n//     /**\n//      * @dev Returns the addition of two unsigned integers, reverting on\n//      * overflow.\n//      *\n//      * Counterpart to Solidity's `+` operator.\n//      *\n//      * Requirements:\n//      * - Addition cannot overflow.\n//      */\n//     function add(uint256 a, uint256 b) internal pure returns (uint256) {\n//         uint256 c = a + b;\n//         require(c >= a, \"SafeMath: addition overflow\");\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the subtraction of two unsigned integers, reverting on\n//      * overflow (when the result is negative).\n//      *\n//      * Counterpart to Solidity's `-` operator.\n//      *\n//      * Requirements:\n//      * - Subtraction cannot overflow.\n//      */\n//     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b <= a, \"SafeMath: subtraction overflow\");\n//         uint256 c = a - b;\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the multiplication of two unsigned integers, reverting on\n//      * overflow.\n//      *\n//      * Counterpart to Solidity's `*` operator.\n//      *\n//      * Requirements:\n//      * - Multiplication cannot overflow.\n//      */\n//     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n//         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n//         // benefit is lost if 'b' is also tested.\n//         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n//         if (a == 0) {\n//             return 0;\n//         }\n\n//         uint256 c = a * b;\n//         require(c / a == b, \"SafeMath: multiplication overflow\");\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the integer division of two unsigned integers. Reverts on\n//      * division by zero. The result is rounded towards zero.\n//      *\n//      * Counterpart to Solidity's `/` operator. Note: this function uses a\n//      * `revert` opcode (which leaves remaining gas untouched) while Solidity\n//      * uses an invalid opcode to revert (consuming all remaining gas).\n//      *\n//      * Requirements:\n//      * - The divisor cannot be zero.\n//      */\n//     function div(uint256 a, uint256 b) internal pure returns (uint256) {\n//         // Solidity only automatically asserts when dividing by 0\n//         require(b > 0, \"SafeMath: division by zero\");\n//         uint256 c = a / b;\n//         // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n//         return c;\n//     }\n\n//     /**\n//      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n//      * Reverts when dividing by zero.\n//      *\n//      * Counterpart to Solidity's `%` operator. This function uses a `revert`\n//      * opcode (which leaves remaining gas untouched) while Solidity uses an\n//      * invalid opcode to revert (consuming all remaining gas).\n//      *\n//      * Requirements:\n//      * - The divisor cannot be zero.\n//      */\n//     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n//         require(b != 0, \"SafeMath: modulo by zero\");\n//         return a % b;\n//     }\n// }\n\n// /**\n//  * @dev Interface of the KIP-13 standard, as defined in the\n//  * [KIP-13](http://kips.klaytn.com/KIPs/kip-13-interface_query_standard).\n//  *\n//  * Implementers can declare support of contract interfaces, which can then be\n//  * queried by others.\n//  *\n//  * For an implementation, see `KIP13`.\n//  */\n// interface IKIP13 {\n//     /**\n//      * @dev Returns true if this contract implements the interface defined by\n//      * `interfaceId`. See the corresponding\n//      * [KIP-13 section](http://kips.klaytn.com/KIPs/kip-13-interface_query_standard#how-interface-identifiers-are-defined)\n//      * to learn more about how these ids are created.\n//      *\n//      * This function call must use less than 30 000 gas.\n//      */\n//     function supportsInterface(bytes4 interfaceId) external view returns (bool);\n// }\n\n// /**\n//  * @title Roles\n//  * @dev Library for managing addresses assigned to a Role.\n//  */\n// library Roles {\n//     struct Role {\n//         mapping(address => bool) bearer;\n//     }\n\n//     /**\n//      * @dev Give an account access to this role.\n//      */\n//     function add(Role storage role, address account) internal {\n//         require(!has(role, account), \"Roles: account already has role\");\n//         role.bearer[account] = true;\n//     }\n\n//     /**\n//      * @dev Remove an account's access to this role.\n//      */\n//     function remove(Role storage role, address account) internal {\n//         require(has(role, account), \"Roles: account does not have role\");\n//         role.bearer[account] = false;\n//     }\n\n//     /**\n//      * @dev Check if an account has this role.\n//      * @return bool\n//      */\n//     function has(Role storage role, address account)\n//         internal\n//         view\n//         returns (bool)\n//     {\n//         require(account != address(0), \"Roles: account is the zero address\");\n//         return role.bearer[account];\n//     }\n// }\n\n// contract PauserRole {\n//     using Roles for Roles.Role;\n\n//     event PauserAdded(address indexed account);\n//     event PauserRemoved(address indexed account);\n\n//     Roles.Role private _pausers;\n\n//     constructor() internal {\n//         _addPauser(msg.sender);\n//     }\n\n//     modifier onlyPauser() {\n//         require(\n//             isPauser(msg.sender),\n//             \"PauserRole: caller does not have the Pauser role\"\n//         );\n//         _;\n//     }\n\n//     function isPauser(address account) public view returns (bool) {\n//         return _pausers.has(account);\n//     }\n\n//     function addPauser(address account) public onlyPauser {\n//         _addPauser(account);\n//     }\n\n//     function renouncePauser() public {\n//         _removePauser(msg.sender);\n//     }\n\n//     function _addPauser(address account) internal {\n//         _pausers.add(account);\n//         emit PauserAdded(account);\n//     }\n\n//     function _removePauser(address account) internal {\n//         _pausers.remove(account);\n//         emit PauserRemoved(account);\n//     }\n// }\n\n// /**\n//  * @dev Implementation of the `IKIP13` interface.\n//  *\n//  * Contracts may inherit from this and call `_registerInterface` to declare\n//  * their support of an interface.\n//  */\n// contract KIP13 is IKIP13 {\n//     /*\n//      * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP13 = 0x01ffc9a7;\n\n//     /**\n//      * @dev Mapping of interface ids to whether or not it's supported.\n//      */\n//     mapping(bytes4 => bool) private _supportedInterfaces;\n\n//     constructor() internal {\n//         // Derived contracts need only register support for their own interfaces,\n//         // we register support for KIP13 itself here\n//         _registerInterface(_INTERFACE_ID_KIP13);\n//     }\n\n//     /**\n//      * @dev See `IKIP13.supportsInterface`.\n//      *\n//      * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n//      */\n//     function supportsInterface(bytes4 interfaceId)\n//         external\n//         view\n//         returns (bool)\n//     {\n//         return _supportedInterfaces[interfaceId];\n//     }\n\n//     /**\n//      * @dev Registers the contract as an implementer of the interface defined by\n//      * `interfaceId`. Support of the actual KIP13 interface is automatic and\n//      * registering its interface id is not required.\n//      *\n//      * See `IKIP13.supportsInterface`.\n//      *\n//      * Requirements:\n//      *\n//      * - `interfaceId` cannot be the KIP13 invalid interface (`0xffffffff`).\n//      */\n//     function _registerInterface(bytes4 interfaceId) internal {\n//         require(interfaceId != 0xffffffff, \"KIP13: invalid interface id\");\n//         _supportedInterfaces[interfaceId] = true;\n//     }\n// }\n\n// /**\n//  * @dev Required interface of an KIP17 compliant contract.\n//  */\n// contract IKIP17 is IKIP13 {\n//     event Transfer(\n//         address indexed from,\n//         address indexed to,\n//         uint256 indexed tokenId\n//     );\n//     event Approval(\n//         address indexed owner,\n//         address indexed approved,\n//         uint256 indexed tokenId\n//     );\n//     event ApprovalForAll(\n//         address indexed owner,\n//         address indexed operator,\n//         bool approved\n//     );\n\n//     /**\n//      * @dev Returns the number of NFTs in `owner`'s account.\n//      */\n//     function balanceOf(address owner) public view returns (uint256 balance);\n\n//     /**\n//      * @dev Returns the owner of the NFT specified by `tokenId`.\n//      */\n//     function ownerOf(uint256 tokenId) public view returns (address owner);\n\n//     /**\n//      * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n//      * another (`to`).\n//      *\n//      * Requirements:\n//      * - `from`, `to` cannot be zero.\n//      * - `tokenId` must be owned by `from`.\n//      * - If the caller is not `from`, it must be have been allowed to move this\n//      * NFT by either `approve` or `setApproveForAll`.\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public;\n\n//     /**\n//      * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n//      * another (`to`).\n//      *\n//      * Requirements:\n//      * - If the caller is not `from`, it must be approved to move this NFT by\n//      * either `approve` or `setApproveForAll`.\n//      */\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public;\n\n//     function approve(address to, uint256 tokenId) public;\n\n//     function getApproved(uint256 tokenId)\n//         public\n//         view\n//         returns (address operator);\n\n//     function setApprovalForAll(address operator, bool _approved) public;\n\n//     function isApprovedForAll(address owner, address operator)\n//         public\n//         view\n//         returns (bool);\n\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public;\n// }\n\n// /**\n//  * @title ERC721 token receiver interface\n//  * @dev Interface for any contract that wants to support safeTransfers\n//  * from ERC721 asset contracts.\n//  */\n// contract IERC721Receiver {\n//     /**\n//      * @notice Handle the receipt of an NFT\n//      * @dev The ERC721 smart contract calls this function on the recipient\n//      * after a `safeTransfer`. This function MUST return the function selector,\n//      * otherwise the caller will revert the transaction. The selector to be\n//      * returned can be obtained as `this.onERC721Received.selector`. This\n//      * function MAY throw to revert and reject the transfer.\n//      * Note: the ERC721 contract address is always the message sender.\n//      * @param operator The address which called `safeTransferFrom` function\n//      * @param from The address which previously owned the token\n//      * @param tokenId The NFT identifier which is being transferred\n//      * @param data Additional data with no specified format\n//      * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n//      */\n//     function onERC721Received(\n//         address operator,\n//         address from,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public returns (bytes4);\n// }\n\n// /**\n//  * @title KIP17 token receiver interface\n//  * @dev Interface for any contract that wants to support safeTransfers\n//  * from KIP17 asset contracts.\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Receiver {\n//     /**\n//      * @notice Handle the receipt of an NFT\n//      * @dev The KIP17 smart contract calls this function on the recipient\n//      * after a `safeTransfer`. This function MUST return the function selector,\n//      * otherwise the caller will revert the transaction. The selector to be\n//      * returned can be obtained as `this.onKIP17Received.selector`. This\n//      * function MAY throw to revert and reject the transfer.\n//      * Note: the KIP17 contract address is always the message sender.\n//      * @param operator The address which called `safeTransferFrom` function\n//      * @param from The address which previously owned the token\n//      * @param tokenId The NFT identifier which is being transferred\n//      * @param data Additional data with no specified format\n//      * @return bytes4 `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`\n//      */\n//     function onKIP17Received(\n//         address operator,\n//         address from,\n//         uint256 tokenId,\n//         bytes memory data\n//     ) public returns (bytes4);\n// }\n\n// /**\n//  * @dev Collection of functions related to the address type,\n//  */\n// library Address {\n//     /**\n//      * @dev Returns true if `account` is a contract.\n//      *\n//      * This test is non-exhaustive, and there may be false-negatives: during the\n//      * execution of a contract's constructor, its address will be reported as\n//      * not containing a contract.\n//      *\n//      * > It is unsafe to assume that an address for which this function returns\n//      * false is an externally-owned account (EOA) and not a contract.\n//      */\n//     function isContract(address account) internal view returns (bool) {\n//         // This method relies in extcodesize, which returns 0 for contracts in\n//         // construction, since the code is only stored at the end of the\n//         // constructor execution.\n\n//         uint256 size;\n//         // solhint-disable-next-line no-inline-assembly\n//         assembly {\n//             size := extcodesize(account)\n//         }\n//         return size > 0;\n//     }\n// }\n\n// /**\n//  * @title Counters\n//  * @author Matt Condon (@shrugs)\n//  * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n//  * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n//  *\n//  * Include with `using Counters for Counters.Counter;`\n//  * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n//  * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n//  * directly accessed.\n//  */\n// library Counters {\n//     using SafeMath for uint256;\n\n//     struct Counter {\n//         // This variable should never be directly accessed by users of the library: interactions must be restricted to\n//         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n//         // this feature: see https://github.com/ethereum/solidity/issues/4637\n//         uint256 _value; // default: 0\n//     }\n\n//     function current(Counter storage counter) internal view returns (uint256) {\n//         return counter._value;\n//     }\n\n//     function increment(Counter storage counter) internal {\n//         counter._value += 1;\n//     }\n\n//     function decrement(Counter storage counter) internal {\n//         counter._value = counter._value.sub(1);\n//     }\n// }\n\n// /**\n//  * @title KIP17 Non-Fungible Token Standard basic implementation\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17 is KIP13, IKIP17 {\n//     using SafeMath for uint256;\n//     using Address for address;\n//     using Counters for Counters.Counter;\n\n//     // Equals to `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`\n//     // which can be also obtained as `IKIP17Receiver(0).onKIP17Received.selector`\n//     bytes4 private constant _KIP17_RECEIVED = 0x6745782b;\n\n//     // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n//     // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n//     bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n//     // Mapping from token ID to owner\n//     mapping(uint256 => address) private _tokenOwner;\n\n//     // Mapping from token ID to approved address\n//     mapping(uint256 => address) private _tokenApprovals;\n\n//     // Mapping from owner to number of owned token\n//     mapping(address => Counters.Counter) private _ownedTokensCount;\n\n//     // Mapping from owner to operator approvals\n//     mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n//     /*\n//      *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n//      *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n//      *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n//      *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n//      *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n//      *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c\n//      *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n//      *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n//      *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n//      *\n//      *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n//      *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17 = 0x80ac58cd;\n\n//     constructor() public {\n//         // register the supported interfaces to conform to KIP17 via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17);\n//     }\n\n//     /**\n//      * @dev Gets the balance of the specified address.\n//      * @param owner address to query the balance of\n//      * @return uint256 representing the amount owned by the passed address\n//      */\n//     function balanceOf(address owner) public view returns (uint256) {\n//         require(\n//             owner != address(0),\n//             \"KIP17: balance query for the zero address\"\n//         );\n\n//         return _ownedTokensCount[owner].current();\n//     }\n\n//     /**\n//      * @dev Gets the owner of the specified token ID.\n//      * @param tokenId uint256 ID of the token to query the owner of\n//      * @return address currently marked as the owner of the given token ID\n//      */\n//     function ownerOf(uint256 tokenId) public view returns (address) {\n//         address owner = _tokenOwner[tokenId];\n//         require(\n//             owner != address(0),\n//             \"KIP17: owner query for nonexistent token\"\n//         );\n\n//         return owner;\n//     }\n\n//     /**\n//      * @dev Approves another address to transfer the given token ID\n//      * The zero address indicates there is no approved address.\n//      * There can only be one approved address per token at a given time.\n//      * Can only be called by the token owner or an approved operator.\n//      * @param to address to be approved for the given token ID\n//      * @param tokenId uint256 ID of the token to be approved\n//      */\n//     function approve(address to, uint256 tokenId) public {\n//         address owner = ownerOf(tokenId);\n//         require(to != owner, \"KIP17: approval to current owner\");\n\n//         require(\n//             msg.sender == owner || isApprovedForAll(owner, msg.sender),\n//             \"KIP17: approve caller is not owner nor approved for all\"\n//         );\n\n//         _tokenApprovals[tokenId] = to;\n//         emit Approval(owner, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Gets the approved address for a token ID, or zero if no address set\n//      * Reverts if the token ID does not exist.\n//      * @param tokenId uint256 ID of the token to query the approval of\n//      * @return address currently approved for the given token ID\n//      */\n//     function getApproved(uint256 tokenId) public view returns (address) {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17: approved query for nonexistent token\"\n//         );\n\n//         return _tokenApprovals[tokenId];\n//     }\n\n//     /**\n//      * @dev Sets or unsets the approval of a given operator\n//      * An operator is allowed to transfer all tokens of the sender on their behalf.\n//      * @param to operator address to set the approval\n//      * @param approved representing the status of the approval to be set\n//      */\n//     function setApprovalForAll(address to, bool approved) public {\n//         require(to != msg.sender, \"KIP17: approve to caller\");\n\n//         _operatorApprovals[msg.sender][to] = approved;\n//         emit ApprovalForAll(msg.sender, to, approved);\n//     }\n\n//     /**\n//      * @dev Tells whether an operator is approved by a given owner.\n//      * @param owner owner address which you want to query the approval of\n//      * @param operator operator address which you want to query the approval of\n//      * @return bool whether the given operator is approved by the given owner\n//      */\n//     function isApprovedForAll(address owner, address operator)\n//         public\n//         view\n//         returns (bool)\n//     {\n//         return _operatorApprovals[owner][operator];\n//     }\n\n//     /**\n//      * @dev Transfers the ownership of a given token ID to another address.\n//      * Usage of this method is discouraged, use `safeTransferFrom` whenever possible.\n//      * Requires the msg.sender to be the owner, approved, or operator.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public {\n//         //solhint-disable-next-line max-line-length\n//         require(\n//             _isApprovedOrOwner(msg.sender, tokenId),\n//             \"KIP17: transfer caller is not owner nor approved\"\n//         );\n\n//         _transferFrom(from, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Safely transfers the ownership of a given token ID to another address\n//      * If the target address is a contract, it must implement `onKIP17Received`,\n//      * which is called upon a safe transfer, and return the magic value\n//      * `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`; otherwise,\n//      * the transfer is reverted.\n//      * Requires the msg.sender to be the owner, approved, or operator\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public {\n//         safeTransferFrom(from, to, tokenId, \"\");\n//     }\n\n//     /**\n//      * @dev Safely transfers the ownership of a given token ID to another address\n//      * If the target address is a contract, it must implement `onKIP17Received`,\n//      * which is called upon a safe transfer, and return the magic value\n//      * `bytes4(keccak256(\"onKIP17Received(address,address,uint256,bytes)\"))`; otherwise,\n//      * the transfer is reverted.\n//      * Requires the msg.sender to be the owner, approved, or operator\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @param _data bytes data to send along with a safe transfer check\n//      */\n//     function safeTransferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory _data\n//     ) public {\n//         transferFrom(from, to, tokenId);\n//         require(\n//             _checkOnKIP17Received(from, to, tokenId, _data),\n//             \"KIP17: transfer to non KIP17Receiver implementer\"\n//         );\n//     }\n\n//     /**\n//      * @dev Returns whether the specified token exists.\n//      * @param tokenId uint256 ID of the token to query the existence of\n//      * @return bool whether the token exists\n//      */\n//     function _exists(uint256 tokenId) internal view returns (bool) {\n//         address owner = _tokenOwner[tokenId];\n//         return owner != address(0);\n//     }\n\n//     /**\n//      * @dev Returns whether the given spender can transfer a given token ID.\n//      * @param spender address of the spender to query\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @return bool whether the msg.sender is approved for the given token ID,\n//      * is an operator of the owner, or is the owner of the token\n//      */\n//     function _isApprovedOrOwner(address spender, uint256 tokenId)\n//         internal\n//         view\n//         returns (bool)\n//     {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17: operator query for nonexistent token\"\n//         );\n//         address owner = ownerOf(tokenId);\n//         return (spender == owner ||\n//             getApproved(tokenId) == spender ||\n//             isApprovedForAll(owner, spender));\n//     }\n\n//     /**\n//      * @dev Internal function to mint a new token.\n//      * Reverts if the given token ID already exists.\n//      * @param to The address that will own the minted token\n//      * @param tokenId uint256 ID of the token to be minted\n//      */\n//     function _mint(address to, uint256 tokenId) internal {\n//         require(to != address(0), \"KIP17: mint to the zero address\");\n//         require(!_exists(tokenId), \"KIP17: token already minted\");\n\n//         _tokenOwner[tokenId] = to;\n//         _ownedTokensCount[to].increment();\n\n//         emit Transfer(address(0), to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         require(\n//             ownerOf(tokenId) == owner,\n//             \"KIP17: burn of token that is not own\"\n//         );\n\n//         _clearApproval(tokenId);\n\n//         _ownedTokensCount[owner].decrement();\n//         _tokenOwner[tokenId] = address(0);\n\n//         emit Transfer(owner, address(0), tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(uint256 tokenId) internal {\n//         _burn(ownerOf(tokenId), tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to transfer ownership of a given token ID to another address.\n//      * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) internal {\n//         require(\n//             ownerOf(tokenId) == from,\n//             \"KIP17: transfer of token that is not own\"\n//         );\n//         require(to != address(0), \"KIP17: transfer to the zero address\");\n\n//         _clearApproval(tokenId);\n\n//         _ownedTokensCount[from].decrement();\n//         _ownedTokensCount[to].increment();\n\n//         _tokenOwner[tokenId] = to;\n\n//         emit Transfer(from, to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to invoke `onKIP17Received` on a target address.\n//      * The call is not executed if the target address is not a contract.\n//      *\n//      * This function is deprecated.\n//      * @param from address representing the previous owner of the given token ID\n//      * @param to target address that will receive the tokens\n//      * @param tokenId uint256 ID of the token to be transferred\n//      * @param _data bytes optional data to send along with the call\n//      * @return bool whether the call correctly returned the expected magic value\n//      */\n//     function _checkOnKIP17Received(\n//         address from,\n//         address to,\n//         uint256 tokenId,\n//         bytes memory _data\n//     ) internal returns (bool) {\n//         if (!to.isContract()) {\n//             return true;\n//         }\n\n//         // Logic for compatibility with ERC721.\n//         bytes4 retval = IERC721Receiver(to).onERC721Received(\n//             msg.sender,\n//             from,\n//             tokenId,\n//             _data\n//         );\n//         if (retval == _ERC721_RECEIVED) {\n//             return true;\n//         }\n\n//         retval = IKIP17Receiver(to).onKIP17Received(\n//             msg.sender,\n//             from,\n//             tokenId,\n//             _data\n//         );\n//         return (retval == _KIP17_RECEIVED);\n//     }\n\n//     /**\n//      * @dev Private function to clear current approval of a given token ID.\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _clearApproval(uint256 tokenId) private {\n//         if (_tokenApprovals[tokenId] != address(0)) {\n//             _tokenApprovals[tokenId] = address(0);\n//         }\n//     }\n// }\n\n// contract MinterRole {\n//     using Roles for Roles.Role;\n\n//     event MinterAdded(address indexed account);\n//     event MinterRemoved(address indexed account);\n\n//     Roles.Role private _minters;\n\n//     constructor() internal {\n//         _addMinter(msg.sender);\n//     }\n\n//     modifier onlyMinter() {\n//         require(\n//             isMinter(msg.sender),\n//             \"MinterRole: caller does not have the Minter role\"\n//         );\n//         _;\n//     }\n\n//     function isMinter(address account) public view returns (bool) {\n//         return _minters.has(account);\n//     }\n\n//     function addMinter(address account) public onlyMinter {\n//         _addMinter(account);\n//     }\n\n//     function renounceMinter() public {\n//         _removeMinter(msg.sender);\n//     }\n\n//     function _addMinter(address account) internal {\n//         _minters.add(account);\n//         emit MinterAdded(account);\n//     }\n\n//     function _removeMinter(address account) internal {\n//         _minters.remove(account);\n//         emit MinterRemoved(account);\n//     }\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token Standard, optional metadata extension\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Metadata is IKIP17 {\n//     function name() external view returns (string memory);\n\n//     function symbol() external view returns (string memory);\n\n//     function tokenURI(uint256 tokenId) external view returns (string memory);\n// }\n\n// contract KIP17Metadata is KIP13, KIP17, IKIP17Metadata {\n//     // Token name\n//     string private _name;\n\n//     // Token symbol\n//     string private _symbol;\n\n//     // Optional mapping for token URIs\n//     mapping(uint256 => string) private _tokenURIs;\n\n//     /*\n//      *     bytes4(keccak256('name()')) == 0x06fdde03\n//      *     bytes4(keccak256('symbol()')) == 0x95d89b41\n//      *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n//      *\n//      *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_METADATA = 0x5b5e139f;\n\n//     /**\n//      * @dev Constructor function\n//      */\n//     constructor(string memory name, string memory symbol) public {\n//         _name = name;\n//         _symbol = symbol;\n\n//         // register the supported interfaces to conform to KIP17 via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_METADATA);\n//     }\n\n//     /**\n//      * @dev Gets the token name.\n//      * @return string representing the token name\n//      */\n//     function name() external view returns (string memory) {\n//         return _name;\n//     }\n\n//     /**\n//      * @dev Gets the token symbol.\n//      * @return string representing the token symbol\n//      */\n//     function symbol() external view returns (string memory) {\n//         return _symbol;\n//     }\n\n//     /**\n//      * @dev Returns an URI for a given token ID.\n//      * Throws if the token ID does not exist. May return an empty string.\n//      * @param tokenId uint256 ID of the token to query\n//      */\n//     function tokenURI(uint256 tokenId) external view returns (string memory) {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17Metadata: URI query for nonexistent token\"\n//         );\n//         return _tokenURIs[tokenId];\n//     }\n\n//     /**\n//      * @dev Internal function to set the token URI for a given token.\n//      * Reverts if the token ID does not exist.\n//      * @param tokenId uint256 ID of the token to set its URI\n//      * @param uri string URI to assign\n//      */\n//     function _setTokenURI(uint256 tokenId, string memory uri) internal {\n//         require(\n//             _exists(tokenId),\n//             \"KIP17Metadata: URI set of nonexistent token\"\n//         );\n//         _tokenURIs[tokenId] = uri;\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned by the msg.sender\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         super._burn(owner, tokenId);\n\n//         // Clear metadata (if any)\n//         if (bytes(_tokenURIs[tokenId]).length != 0) {\n//             delete _tokenURIs[tokenId];\n//         }\n//     }\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token Standard, optional enumeration extension\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract IKIP17Enumerable is IKIP17 {\n//     function totalSupply() public view returns (uint256);\n\n//     function tokenOfOwnerByIndex(address owner, uint256 index)\n//         public\n//         view\n//         returns (uint256 tokenId);\n\n//     function tokenByIndex(uint256 index) public view returns (uint256);\n// }\n\n// /**\n//  * @title KIP-17 Non-Fungible Token with optional enumeration extension logic\n//  * @dev See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Enumerable is KIP13, KIP17, IKIP17Enumerable {\n//     // Mapping from owner to list of owned token IDs\n//     mapping(address => uint256[]) private _ownedTokens;\n\n//     // Mapping from token ID to index of the owner tokens list\n//     mapping(uint256 => uint256) private _ownedTokensIndex;\n\n//     // Array with all token ids, used for enumeration\n//     uint256[] private _allTokens;\n\n//     // Mapping from token id to position in the allTokens array\n//     mapping(uint256 => uint256) private _allTokensIndex;\n\n//     /*\n//      *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n//      *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n//      *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n//      *\n//      *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_ENUMERABLE = 0x780e9d63;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Enumerable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_ENUMERABLE);\n//     }\n\n//     /**\n//      * @dev Gets the token ID at a given index of the tokens list of the requested owner.\n//      * @param owner address owning the tokens list to be accessed\n//      * @param index uint256 representing the index to be accessed of the requested tokens list\n//      * @return uint256 token ID at the given index of the tokens list owned by the requested address\n//      */\n//     function tokenOfOwnerByIndex(address owner, uint256 index)\n//         public\n//         view\n//         returns (uint256)\n//     {\n//         require(\n//             index < balanceOf(owner),\n//             \"KIP17Enumerable: owner index out of bounds\"\n//         );\n//         return _ownedTokens[owner][index];\n//     }\n\n//     /**\n//      * @dev Gets the total amount of tokens stored by the contract.\n//      * @return uint256 representing the total amount of tokens\n//      */\n//     function totalSupply() public view returns (uint256) {\n//         return _allTokens.length;\n//     }\n\n//     /**\n//      * @dev Gets the token ID at a given index of all the tokens in this contract\n//      * Reverts if the index is greater or equal to the total number of tokens.\n//      * @param index uint256 representing the index to be accessed of the tokens list\n//      * @return uint256 token ID at the given index of the tokens list\n//      */\n//     function tokenByIndex(uint256 index) public view returns (uint256) {\n//         require(\n//             index < totalSupply(),\n//             \"KIP17Enumerable: global index out of bounds\"\n//         );\n//         return _allTokens[index];\n//     }\n\n//     /**\n//      * @dev Internal function to transfer ownership of a given token ID to another address.\n//      * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n//      * @param from current owner of the token\n//      * @param to address to receive the ownership of the given token ID\n//      * @param tokenId uint256 ID of the token to be transferred\n//      */\n//     function _transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) internal {\n//         super._transferFrom(from, to, tokenId);\n\n//         _removeTokenFromOwnerEnumeration(from, tokenId);\n\n//         _addTokenToOwnerEnumeration(to, tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to mint a new token.\n//      * Reverts if the given token ID already exists.\n//      * @param to address the beneficiary that will own the minted token\n//      * @param tokenId uint256 ID of the token to be minted\n//      */\n//     function _mint(address to, uint256 tokenId) internal {\n//         super._mint(to, tokenId);\n\n//         _addTokenToOwnerEnumeration(to, tokenId);\n\n//         _addTokenToAllTokensEnumeration(tokenId);\n//     }\n\n//     /**\n//      * @dev Internal function to burn a specific token.\n//      * Reverts if the token does not exist.\n//      * Deprecated, use _burn(uint256) instead.\n//      * @param owner owner of the token to burn\n//      * @param tokenId uint256 ID of the token being burned\n//      */\n//     function _burn(address owner, uint256 tokenId) internal {\n//         super._burn(owner, tokenId);\n\n//         _removeTokenFromOwnerEnumeration(owner, tokenId);\n//         // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n//         _ownedTokensIndex[tokenId] = 0;\n\n//         _removeTokenFromAllTokensEnumeration(tokenId);\n//     }\n\n//     /**\n//      * @dev Gets the list of token IDs of the requested owner.\n//      * @param owner address owning the tokens\n//      * @return uint256[] List of token IDs owned by the requested address\n//      */\n//     function _tokensOfOwner(address owner)\n//         internal\n//         view\n//         returns (uint256[] storage)\n//     {\n//         return _ownedTokens[owner];\n//     }\n\n//     /**\n//      * @dev Private function to add a token to this extension's ownership-tracking data structures.\n//      * @param to address representing the new owner of the given token ID\n//      * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n//      */\n//     function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n//         _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n//         _ownedTokens[to].push(tokenId);\n//     }\n\n//     /**\n//      * @dev Private function to add a token to this extension's token tracking data structures.\n//      * @param tokenId uint256 ID of the token to be added to the tokens list\n//      */\n//     function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n//         _allTokensIndex[tokenId] = _allTokens.length;\n//         _allTokens.push(tokenId);\n//     }\n\n//     /**\n//      * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n//      * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n//      * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n//      * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n//      * @param from address representing the previous owner of the given token ID\n//      * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n//      */\n//     function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n//         private\n//     {\n//         // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n//         // then delete the last slot (swap and pop).\n\n//         uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n//         uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n//         // When the token to delete is the last token, the swap operation is unnecessary\n//         if (tokenIndex != lastTokenIndex) {\n//             uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n//             _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n//             _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n//         }\n\n//         // This also deletes the contents at the last position of the array\n//         _ownedTokens[from].length--;\n\n//         // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n//         // lastTokenId, or just over the end of the array if the token was the last one).\n//     }\n\n//     /**\n//      * @dev Private function to remove a token from this extension's token tracking data structures.\n//      * This has O(1) time complexity, but alters the order of the _allTokens array.\n//      * @param tokenId uint256 ID of the token to be removed from the tokens list\n//      */\n//     function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n//         // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n//         // then delete the last slot (swap and pop).\n\n//         uint256 lastTokenIndex = _allTokens.length.sub(1);\n//         uint256 tokenIndex = _allTokensIndex[tokenId];\n\n//         // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n//         // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n//         // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n//         uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n//         _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n//         _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n//         // This also deletes the contents at the last position of the array\n//         _allTokens.length--;\n//         _allTokensIndex[tokenId] = 0;\n//     }\n// }\n\n// /**\n//  * @title Full KIP-17 Token\n//  * This implementation includes all the required and some optional functionality of the KIP-17 standard\n//  * Moreover, it includes approve all functionality using operator terminology\n//  * @dev see http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Full is KIP17, KIP17Enumerable, KIP17Metadata {\n//     constructor(string memory name, string memory symbol)\n//         public\n//         KIP17Metadata(name, symbol)\n//     {\n//         // solhint-disable-previous-line no-empty-blocks\n//     }\n// }\n\n// /**\n//  * @title KIP17MetadataMintable\n//  * @dev KIP17 minting logic with metadata.\n//  */\n// contract KIP17MetadataMintable is KIP13, KIP17, KIP17Metadata, MinterRole {\n//     /*\n//      *     bytes4(keccak256('mintWithTokenURI(address,uint256,string)')) == 0x50bb4e7f\n//      *     bytes4(keccak256('isMinter(address)')) == 0xaa271e1a\n//      *     bytes4(keccak256('addMinter(address)')) == 0x983b2d56\n//      *     bytes4(keccak256('renounceMinter()')) == 0x98650275\n//      *\n//      *     => 0x50bb4e7f ^ 0xaa271e1a ^ 0x983b2d56 ^ 0x98650275 == 0xfac27f46\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_METADATA_MINTABLE = 0xfac27f46;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Mintable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_METADATA_MINTABLE);\n//     }\n\n//     /**\n//      * @dev Function to mint tokens.\n//      * @param to The address that will receive the minted tokens.\n//      * @param tokenId The token id to mint.\n//      * @param tokenURI The token URI of the minted token.\n//      * @return A boolean that indicates if the operation was successful.\n//      */\n//     function mintWithTokenURI(\n//         address to,\n//         uint256 tokenId,\n//         string memory tokenURI\n//     ) public onlyMinter returns (bool) {\n//         _mint(to, tokenId);\n//         _setTokenURI(tokenId, tokenURI);\n//         return true;\n//     }\n// }\n\n// /**\n//  * @title KIP17Mintable\n//  * @dev KIP17 minting logic.\n//  */\n// contract KIP17Mintable is KIP17, MinterRole {\n//     /*\n//      *     bytes4(keccak256('isMinter(address)')) == 0xaa271e1a\n//      *     bytes4(keccak256('addMinter(address)')) == 0x983b2d56\n//      *     bytes4(keccak256('renounceMinter()')) == 0x98650275\n//      *     bytes4(keccak256('mint(address,uint256)')) == 0x40c10f19\n//      *\n//      *     => 0xaa271e1a ^ 0x983b2d56 ^ 0x98650275 ^ 0x40c10f19 == 0xeab83e20\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_MINTABLE = 0xeab83e20;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Mintable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_MINTABLE);\n//     }\n\n//     /**\n//      * @dev Function to mint tokens.\n//      * @param to The address that will receive the minted tokens.\n//      * @param tokenId The token id to mint.\n//      * @return A boolean that indicates if the operation was successful.\n//      */\n//     function mint(address to, uint256 tokenId)\n//         public\n//         onlyMinter\n//         returns (bool)\n//     {\n//         _mint(to, tokenId);\n//         return true;\n//     }\n// }\n\n// /**\n//  * @title KIP17 Burnable Token\n//  * @dev KIP17 Token that can be irreversibly burned (destroyed).\n//  * See http://kips.klaytn.com/KIPs/kip-17-non_fungible_token\n//  */\n// contract KIP17Burnable is KIP13, KIP17 {\n//     /*\n//      *     bytes4(keccak256('burn(uint256)')) == 0x42966c68\n//      *\n//      *     => 0x42966c68 == 0x42966c68\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_BURNABLE = 0x42966c68;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Burnable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_BURNABLE);\n//     }\n\n//     /**\n//      * @dev Burns a specific KIP17 token.\n//      * @param tokenId uint256 id of the KIP17 token to be burned.\n//      */\n//     function burn(uint256 tokenId) public {\n//         //solhint-disable-next-line max-line-length\n//         require(\n//             _isApprovedOrOwner(msg.sender, tokenId),\n//             \"KIP17Burnable: caller is not owner nor approved\"\n//         );\n//         _burn(tokenId);\n//     }\n// }\n\n// /**\n//  * @dev Contract module which allows children to implement an emergency stop\n//  * mechanism that can be triggered by an authorized account.\n//  *\n//  * This module is used through inheritance. It will make available the\n//  * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n//  * the functions of your contract. Note that they will not be pausable by\n//  * simply including this module, only once the modifiers are put in place.\n//  */\n// contract Pausable is PauserRole {\n//     /**\n//      * @dev Emitted when the pause is triggered by a pauser (`account`).\n//      */\n//     event Paused(address account);\n\n//     /**\n//      * @dev Emitted when the pause is lifted by a pauser (`account`).\n//      */\n//     event Unpaused(address account);\n\n//     bool private _paused;\n\n//     /**\n//      * @dev Initializes the contract in unpaused state. Assigns the Pauser role\n//      * to the deployer.\n//      */\n//     constructor() internal {\n//         _paused = false;\n//     }\n\n//     /**\n//      * @dev Returns true if the contract is paused, and false otherwise.\n//      */\n//     function paused() public view returns (bool) {\n//         return _paused;\n//     }\n\n//     /**\n//      * @dev Modifier to make a function callable only when the contract is not paused.\n//      */\n//     modifier whenNotPaused() {\n//         require(!_paused, \"Pausable: paused\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Modifier to make a function callable only when the contract is paused.\n//      */\n//     modifier whenPaused() {\n//         require(_paused, \"Pausable: not paused\");\n//         _;\n//     }\n\n//     /**\n//      * @dev Called by a pauser to pause, triggers stopped state.\n//      */\n//     function pause() public onlyPauser whenNotPaused {\n//         _paused = true;\n//         emit Paused(msg.sender);\n//     }\n\n//     /**\n//      * @dev Called by a pauser to unpause, returns to normal state.\n//      */\n//     function unpause() public onlyPauser whenPaused {\n//         _paused = false;\n//         emit Unpaused(msg.sender);\n//     }\n// }\n\n// /**\n//  * @title KIP17 Non-Fungible Pausable token\n//  * @dev KIP17 modified with pausable transfers.\n//  */\n// contract KIP17Pausable is KIP13, KIP17, Pausable {\n//     /*\n//      *     bytes4(keccak256('paused()')) == 0x5c975abb\n//      *     bytes4(keccak256('pause()')) == 0x8456cb59\n//      *     bytes4(keccak256('unpause()')) == 0x3f4ba83a\n//      *     bytes4(keccak256('isPauser(address)')) == 0x46fbf68e\n//      *     bytes4(keccak256('addPauser(address)')) == 0x82dc1ec4\n//      *     bytes4(keccak256('renouncePauser()')) == 0x6ef8d66d\n//      *\n//      *     => 0x5c975abb ^ 0x8456cb59 ^ 0x3f4ba83a ^ 0x46fbf68e ^ 0x82dc1ec4 ^ 0x6ef8d66d == 0x4d5507ff\n//      */\n//     bytes4 private constant _INTERFACE_ID_KIP17_PAUSABLE = 0x4d5507ff;\n\n//     /**\n//      * @dev Constructor function.\n//      */\n//     constructor() public {\n//         // register the supported interface to conform to KIP17Pausable via KIP13\n//         _registerInterface(_INTERFACE_ID_KIP17_PAUSABLE);\n//     }\n\n//     function approve(address to, uint256 tokenId) public whenNotPaused {\n//         super.approve(to, tokenId);\n//     }\n\n//     function setApprovalForAll(address to, bool approved) public whenNotPaused {\n//         super.setApprovalForAll(to, approved);\n//     }\n\n//     function transferFrom(\n//         address from,\n//         address to,\n//         uint256 tokenId\n//     ) public whenNotPaused {\n//         super.transferFrom(from, to, tokenId);\n//     }\n// }\n\n// // contract KIP17Token is\n// contract KIP17TokenTest is\n//     KIP17Full,\n//     KIP17Mintable,\n//     KIP17MetadataMintable,\n//     KIP17Burnable,\n//     KIP17Pausable,\n//     Ownable\n// {\n//     constructor(string memory name, string memory symbol)\n//         public\n//         KIP17Full(name, symbol)\n//     {}\n// }\n"
    },
    "contracts/tokens/vper/vper.sol": {
      "content": "// pragma solidity ^0.8.0;\n\n// // address : 0xc69ad53109892f1d5b0decf1917eabd0888e5082\n// // network : cypress\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}